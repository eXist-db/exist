/*
 * eXist-db Open Source Native XML Database
 * Copyright (C) 2001 The eXist-db Authors
 *
 * info@exist-db.org
 * http://www.exist-db.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 */
header {
	package org.exist.xquery.parser;

	import antlr.debug.misc.*;
	import java.io.StringReader;
	import java.io.BufferedReader;
	import java.io.InputStreamReader;
	import java.util.ArrayDeque;
	import java.util.ArrayList;
	import java.util.Deque;
	import java.util.List;
	import java.util.Iterator;
	import org.exist.storage.BrokerPool;
	import org.exist.storage.DBBroker;
	import org.exist.EXistException;
	import org.exist.dom.persistent.DocumentSet;
	import org.exist.dom.persistent.DocumentImpl;
	import org.exist.dom.QName;
	import org.exist.security.PermissionDeniedException;
	import org.exist.xquery.*;
	import org.exist.xquery.value.*;
	import org.exist.xquery.functions.fn.*;
}

/**
eXist parses an XQuery expression in (currently) 4 phases:

1) lexical analysis in XQueryLexer
2) syntax analysis and construction of an intermediate AST (abstract
	syntax tree) in XQueryParser
3) analysis of the intermediate AST, and construction of the executable XQuery
	expression tree from the intermediate AST in {@link XQueryTreeParser}
4) static analysis of the final expression tree

The grammar in XQuery.g corresponds to phase 2. It generates an
intermediate AST which will then be parsed a second time by
XQueryTree.g.

ANTLR provides a special syntax for tree parsers. Every
action returns an AST node and the # references these nodes.
#[VARIABLE_BINDING, varName] constructs a new AST node of type
VARIABLE_BINDING, which is prepended to the default AST generated by
the production.

ANTLR's meta language for tree construction is described in the ANTLR reference manual:
http://www.antlr.org/doc/index.html .

 */
class XQueryParser extends Parser;

options {
	defaultErrorHandler= false;
	k= 1;
	buildAST= true;
	ASTLabelType = org.exist.xquery.parser.XQueryAST;
	exportVocab=XQuery;
}

{
	protected List<Exception> exceptions = new ArrayList<>(2);
	protected boolean foundError = false;
	protected Deque<Deque<String>> globalStack = new ArrayDeque<>();
	protected Deque<String> elementStack = new ArrayDeque<>();
	protected XQueryLexer lexer;

	public XQueryParser(XQueryLexer lexer) {
		this((TokenStream)lexer);
		this.lexer= lexer;
		setASTNodeClass("org.exist.xquery.parser.XQueryAST");
	}

	public boolean foundErrors() {
		return foundError;
	}

	public String getErrorMessage() {
		StringBuilder buf= new StringBuilder();
		for (Iterator i= exceptions.iterator(); i.hasNext();) {
			buf.append(((Exception) i.next()).toString());
			buf.append('\n');
		}
		return buf.toString();
	}

	public Exception getLastException() {
		return (Exception) exceptions.get(exceptions.size() - 1);
	}

	public String getXQDoc() {
		return lexer.getXQDoc();
	}

	protected void handleException(Exception e) {
		foundError= true;
		exceptions.add(e);
	}
}

/* The following tokens are assigned by the parser (not the lexer)
 * and have to be exported (so the tree parser can see them).
 */
imaginaryTokenDefinitions
:
	QNAME
	EQNAME
	PREDICATE
	FLWOR
	PARENTHESIZED
	ABSOLUTE_SLASH
	ABSOLUTE_DSLASH
	WILDCARD
	PREFIX_WILDCARD
	FUNCTION
	DYNAMIC_FCALL
	UNARY_MINUS
	UNARY_PLUS
	XPOINTER
	XPOINTER_ID
	VARIABLE_REF
	VARIABLE_BINDING
	ELEMENT
	ATTRIBUTE
	ATTRIBUTE_CONTENT
	TEXT
	VERSION_DECL
	NAMESPACE_DECL
	DEF_NAMESPACE_DECL
	DEF_COLLATION_DECL
	DEF_FUNCTION_NS_DECL
	CONTEXT_ITEM_DECL
	ANNOT_DECL
	GLOBAL_VAR
	FUNCTION_DECL
	INLINE_FUNCTION_DECL
	FUNCTION_INLINE
	FUNCTION_TEST
	MAP
	MAP_TEST
	LOOKUP
	ARRAY
	ARRAY_TEST
	PROLOG
	OPTION
	ATOMIC_TYPE
	MODULE
	ORDER_BY
    GROUP_BY
	POSITIONAL_VAR
	CATCH_ERROR_CODE
	CATCH_ERROR_DESC
	CATCH_ERROR_VAL
	MODULE_DECL
	MODULE_IMPORT
	SCHEMA_IMPORT
	ATTRIBUTE_TEST
	COMP_ELEM_CONSTRUCTOR
	COMP_ATTR_CONSTRUCTOR
	COMP_TEXT_CONSTRUCTOR
	COMP_COMMENT_CONSTRUCTOR
	COMP_PI_CONSTRUCTOR
	COMP_NS_CONSTRUCTOR
	COMP_DOC_CONSTRUCTOR
	PRAGMA
	GTEQ
	SEQUENCE
	TUMBLING_WINDOW
	CURRENT_ITEM
	PREVIOUS_ITEM
	NEXT_ITEM
	WINDOW_VARS
	;

// === XPointer ===

xpointer throws XPathException
:
	"xpointer"^ LPAREN! ex:expr RPAREN!
	{ #xpointer= #(#[XPOINTER, "xpointer"], #ex); }
	|
	nc:NCNAME
	{ #xpointer= #(#[XPOINTER_ID, "id"], #nc); }
	;

// === Modules ===

/** top-rule */
xpath throws XPathException
:
	( module )? EOF
	;
	exception catch [RecognitionException e]
	{
        // TODO: WM: not sure if we need handleException anymore.
        // we could just throw the exception.
        handleException(
	        new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage())
        );
    }

module throws XPathException:
	( ( "xquery" "version" ) => v:versionDecl SEMICOLON! )?
	(
		( "module" "namespace" ) => libraryModule
		|
		mainModule
	)
	;

mainModule throws XPathException:
	prolog ( queryBody )? ;

libraryModule throws XPathException:
    moduleDecl prolog;

moduleDecl throws XPathException
{ String prefix = null; }
:
	"module"! "namespace"! prefix=ncnameOrKeyword EQ! uri:STRING_LITERAL SEMICOLON!
	{
		#moduleDecl =
			#(#[MODULE_DECL, prefix, org.exist.xquery.parser.XQueryFunctionAST.class.getName()], uri);
		#moduleDecl.setDoc(getXQDoc());
	}
	;

// === Prolog ===

prolog throws XPathException
{ boolean inSetters = true; }
:
    (
		(
			importDecl
			|
			( "declare" ( "default" | "boundary-space" | "ordering" | "construction" | "base-uri" | "copy-namespaces" | "namespace" ) ) =>
			s:setter
			{
				if(!inSetters)
					throw new XPathException(#s, "Default declarations have to come first");
			}
            |
			( "declare" "option" )
			=> optionDecl { inSetters = false; }
			|
			( "declare" "function" )
			=> functionDeclUp { inSetters = false; }
			|
			( "declare" "variable" )
			=> varDeclUp { inSetters = false; }
			|
            ( "declare" "context" "item" )
            => contextItemDeclUp { inSetters = false; }
			|
			( "declare" MOD )
			=> annotateDecl { inSetters = false; }
        )
		SEMICOLON!
    )*
	;

importDecl throws XPathException
:
	( "import" "module") => moduleImport
	|
	schemaImport
	;

versionDecl throws XPathException
:
	"xquery" "version" v:STRING_LITERAL ( "encoding"! enc:STRING_LITERAL )?
        { #versionDecl = #(#[VERSION_DECL, v.getText()], enc); }
	;

setter
:
	(
		( "declare" "default" ) =>
		"declare"! "default"!
		(
			"collation"! defc:STRING_LITERAL
			{ #setter = #(#[DEF_COLLATION_DECL, "defaultCollationDecl"], defc); }
			|
			"element"! "namespace"! defu:STRING_LITERAL
			{ #setter= #(#[DEF_NAMESPACE_DECL, "defaultNamespaceDecl"], defu); }
			|
			"function"! "namespace"! deff:STRING_LITERAL
			{ #setter= #(#[DEF_FUNCTION_NS_DECL, "defaultFunctionNSDecl"], deff); }
			|
			"order"^ "empty"! ( "greatest" | "least" )
		)
		|
		( "declare" "boundary-space" ) =>
		"declare"! "boundary-space"^ ( "preserve" | "strip" )
		|
		( "declare" "base-uri" ) =>
		"declare"! "base-uri"^ STRING_LITERAL
		|
		( "declare" "ordering" ) =>
		"declare"! "ordering"^ ( "ordered" | "unordered" )
		|
		( "declare" "construction" ) =>
		"declare"! "construction"^ ( "preserve" | "strip" )
		|
		( "declare" "copy-namespaces" ) =>
		"declare"! "copy-namespaces"^ preserveMode COMMA! inheritMode
		|
		( "declare" "namespace" ) =>
        namespaceDecl
	)
	;

preserveMode
:
	( "preserve" | "no-preserve" )
	;

inheritMode
:
	( "inherit" | "no-inherit" )
	;

namespaceDecl
{ String prefix = null; }
:
	decl:"declare" "namespace" prefix=ncnameOrKeyword EQ! uri:STRING_LITERAL
	{
		#namespaceDecl= #(#[NAMESPACE_DECL, prefix], uri);
		#namespaceDecl.copyLexInfo(#decl);
	}
	;

varDeclUp! throws XPathException
:
	decl:"declare"! v:varDecl[#decl, null] { #varDeclUp = #v; }
;

varName returns [String name]
:
    ( name=eq:eqName )
    { #varName.copyLexInfo(#eq); }
;

varDecl [XQueryAST decl, XQueryAST ann] throws XPathException
{ String varName= null; }
:
	"variable"! DOLLAR! varName=varName! ( typeDeclaration )?
	(
		"external" ( COLON! EQ! e3:expr )?
		|
		COLON! EQ! e2:expr
	)
	{
		#varDecl= #(#[GLOBAL_VAR, varName], ann, #varDecl);
		#varDecl.copyLexInfo(decl);
	}
	;

optionDecl
{ String eq = null; }
:
	decl:"declare"! opt:"option"! eq=eqName! STRING_LITERAL
	{
		#optionDecl = #(#[OPTION, eq], #optionDecl);
		#optionDecl.copyLexInfo(#decl);
	}
	;

moduleImport throws XPathException
:
	i:"import"! "module"! ( moduleNamespace )? STRING_LITERAL ( uriList )?
	{
		#moduleImport = #(#[MODULE_IMPORT, "module"], #moduleImport);
		#moduleImport.copyLexInfo(#i);
	}
	;

moduleNamespace
{ String prefix = null; }
:
	"namespace"! prefix=ncnameOrKeyword EQ!
	{ #moduleNamespace = #[NCNAME, prefix]; }
	;

schemaImport throws XPathException
{ String prefix = null; }
:
	i:"import"! "schema"! ( schemaPrefix )? STRING_LITERAL ( uriList )?
	{
		#schemaImport = #(#[SCHEMA_IMPORT, "schema"], #schemaImport);
		#schemaImport.copyLexInfo(#i);
	}
	;

schemaPrefix
{ String prefix = null; }
:
	"namespace"! prefix=ncnameOrKeyword EQ!
	{ #schemaPrefix = #[NCNAME, prefix]; }
	|
	"default" "element" "namespace"
	;

annotateDecl! throws XPathException
:
	decl:"declare"! ann:annotations!
	(
	    ("function") => f:functionDecl[#ann] { #annotateDecl = #f; }
	    |
	    ("variable") => v:varDecl[#decl, #ann] { #annotateDecl = #v; }
	)
    ;

contextItemDeclUp! throws XPathException
:
	decl:"declare"! c:contextItemDecl[#decl] { #contextItemDeclUp = #c; }
    ;

contextItemDecl [XQueryAST decl] throws XPathException
:
	"context"! "item"! ( typeDeclaration )?
	(
	    COLON! EQ! e1:expr
	    |
	    "external" ( COLON! EQ! e2:expr )?
	)
    {
        #contextItemDecl= #(#[CONTEXT_ITEM_DECL, "context item"], #contextItemDecl);
        #contextItemDecl.copyLexInfo(decl);
    }
    ;


annotations
:
    (annotation)*
    ;

annotation
{
	String name= null;
}
:
	MOD! name=eqName! (LPAREN! literal (COMMA! literal)* RPAREN!)?
        { #annotation= #(#[ANNOT_DECL, name], #annotation); }
    ;

eqName returns [String name]
{ name= null; }
:
    ( name=qName | name=uriQualifiedName )
    ;

uriQualifiedName returns [String name]
{
    name = null;
    String uri;
}
:
    ( uri=bracedUriLiteral name=ncnameOrKeyword )
    // convert to Clark notation
    { name = "{" + uri + "}" + name; }
    ;

bracedUriLiteral returns [String uri]
{
    uri= null;
}
:
    lit:BRACED_URI_LITERAL
    { uri = lit.getText(); }
    ;

functionDeclUp! throws XPathException
:
	"declare"! f:functionDecl[null] { #functionDeclUp = #f; }
    ;

functionDecl [XQueryAST ann] throws XPathException
{ String name= null; }
:
	"function"! name=eqName! lp:LPAREN! ( paramList )?
	RPAREN! ( returnType )?
	( functionBody | "external" )
	{
	  	#functionDecl= #(#[FUNCTION_DECL, name, org.exist.xquery.parser.XQueryFunctionAST.class.getName()], #ann, #functionDecl);
		#functionDecl.copyLexInfo(#lp);
		#functionDecl.setDoc(getXQDoc());
	}
	exception catch [RecognitionException e]
	{
		if (#lp == null) {
			throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, "Syntax error within user defined function " +
				name + ": " + e.getMessage());
		} else {
			#lp.setLine(e.getLine());
			#lp.setColumn(e.getColumn());
			throw new XPathException(#lp, ErrorCodes.XPST0003, "Syntax error within user defined function " +
				name + ": " + e.getMessage());
		}
	}
	;

// add virtual parenthesizedExpr for empty function bodys
// this adds an empty sequence
// fixes #3551
functionBody throws XPathException
:
    ( LCURLY RCURLY ) => l:LCURLY^ RCURLY!
    { #functionBody= #(#l, #(#[PARENTHESIZED, "Parenthesized"], null)); }
    | LCURLY^
    { lexer.inFunctionBody = true; }
    expr
    { lexer.inFunctionBody = false; }
    RCURLY!
    ;

returnType throws XPathException:
	"as"^ sequenceType ;

paramList throws XPathException
:
	param ( COMMA! p1:param )*
	;

param throws XPathException
{ String varName= null; }
:
	DOLLAR! varName=eqName ( t:typeDeclaration )?
	{ #param= #(#[VARIABLE_BINDING, varName], #t); }
	;

uriList throws XPathException
:
	"at"! uri ( COMMA! uri )*
	;

uri throws XPathException
:
	STRING_LITERAL
	;

typeDeclaration throws XPathException
:
	"as"^ sequenceType
	;

// === Types ===

sequenceType throws XPathException
:
	( "empty-sequence" LPAREN ) => "empty-sequence"^ LPAREN! RPAREN!
	|
	itemType ( occurrenceIndicator )?
	;

occurrenceIndicator
:
    ( QUESTION | STAR | PLUS )
	;

itemType throws XPathException
:
	( "item" LPAREN ) => "item"^ LPAREN! RPAREN!
	|
	( "function" LPAREN ) => functionTest
	|
	( "map" LPAREN ) => mapType
	|
	( "array" LPAREN ) => arrayType
	|
	( LPAREN ) => parenthesizedItemType
	|
	( . LPAREN ) => kindTest
	|
	atomicType
	;

parenthesizedItemType throws XPathException
:
	LPAREN! itemType RPAREN!
	;

singleType throws XPathException
:
	atomicType ( QUESTION )?
	;

atomicType throws XPathException
{ String name= null; }
:
	name=q:qName
	{
	  #atomicType= #[ATOMIC_TYPE, name];
	  #atomicType.copyLexInfo(#q);
	}
	;

functionTest throws XPathException
:
	( "function" LPAREN STAR RPAREN) => anyFunctionTest
	|
	typedFunctionTest
	;

anyFunctionTest throws XPathException
:
	"function"! LPAREN! s:STAR RPAREN!
	{ #anyFunctionTest = #(#[FUNCTION_TEST, "anyFunction"], #s); }
	;

typedFunctionTest throws XPathException
:
	"function"! LPAREN! (sequenceType (COMMA! sequenceType)*)? RPAREN! "as" sequenceType
	{ #typedFunctionTest = #(#[FUNCTION_TEST, "anyFunction"], #typedFunctionTest); }
	;

mapType throws XPathException
:
	( "map" LPAREN STAR ) => anyMapTypeTest
	|
	mapTypeTest
	;

anyMapTypeTest throws XPathException
:
	m:"map"! LPAREN! s:STAR RPAREN!
	{
		#anyMapTypeTest = #(#[MAP_TEST, "map"], #s);
		#anyMapTypeTest.copyLexInfo(#m);
	}
	;

mapTypeTest throws XPathException
:
	m:"map"! LPAREN! (sequenceType (COMMA! sequenceType)*)? RPAREN!
	{
		#mapTypeTest = #(#[MAP_TEST, "map"], #mapTypeTest);
	}
	;

arrayType throws XPathException
:
	( "array" LPAREN STAR ) => anyArrayTypeTest
	|
	arrayTypeTest
	;

anyArrayTypeTest throws XPathException
:
	m:"array"! LPAREN! s:STAR RPAREN!
	{
		#anyArrayTypeTest = #(#[ARRAY_TEST, "array"], #s);
		#anyArrayTypeTest.copyLexInfo(#m);
	}
	;

arrayTypeTest throws XPathException
:
	m:"array"! LPAREN! sequenceType RPAREN!
	{
		#arrayTypeTest = #(#[ARRAY_TEST, "array"], #arrayTypeTest);
	}
	;

// === Expressions ===

queryBody throws XPathException: expr ;

expr throws XPathException
{ boolean isSequence = false; }
:
    exprSingle ( COMMA! exprSingle { isSequence = true; })*
    {
        if (isSequence)
          #expr = #(#[SEQUENCE, "sequence"], #expr);
    }
    ;

exprSingle throws XPathException
:
	( ( "for" | "let" ) ("tumbling" | "sliding" | DOLLAR ) ) => flworExpr
	| ( "try" LCURLY ) => tryCatchExpr
	| ( ( "some" | "every" ) DOLLAR ) => quantifiedExpr
	| ( "if" LPAREN ) => ifExpr
	| ( "switch" LPAREN ) => switchExpr
	| ( "typeswitch" LPAREN ) => typeswitchExpr
	| ( "update" ( "replace" | "value" | "insert" | "delete" | "rename" )) => updateExpr
	| orExpr
	;

// === Xupdate ===

updateExpr throws XPathException
:
	"update"^
	(
		replaceExpr
		| updateValueExpr
		| insertExpr
		| deleteExpr
		| ( "rename" . "as" ) => renameExpr
	)
	;

replaceExpr throws XPathException
:
	"replace" expr "with"! exprSingle
	;

updateValueExpr throws XPathException
:
	"value" expr "with"! exprSingle
	;

insertExpr throws XPathException
:
	"insert" exprSingle
	( "into" | "preceding" | "following" ) exprSingle
	;

deleteExpr throws XPathException
:
	"delete" exprSingle
	;

renameExpr throws XPathException
:
	"rename" exprSingle "as"! exprSingle
	;

// === try/catch ===
tryCatchExpr throws XPathException
:
	"try"^ LCURLY! tryTargetExpr RCURLY!
    (catchClause)+
	;

tryTargetExpr throws XPathException
:
	expr
	;

catchClause throws XPathException
:
	"catch"^ catchErrorList (catchVars)? LCURLY! expr RCURLY!
	;

catchErrorList throws XPathException
:
	nameTest (UNION! nameTest)*
	;

catchVars throws XPathException
:
	LPAREN! catchErrorCode (COMMA! catchErrorDesc (COMMA! catchErrorVal)?)? RPAREN!
	;

catchErrorCode
{ String varName; }
:
    DOLLAR! varName=qName
	{ #catchErrorCode= #[CATCH_ERROR_CODE, varName]; }
	;

catchErrorDesc
{ String varName; }
:
    DOLLAR! varName=qName
	{ #catchErrorDesc= #[CATCH_ERROR_DESC, varName]; }
	;

catchErrorVal
{ String varName; }
:
    DOLLAR! varName=qName
	{ #catchErrorVal= #[CATCH_ERROR_VAL, varName]; }
	;

// === FLOWER ===

flworExpr throws XPathException
:
    initialClause ( intermediateClause )* "return"^ exprSingle
	;

initialClause throws XPathException
:
    ( ( "for" DOLLAR ) => forClause
    | ( "for" ( "tumbling" | "sliding" ) ) => windowClause
    | letClause )
    ;

intermediateClause throws XPathException
:
    ( initialClause | whereClause | groupByClause | orderByClause | countClause )
    ;

whereClause throws XPathException
:
	"where"^ exprSingle
	;

countClause throws XPathException
{ String varName; }
:
	"count"^ DOLLAR! varName=varName!
	{ #countClause = #(#countClause, #[VARIABLE_BINDING, varName]); }
	;

forClause throws XPathException
:
	"for"^ inVarBinding ( COMMA! inVarBinding )*
	;

letClause throws XPathException
:
	"let"^ letVarBinding ( COMMA! letVarBinding )*
	;

windowClause throws XPathException
:
	"for"! ("tumbling"|"sliding") "window"^ inVarBinding windowStartCondition ( windowEndCondition )?
	;

inVarBinding throws XPathException
{ String varName; }
:
	DOLLAR! varName=v:varName! ( typeDeclaration )? ( allowingEmpty )?
	( positionalVar )?
	"in"! exprSingle
	{
		#inVarBinding= #(#[VARIABLE_BINDING, varName], #inVarBinding);
		#inVarBinding.copyLexInfo(#v);
	}
	;

positionalVar
{ String varName; }
:
	"at" DOLLAR! varName=varName
	{ #positionalVar= #[POSITIONAL_VAR, varName]; }
	;

allowingEmpty
:
	"allowing"! "empty"
	;

windowStartCondition throws XPathException
:
    "start"^ windowVars "when" exprSingle
;

windowEndCondition throws XPathException
:
    ( "only" )? "end"^ windowVars "when" exprSingle
;

windowVars throws XPathException
{ String currentItemName = null, positionalVarName = null, previousItemName = null, nextItemName = null; }
:
    ( DOLLAR! currentItemName=eqName! )?
    ( "at"! DOLLAR! positionalVarName=eqName! )?
    ( "previous"! DOLLAR! previousItemName=eqName! )?
    ( "next"! DOLLAR! nextItemName=eqName! )?
    {
        windowVars_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(WINDOW_VARS);
        if (currentItemName != null)
            windowVars_AST.addChild(astFactory.create(CURRENT_ITEM,currentItemName));
        if (positionalVarName != null)
            windowVars_AST.addChild(astFactory.create(POSITIONAL_VAR,positionalVarName));
        if (previousItemName != null)
            windowVars_AST.addChild(astFactory.create(PREVIOUS_ITEM,previousItemName));
        if (nextItemName != null)
            windowVars_AST.addChild(astFactory.create(NEXT_ITEM,nextItemName));
        currentAST.root = (org.exist.xquery.parser.XQueryAST) windowVars_AST;
    }
;

letVarBinding throws XPathException
{ String varName; }
:
	DOLLAR! varName=v:varName! ( typeDeclaration )?
	COLON! EQ! exprSingle
	{
		#letVarBinding= #(#[VARIABLE_BINDING, varName], #letVarBinding);
		#letVarBinding.copyLexInfo(#v);
	}
	;

orderByClause throws XPathException
:
    ( "order"! "by"! | "stable"! "order"! "by"! ) orderSpecList
	{ #orderByClause= #([ORDER_BY, "order by"], #orderByClause); }
	;

orderSpecList throws XPathException
:
	orderSpec ( COMMA! orderSpec )*
	;

orderSpec throws XPathException: exprSingle orderModifier ;

orderModifier
:
	( "ascending" | "descending" )? ( "empty" ( "greatest" | "least" ) )? ( "collation" STRING_LITERAL )?
	;

groupByClause throws XPathException
:
	"group"! "by"! groupingSpecList
    { #groupByClause= #([GROUP_BY, "group by"], #groupByClause); }
    ;

groupingSpecList throws XPathException
:
    groupingSpec ( COMMA! groupingSpec )*
    ;

groupingSpec throws XPathException
{ String groupKeyVarName; }
:
	DOLLAR! groupKeyVarName=varName! ( typeDeclaration )? ( COLON! EQ! exprSingle )? ( "collation" STRING_LITERAL )?
    { #groupingSpec = #(#[VARIABLE_BINDING, groupKeyVarName], #groupingSpec); }
    ;

/*groupKeyVarBinding throws XPathException
{ String groupKeyVarName; }
:
    DOLLAR! groupKeyVarName=qName!
    { #groupKeyVarBinding= #(#[VARIABLE_BINDING, groupKeyVarName], #groupKeyVarBinding); }
    ;
*/

quantifiedExpr throws XPathException
:
	( "some"^ | "every"^ ) quantifiedInVarBinding ( COMMA! quantifiedInVarBinding )*
	"satisfies"! exprSingle
	;

quantifiedInVarBinding throws XPathException
{ String varName; }
:
	DOLLAR! varName=varName! ( typeDeclaration )? "in"! exprSingle
	{ #quantifiedInVarBinding = #(#[VARIABLE_BINDING, varName], #quantifiedInVarBinding); }
	;

// === Branching ===

switchExpr throws XPathException
:
	"switch"^ LPAREN! expr RPAREN!
	( switchCaseClause )+
	"default" "return"! exprSingle
	;

switchCaseClause throws XPathException
:
    ( "case" exprSingle )+
	caseReturn
	;

typeswitchExpr throws XPathException
{ String varName; }
:
	"typeswitch"^ LPAREN! expr RPAREN!
	( caseClause )+
	"default" ( defaultVar )? "return"! exprSingle
	;

caseClause throws XPathException
{ String varName; }
:
	"case"^ ( caseVar )?
	sequenceTypeUnion caseReturn
	;

sequenceTypeUnion throws XPathException
:
    sequenceType ( UNION! sequenceType )*
    ;

caseReturn throws XPathException
:
    "return"^ exprSingle
    ;

caseVar throws XPathException
{ String varName; }
:
	DOLLAR! varName=varName! "as"
	{ #caseVar = #[VARIABLE_BINDING, varName]; }
	;

defaultVar throws XPathException
{ String varName; }
:
	DOLLAR! varName=varName!
	{ #defaultVar = #[VARIABLE_BINDING, varName]; }
	;

ifExpr throws XPathException
:
    "if"^ LPAREN! expr RPAREN! t:"then"! thenExpr:exprSingle e:"else"! elseExpr:exprSingle
    {
        #thenExpr.copyLexInfo(#t);
        #elseExpr.copyLexInfo(#e);
    }
    ;

// === Logical ===

orExpr throws XPathException
:
	andExpr ( "or"^ andExpr )*
	;

andExpr throws XPathException
:
	comparisonExpr ( "and"^ comparisonExpr )*
	;

instanceofExpr throws XPathException
:
	treatExpr ( "instance"^ "of"! sequenceType )?
	;

treatExpr throws XPathException
:
	castableExpr ( "treat"^ "as"! sequenceType )?
	;

castableExpr throws XPathException
:
	castExpr ( "castable"^ "as"! singleType )?
	;

castExpr throws XPathException
:
	arrowExpr ( "cast"^ "as"! singleType )?
	;

comparisonExpr throws XPathException
:
	r1:stringConcatExpr (
		( BEFORE ) => BEFORE^ stringConcatExpr
		|
		( AFTER ) => AFTER^ stringConcatExpr
		| ( ( "eq"^ | "ne"^ | "lt"^ | "le"^ | "gt"^ | "ge"^ ) stringConcatExpr )
		| ( GT EQ ) => GT^ EQ^ r2:rangeExpr
			{ #comparisonExpr = #(#[GTEQ, ">="], #r1, #r2); }
		| ( ( EQ^ | NEQ^ | GT^ | LT^ | LTEQ^ ) stringConcatExpr )
		| ( ( "is"^ | "isnot"^ ) stringConcatExpr )
	)?
	;

stringConcatExpr throws XPathException
{ boolean isConcat = false; }
:
	r1:rangeExpr (
		CONCAT! rangeExpr { isConcat = true; }
	)*
	{
		if (isConcat)
			#stringConcatExpr = #(#[CONCAT, "||"], #stringConcatExpr);
	}
	;

rangeExpr throws XPathException
:
	additiveExpr ( "to"^ additiveExpr )?
	;

// === Operators ===

additiveExpr throws XPathException
:
	multiplicativeExpr ( ( PLUS^ | MINUS^ ) multiplicativeExpr )*
	;

multiplicativeExpr throws XPathException
:
	unionExpr ( ( STAR^ | "div"^ | "idiv"^ | "mod"^ ) unionExpr )*
	;

unaryExpr throws XPathException
:
	MINUS! ( unaryExpr ) { #unaryExpr = #(#[UNARY_MINUS, "-"], #unaryExpr); }
	|
	PLUS! ( unaryExpr ) { #unaryExpr = #(#[UNARY_PLUS, "+"], #unaryExpr); }
	|
	valueExpr
	;

valueExpr throws XPathException
{ Boolean inFunctionBodyState = lexer.inFunctionBody; }
:
	pathExpr (
	    BANG^
	    {
	        // simple map operator might add new document context
	        lexer.inFunctionBody = false;
        }
	    pathExpr
	    {
	        // reset state
	        lexer.inFunctionBody = inFunctionBodyState;
        }
    )*
	|
	extensionExpr
	;

extensionExpr throws XPathException
:
	( pragma )+ LCURLY! expr RCURLY!
	;

pragma throws XPathException
{ String name = null; }
:
	PRAGMA_START! name=eqName! PRAGMA_END
	{
        lexer.wsExplicit = false;
		#pragma = #(#[PRAGMA, name], #pragma);
	}
    exception catch [RecognitionException e]
    {
        lexer.wsExplicit = false;
        throw new XPathException(pragma_AST, ErrorCodes.XPST0003, "Parse error: " + e.getMessage() + " at line: " + e.getLine() + " column: " + e.getColumn());
    }
	;

unionExpr throws XPathException
:
	intersectExceptExpr
	(
		( "union"! | UNION! ) unionExpr
		{
			#unionExpr = #(#[UNION, "union"], #unionExpr);
		}
	)?
	;

intersectExceptExpr throws XPathException
:
	instanceofExpr
	(
		( "intersect"^ | "except"^ ) instanceofExpr
	)*
	;

// === XPath ===

pathExpr throws XPathException
:
	relativePathExpr
	|
	( SLASH relativePathExpr )
	=> s1:SLASH relPath:relativePathExpr
	{
	  if (lexer.inFunctionBody) {
        throw new XPathException(#s1.getLine(), #s1.getColumn(), ErrorCodes.XPDY0002,
               "Leading '/' selects nothing, ContextItem is absent in function body");
	  }
	  #pathExpr= #(#[ABSOLUTE_SLASH, "AbsoluteSlash"], #relPath);
	}
	// lone slash
	|
	s2:SLASH
	{
	  if (lexer.inFunctionBody) {
        throw new XPathException(#s2.getLine(), #s2.getColumn(), ErrorCodes.XPDY0002,
               "Leading '/' selects nothing, ContextItem is absent in function body");
	  }
	  #pathExpr= #[ABSOLUTE_SLASH, "AbsoluteSlash"];
	}
	|
	ds:DSLASH relPath2:relativePathExpr
	{
	  if (lexer.inFunctionBody) {
        throw new XPathException(#ds.getLine(), #ds.getColumn(), ErrorCodes.XPDY0002,
               "Leading '//' selects nothing, ContextItem is absent in function body");
	  }
	  #pathExpr= #(#[ABSOLUTE_DSLASH, "AbsoluteSlashSlash"], #relPath2);
	}
	;

relativePathExpr throws XPathException
:
	stepExpr ( ( SLASH^ | DSLASH^ ) stepExpr )*
	;

stepExpr throws XPathException
:
	( ( "text" | "node" | "element" | "attribute" | "comment" | "namespace-node" | "processing-instruction" | "document-node" ) LPAREN )
	=> axisStep
	|
	( ( "element" | "attribute" | "text" | "document" | "comment" |
	  "namespace-node" | "processing-instruction" | "namespace" | "ordered" |
	  "unordered" | "map" | "array" ) LCURLY ) =>
	postfixExpr
	|
	( ( "element" | "attribute" | "processing-instruction" | "namespace" ) eqName LCURLY ) => postfixExpr
	|
	( MOD | DOLLAR | ( eqName ( LPAREN | HASH ) ) | SELF | LPAREN | literal | XML_COMMENT | LT |
	  XML_PI | QUESTION | LPPAREN | STRING_CONSTRUCTOR_START )
	=> postfixExpr
	|
	axisStep
	;

axisStep throws XPathException
:
	( forwardOrReverseStep ) predicates
	;

predicates throws XPathException
:
	( predicate )*
	;

predicate throws XPathException
:
	LPPAREN! predExpr:expr RPPAREN!
	{ #predicate= #(#[PREDICATE, "Pred"], #predExpr); }
	;

forwardOrReverseStep throws XPathException
:
	( forwardAxisSpecifier COLON )
	=> forwardAxis nodeTest
	|
	( reverseAxisSpecifier COLON )
	=> reverseAxis nodeTest
	|
	abbrevStep
	;

abbrevStep throws XPathException
:
	( AT )? nodeTest | PARENT
	;

forwardAxis : forwardAxisSpecifier COLON! COLON! ;

forwardAxisSpecifier
:
	"child" | "self" | "attribute" | "descendant" | "descendant-or-self"
    | "following-sibling" | "following"
	;

reverseAxis : reverseAxisSpecifier COLON! COLON! ;

reverseAxisSpecifier
:
	"parent" | "ancestor" | "ancestor-or-self" | "preceding-sibling" | "preceding"
	;

nodeTest throws XPathException
:
	( . LPAREN ) => kindTest | nameTest
	;

nameTest throws XPathException
{ String name= null; }
:
	( ( ncnameOrKeyword COLON STAR ) | STAR )
	=> wildcard
	|
	name=n:eqName
	{
		#nameTest= #[EQNAME, name];
		#nameTest.copyLexInfo(#n);
	}
	;

wildcard
{ String name= null; }
:
	// *:localname
	( STAR COLON )
	=> STAR! COLON! name=ncnameOrKeyword
	{ #wildcard= #(#[PREFIX_WILDCARD, "*"], #[NCNAME, name]); }
	// prefix:*
	|
	name=ncnameOrKeyword COLON! STAR!
	{ #wildcard= #(#[NCNAME, name], #[WILDCARD, "*"]); }
	// *
	|
	STAR
	{
		// make this distinct from multiplication
		#wildcard= #[WILDCARD, "*"];
	}
	;

postfixExpr throws XPathException
:
	primaryExpr (
		(LPPAREN) => predicate
		|
		(LPAREN) => dynamicFunCall
		|
		(QUESTION) => lookup
	)*
	;

arrowExpr throws XPathException
:
    unaryExpr ( ARROW_OP^ arrowFunctionSpecifier argumentList )*
    ;

arrowFunctionSpecifier throws XPathException
{ String name= null; }
:
    name=n:eqName
    {
        #arrowFunctionSpecifier= #[EQNAME, name];
        #arrowFunctionSpecifier.copyLexInfo(#n);
    }
    |
    parenthesizedExpr
    |
    varRef
    ;

lookup throws XPathException
{ String name= null; }
:
    q:QUESTION!
    (
        name=ncnameOrKeyword
        {
        	#lookup = #(#[LOOKUP, name]);
        	#lookup.copyLexInfo(#q);
		}
        |
        pos:INTEGER_LITERAL
        {
        	#lookup = #(#[LOOKUP, "?"], #pos);
        	#lookup.copyLexInfo(#q);
		}
        |
        paren:parenthesizedExpr
        {
        	#lookup = #(#[LOOKUP, "?"], #paren);
        	#lookup.copyLexInfo(#q);
		}
        |
        STAR
        {
        	#lookup = #(#[LOOKUP, "?*"]);
        	#lookup.copyLexInfo(#q);
        }
    )
    ;

unaryLookup throws XPathException
:
    l:lookup
    { #unaryLookup= #(#[PARENTHESIZED, "Parenthesized"], #l); }
    ;

dynamicFunCall throws XPathException
:
	args:argumentList
	{
		#dynamicFunCall = #(#[DYNAMIC_FCALL, "DynamicFunction"], #args);
	}
	;


primaryExpr throws XPathException
{ String varName= null; }
:
	(
	    (
	        "element" | "attribute" | "text" | "document" |
	        "processing-instruction" | "comment" | "namespace"
	    )
	    LCURLY
	)
	=> computedConstructor
	|
	(
	    (
	        "element" | "attribute" | "processing-instruction" | "namespace"
        )
        qName LCURLY
    )
	=> computedConstructor
	|
	( "ordered" LCURLY ) => orderedExpr
	|
	( "unordered" LCURLY ) => unorderedExpr
	|
	( LPPAREN | ( "array" LCURLY ) ) => arrayConstructor
	|
	( "map" LCURLY ) => mapConstructor
	|
	directConstructor
	|
	( MOD | "function" LPAREN | eqName HASH ) => functionItemExpr
	|
	( eqName LPAREN ) => functionCall
	|
	( QUESTION ) => unaryLookup
	|
	( STRING_CONSTRUCTOR_START ) => stringConstructor
	|
	contextItemExpr
	|
	parenthesizedExpr
	|
	varRef
	|
	literal
	;

stringConstructor throws XPathException
:
	STRING_CONSTRUCTOR_START^
	{ lexer.inStringConstructor = true; }
	stringConstructorContent
	{ lexer.inStringConstructor = false; }
	STRING_CONSTRUCTOR_END!
	;

stringConstructorContent throws XPathException
:
	( STRING_CONSTRUCTOR_CONTENT | stringConstructorInterpolation )*
	;

stringConstructorInterpolation throws XPathException
:
	STRING_CONSTRUCTOR_INTERPOLATION_START^
	{ lexer.inStringConstructor = false; }
	( expr )?
	STRING_CONSTRUCTOR_INTERPOLATION_END!
	{ lexer.inStringConstructor = true; }
	;

mapConstructor throws XPathException
:
    a:"map"! LCURLY! ( mapAssignment ( COMMA! mapAssignment )* )? RCURLY!
    {
        #mapConstructor = #(#[MAP, "map"], #mapConstructor);
        #mapConstructor.copyLexInfo(#a);
    }
    ;

mapAssignment throws XPathException
:
    (exprSingle COLON! EQ!) => exprSingle COLON^ eq:EQ^ exprSingle
    {
        throw new XPathException(#eq.getLine(), #eq.getColumn(), ErrorCodes.XPST0003,
               "The ':=' notation is no longer accepted in map expressions: use ':' instead.");
    }
    |
	exprSingle COLON^ exprSingle
	;

arrayConstructor throws XPathException
:
    lp:LPPAREN! (exprSingle ( COMMA! exprSingle )* )? RPPAREN!
    {
        #arrayConstructor = #(#[ARRAY, "["], #arrayConstructor);
        #arrayConstructor.copyLexInfo(#lp);
    }
    |
    a:"array"! LCURLY! (expr )? RCURLY!
    {
        #arrayConstructor = #(#[ARRAY, "array"], #arrayConstructor);
        #arrayConstructor.copyLexInfo(#a);
    }
    ;

orderedExpr throws XPathException
:
	"ordered"! LCURLY! expr RCURLY!
	;

unorderedExpr throws XPathException
:
	"unordered"! LCURLY! expr RCURLY!
	;

varRef throws XPathException
{ String varName = null; }
:
	DOLLAR! varName=v:varName
	{
		#varRef= #[VARIABLE_REF, varName];
		#varRef.copyLexInfo(#v);
	}
	;

literal
:
	STRING_LITERAL^ | numericLiteral
	;

numericLiteral
:
	DOUBLE_LITERAL^ | DECIMAL_LITERAL^ | INTEGER_LITERAL^
	;

parenthesizedExpr throws XPathException
:
	LPAREN! ( e:expr )?
	RPAREN!
	{ #parenthesizedExpr= #(#[PARENTHESIZED, "Parenthesized"], #e); }
	;

functionItemExpr throws XPathException
:
	( MOD | "function" ) => inlineFunctionExpr
	|
	namedFunctionRef
	;

namedFunctionRef throws XPathException
{ String name = null; }
:
	name=eqName! h:HASH! INTEGER_LITERAL
	{
		#namedFunctionRef = #(#[HASH, name], #namedFunctionRef);
	}
	;

inlineFunctionExpr throws XPathException
:
	ann:annotations! "function"! lp:LPAREN! ( paramList )?
	RPAREN! ( returnType )?
	functionBody
	{
	  	#inlineFunctionExpr = #(#[INLINE_FUNCTION_DECL, null], null, #inlineFunctionExpr);
		#inlineFunctionExpr.copyLexInfo(#lp);
	}
	exception catch [RecognitionException e]
	{
		if (#lp == null) {
			throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, "Syntax error within inline function: " + e.getMessage());
		} else {
			#lp.setLine(e.getLine());
			#lp.setColumn(e.getColumn());
			throw new XPathException(#lp, ErrorCodes.XPST0003, "Syntax error within user defined function: " + e.getMessage());
		}
	}
	;

functionCall throws XPathException
{ String fnName= null; }
:
	fnName=eq:eqName
	{
        #functionCall = #[FUNCTION, fnName];
    }
	(
		params:argumentList
		{ #functionCall= #(#[FUNCTION, fnName], #params); }
	)?
    { #functionCall.copyLexInfo(#eq); }
	;

argumentList throws XPathException
:
	LPAREN! (argument (COMMA! argument)*)? RPAREN!
	;

argument throws XPathException
:
	(QUESTION! ( NCNAME | INTEGER_LITERAL | LPAREN | STAR )) => lookup
	| argumentPlaceholder
	| exprSingle
	;

argumentPlaceholder throws XPathException : QUESTION ;

contextItemExpr : SELF ;

kindTest
:
	textTest | anyKindTest | elementTest | attributeTest |
	commentTest | namespaceNodeTest | piTest | documentTest
	;

textTest
:
    "text"^ LPAREN! RPAREN!
    ;

anyKindTest
:
    "node"^ LPAREN! RPAREN!
    ;

elementTest
:
    "element"^ LPAREN!
    (
        elementNameOrWildcard
        ( COMMA! typeName ( QUESTION )? )?
    )?
    RPAREN!
    ;

typeName
{ String eq = null; }
:
	eq=eqName
	{ #typeName = #[EQNAME, eq]; }
	;

elementNameOrWildcard
{ String eq = null; }
:
	STAR { #elementNameOrWildcard = #[WILDCARD, "*"]; }
	|
	eq=eqName { #elementNameOrWildcard = #[EQNAME, eq]; }
	;

attributeTest
:
    "attribute"! LPAREN!
    (
        attributeNameOrWildcard
        ( COMMA! typeName ( QUESTION )? )?
    )?
    RPAREN!
	{ #attributeTest= #(#[ATTRIBUTE_TEST, "attribute()"], #attributeTest); }
	;

attributeNameOrWildcard
{ String eq = null; }
:
	STAR { #attributeNameOrWildcard = #[WILDCARD, "*"]; }
	|
	eq=eqName { #attributeNameOrWildcard = #[EQNAME, eq]; }
	;

commentTest : "comment"^ LPAREN! RPAREN! ;

namespaceNodeTest : "namespace-node"^ LPAREN! RPAREN! ;

piTest
:
    "processing-instruction"^ LPAREN!
    ( NCNAME | STRING_LITERAL )?
    RPAREN!
    ;

documentTest
:
    "document-node"^ LPAREN!
    ( elementTest | schemaElementTest )?
    RPAREN!
    ;

schemaElementTest : "schema-element"^ LPAREN! eqName RPAREN! ;

qName returns [String name]
{
	name= null;
	String name2;
}
:
	n:QNAME { name = n.getText(); }
    |
    name=ncnameOrKeyword
	;

directConstructor throws XPathException
:
	elementConstructor
	|
	xmlComment
	|
	xmlPI
	;

computedConstructor throws XPathException
:
	compElemConstructor
	|
	compAttrConstructor
	|
	compTextConstructor
	|
	compNamespaceConstructor
	|
	compDocumentConstructor
	|
	compXmlPI
	|
	compXmlComment
	;

compElemConstructor throws XPathException
{ String eq; }
:
	( "element" LCURLY ) =>
	"element"! LCURLY! expr RCURLY! compElemConstructorContent
	{ #compElemConstructor = #(#[COMP_ELEM_CONSTRUCTOR], #compElemConstructor); }
	|
	"element"! eq=eqName v:compElemConstructorContent
	{ #compElemConstructor = #(#[COMP_ELEM_CONSTRUCTOR, eq], #[STRING_LITERAL, eq], #v); }
	;

compElemConstructorContent throws XPathException
:
    ( LCURLY RCURLY ) => LCURLY! RCURLY!
    { #compElemConstructorContent= #(#[PARENTHESIZED, "Parenthesized"], null); }
    | LCURLY! e:expr RCURLY!
    { #compElemConstructorContent.copyLexInfo(#e); }
    ;


compAttrConstructor throws XPathException
{ String eq; }
:
	( "attribute" LCURLY ) =>
	"attribute"! LCURLY! e1:expr RCURLY! e2:compConstructorValue
	{ #compAttrConstructor = #(#[COMP_ATTR_CONSTRUCTOR], #compAttrConstructor); }
	|
	"attribute"! eq=eqName e3:compConstructorValue
    { #compAttrConstructor = #(#[COMP_ATTR_CONSTRUCTOR, eq], #[STRING_LITERAL, eq], #e3); }
	;

compConstructorValue throws XPathException
:
    LCURLY^ ( e2:expr )?  RCURLY!
    ;

compTextConstructor throws XPathException
:
	"text" LCURLY! e:expr RCURLY!
	{ #compTextConstructor = #(#[COMP_TEXT_CONSTRUCTOR, "text"], #e); }
	;

compDocumentConstructor throws XPathException
:
	"document" LCURLY! e:expr RCURLY!
	{ #compDocumentConstructor = #(#[COMP_DOC_CONSTRUCTOR, "document"], #e); }
	;

compXmlPI throws XPathException
{ String qn; }
:
	( "processing-instruction" LCURLY ) =>
	"processing-instruction"! LCURLY! e1:expr RCURLY! e2:compConstructorValue
	{ #compXmlPI = #(#[COMP_PI_CONSTRUCTOR], #compXmlPI); }
	|
	"processing-instruction"! qn=qName e3:compConstructorValue
	{ #compXmlPI = #(#[COMP_PI_CONSTRUCTOR, qn], #[STRING_LITERAL, qn], #e3); }
	;

compXmlComment throws XPathException
:
	"comment" LCURLY! e:expr RCURLY!
	{ #compXmlComment = #(#[COMP_COMMENT_CONSTRUCTOR, "comment"], #e); }
	;

compNamespaceConstructor throws XPathException
{ String qn; }
:
	( "namespace" LCURLY ) =>
	"namespace"! LCURLY! expr RCURLY! LCURLY! (expr)? RCURLY!
	{ #compNamespaceConstructor = #(#[COMP_NS_CONSTRUCTOR], #compNamespaceConstructor); }
	|
	"namespace"! qn=qName LCURLY! (e3:expr)? RCURLY!
	{ #compNamespaceConstructor = #(#[COMP_NS_CONSTRUCTOR, qn], #[STRING_LITERAL, qn], #e3); }
	;

elementConstructor throws XPathException
{ String name= null; }
:
	( LT qName ~( GT | SLASH ) )
	=> elementWithAttributes | elementWithoutAttributes
	;

elementWithoutAttributes throws XPathException
{ String name = null, cname = null; }
:
	LT name=q:qName
	(
		(
			SLASH! GT!
			{
				lexer.wsExplicit= false;
				if (!elementStack.isEmpty())
					lexer.inElementContent= true;
				#elementWithoutAttributes= #[ELEMENT, name];
			}
		)
		|
		(
			GT!
			{
				elementStack.push(name);
				lexer.inElementContent= true;
			}
			content:mixedElementContent END_TAG_START! cname=qn:qName! GT!
			{
				if (elementStack.isEmpty())
					throw new XPathException(#qn, "found additional closing tag: " + cname);
				String prev= (String) elementStack.pop();
				if (!prev.equals(cname))
					throw new XPathException(#qn, "found closing tag: " + cname + "; expected: " + prev);
				#elementWithoutAttributes= #(#[ELEMENT, cname], #content);
				if (!elementStack.isEmpty()) {
					lexer.inElementContent= true;
					//lexer.wsExplicit= false;
				}
			}
		)
	)
    { #elementWithoutAttributes.copyLexInfo(#q); }
    exception catch [RecognitionException e]
    {
        if (e.getMessage().contains("expecting XML end tag") || e.getMessage().contains("<")) {
            lexer.wsExplicit = false;
            throw new XPathException(#q, ErrorCodes.XPST0003, "No closing end tag found for element constructor: " + name);
        } else if (e.getMessage().contains("unexpected token")) {
            throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage() +
                " (while expecting closing tag for element constructor: " + name + ")");
        } else {
            throw e;
        }
    }
	;

// === XML ===

elementWithAttributes throws XPathException
{ String name= null, cname=null; }
:
	LT! name=q:qName attrs:attributeList
	(
		(
			SLASH! GT!
			{
				if (!elementStack.isEmpty())
					lexer.inElementContent= true;
				#elementWithAttributes= #(#[ELEMENT, name], #attrs);
			}
		)
		|
		(
			GT!
			{
				elementStack.push(name);
				lexer.inElementContent= true;
			}
			content:mixedElementContent END_TAG_START! cname=qn:qName! GT!
			{
				if (elementStack.isEmpty())
					throw new XPathException(#qn, ErrorCodes.XPST0003, "Found closing tag without opening tag: " + cname);
				String prev= (String) elementStack.pop();
				if (!prev.equals(cname))
					throw new XPathException(#qn, ErrorCodes.XPST0003, "Found closing tag: " + cname + "; expected: " + prev);
				#elementWithAttributes= #(#[ELEMENT, cname], #attrs);
				if (!elementStack.isEmpty()) {
					lexer.inElementContent= true;
				}
			}
		)
	)
    { #elementWithAttributes.copyLexInfo(#q); }
    exception catch [RecognitionException e]
    {
        if (
            e.getMessage().contains("expecting XML end tag") ||
            e.getMessage().contains("<")
        ) {
            lexer.wsExplicit = false;
            throw new XPathException(#q, ErrorCodes.XPST0003, "Static error: no closing end tag found for element constructor: " + name);
        } else if (e.getMessage().contains("unexpected token")) {
            throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage() +
                " (while expecting closing tag for element constructor: " + name + ")");
        } else {
            throw e;
        }
    }
	;

attributeList throws XPathException
:
	( attributeDef )+
	;

attributeDef throws XPathException
{
	String name= null;
	lexer.parseStringLiterals= false;
}
:
	name=q:qName! EQ!
	attributeValue
	{
		#attributeDef= #(#[ATTRIBUTE, name], #attributeDef);
		#attributeDef.copyLexInfo(#q);
	}
	;

attributeValue throws XPathException
:
	QUOT!
	{
		lexer.inAttributeContent= true;
		lexer.attrDelimChar = '"';
	}
	( quotAttrValueContent )*
	QUOT!
	{
		lexer.parseStringLiterals= true;
		lexer.inAttributeContent= false;
	}
	|
	APOS!
	{
		lexer.inAttributeContent= true;
		lexer.attrDelimChar = '\'';
	}
	( aposAttrValueContent )*
	APOS!
	{
		lexer.parseStringLiterals= true;
		lexer.inAttributeContent= false;
	}
	;

quotAttrValueContent throws XPathException:
	c:QUOT_ATTRIBUTE_CONTENT
	{ #quotAttrValueContent = #[ATTRIBUTE_CONTENT, c.getText()]; }
	|
	e:ESCAPE_QUOT
	{ #quotAttrValueContent = #[ATTRIBUTE_CONTENT, "\""]; }
	|
	attrCommonContent
	;

aposAttrValueContent throws XPathException
:
	c:APOS_ATTRIBUTE_CONTENT
	{ #aposAttrValueContent = #[ATTRIBUTE_CONTENT, c.getText()]; }
	|
	e:ESCAPE_APOS
	{ #aposAttrValueContent = #[ATTRIBUTE_CONTENT, "'"]; }
	|
	attrCommonContent
	;

attrCommonContent throws XPathException
:
	( LCURLY LCURLY )=> LCURLY LCURLY
	{
		lexer.inAttributeContent= true;
		lexer.parseStringLiterals = false;
		#attrCommonContent= #[ATTRIBUTE_CONTENT, "{"];
	}
	|
	RCURLY RCURLY
	{ #attrCommonContent= #[ATTRIBUTE_CONTENT, "}"]; }
	|
	attributeEnclosedExpr
	;

mixedElementContent throws XPathException
:
	( elementContent )*
	;

elementContent throws XPathException
:
	elementConstructor
	|
	( LCURLY LCURLY )=> LCURLY LCURLY
	{
		lexer.inElementContent= true;
		#elementContent= #[TEXT, "{"];
	}
	|
	RCURLY RCURLY
	{ #elementContent= #[TEXT, "}"]; }
	|
	content:ELEMENT_CONTENT
	{ #elementContent= #[TEXT, content.getText()]; }
	|
	xmlComment
	|
	cdataSection
	|
	enclosedExpr
	|
	xmlPI
	;

xmlComment : XML_COMMENT XML_COMMENT_END! ;

xmlPI : XML_PI XML_PI_END! ;

cdataSection : XML_CDATA;

enclosedExpr throws XPathException
:
    ( LCURLY RCURLY ) => LCURLY! RCURLY!
    { lexer.inElementContent= true; }
    |
	LCURLY^
	{
		globalStack.push(elementStack);
		elementStack = new ArrayDeque<>();
		lexer.inElementContent= false;
	}
	expr RCURLY!
	{
		elementStack = (Deque) globalStack.pop();
		lexer.inElementContent= true;
	}
	;

attributeEnclosedExpr throws XPathException
:
    ( LCURLY RCURLY ) => LCURLY! RCURLY!
    { lexer.inAttributeContent= true; }
    |
	LCURLY^
	{
		lexer.inAttributeContent= false;
		lexer.parseStringLiterals = true;
	}
	expr RCURLY!
	{
		lexer.inAttributeContent= true;
		lexer.parseStringLiterals = false;
	}
	;

/* All of the literals used in this grammar can also be
 * part of a valid QName. We thus have to test for each
 * of them below.
 */
ncnameOrKeyword returns [String name]
{ name= null; }
:
	n1:NCNAME { name= n1.getText(); }
	|
	name=reservedKeywords
	;

reservedKeywords returns [String name]
{ name= null; }
:
	"element" { name = "element"; }
	|
	"to" { name = "to"; }
	|
	"div" { name= "div"; }
	|
	"mod" { name= "mod"; }
	|
	"text" { name= "text"; }
	|
	"node" { name= "node"; }
	|
	"or" { name= "or"; }
	|
	"and" { name= "and"; }
	|
	"child" { name= "child"; }
	|
	"parent" { name= "parent"; }
	|
	"self" { name= "self"; }
	|
	"attribute" { name= "attribute"; }
	|
	"comment" { name= "comment"; }
	|
	"document" { name= "document"; }
	|
	"document-node" { name= "document-node"; }
	|
	"collection" { name= "collection"; }
	|
	"ancestor" { name= "ancestor"; }
	|
	"descendant" { name= "descendant"; }
	|
	"descendant-or-self" { name= "descendant-or-self"; }
	|
	"ancestor-or-self" { name= "ancestor-or-self"; }
	|
	"preceding-sibling" { name= "preceding-sibling"; }
	|
	"following-sibling" { name= "following-sibling"; }
	|
	"following" { name = "following"; }
	|
	"preceding" { name = "preceding"; }
	|
	"item" { name= "item"; }
	|
	"empty" { name= "empty"; }
	|
	"version" { name= "version"; }
	|
	"xquery" { name= "xquery"; }
	|
	"variable" { name= "variable"; }
	|
	"namespace-node" { name= "namespace-node"; }
	|
    "namespace" { name= "namespace"; }
    |
	"if" { name= "if"; }
	|
	"then" { name= "then"; }
	|
	"else" { name= "else"; }
	|
	"for" { name= "for"; }
	|
	"where" { name= "where"; }
	|
	"in" { name = "in"; }
	|
	"let" { name= "let"; }
	|
	"try" { name="try"; }
	|
	"catch" { name="catch"; }
	|
	"default" { name= "default"; }
	|
	"function" { name= "function"; }
	|
	"external" { name = "external"; }
	|
	"as" { name = "as"; }
	|
	"union" { name = "union"; }
	|
	"intersect" { name = "intersect"; }
	|
	"except" { name = "except"; }
	|
	"order" { name = "order"; }
	|
	"stable" { name = "stable"; }
	|
	"by" { name = "by"; }
	|
    "group" { name = "group"; }
    |
	"some" { name = "some"; }
	|
	"every" { name = "every"; }
	|
	"is" { name = "is"; }
	|
	"isnot" { name = "isnot"; }
	|
	"module" { name = "module"; }
	|
	"import" { name = "import"; }
	|
	"at" { name = "at"; }
	|
	"cast" { name = "cast"; }
	|
	"return" { name = "return"; }
	|
	"instance" { name = "instance"; }
	|
	"of" { name = "of"; }
	|
	"declare" { name = "declare"; }
	|
	"collation" { name = "collation"; }
	|
	"boundary-space" { name = "boundary-space"; }
	|
	"preserve" { name = "preserve"; }
	|
	"strip" { name = "strip"; }
	|
	"ordering" { name = "ordering"; }
	|
	"construction" { name = "construction"; }
	|
	"context" { name = "context"; }
	|
	"ordered" { name = "ordered"; }
	|
	"unordered" { name = "unordered"; }
	|
	"typeswitch" { name = "typeswitch"; }
	|
	"switch" { name = "switch"; }
	|
	"encoding" { name = "encoding"; }
	|
	"base-uri" { name = "base-uri"; }
	|
	"update" { name = "update"; }
	|
	"replace" { name = "replace"; }
	|
	"delete" { name = "delete"; }
	|
	"value" { name = "value"; }
	|
	"insert" { name = "insert"; }
	|
	"with" { name = "with"; }
	|
	"into" { name = "into"; }
	|
	"rename" { name = "rename"; }
	|
	"option" { name = "option"; }
	|
	"case" { name = "case"; }
	|
	"validate" { name = "validate"; }
	|
	"schema" { name = "schema"; }
	|
	"treat" { name = "treat"; }
	|
	"no-preserve" { name = "no-preserve"; }
	|
	"inherit" { name = "inherit"; }
	|
	"no-inherit" { name = "no-inherit"; }
	|
	"eq" { name="eq"; }
	|
	"ne" { name = "ne"; }
	|
	"lt" { name = "lt"; }
	|
	"le" { name = "le"; }
	|
	"gt" { name = "gt"; }
	|
	"ge" { name = "ge"; }
	|
	"xpointer" { name = "xpointer"; }
	|
	"map" { name = "map"; }
	|
	"array" { name = "array"; }
	|
	"count" { name = "count"; }
	|
	"copy-namespaces" { name = "copy-namespaces"; }
	|
	"empty-sequence" { name = "empty-sequence"; }
	|
	"schema-element" { name = "schema-element"; }
	|
	"tumbling" { name = "tumbling"; }
	|
	"sliding" { name = "sliding"; }	
	|
	"window" { name = "window"; }
	|
	"start" { name = "start"; }
	|
	"end" { name = "end"; }
	|
	"only" { name = "only"; }
	|
	"previous" { name = "previous"; }
	|
	"next" { name = "next"; }
	;


/**
 * The XQuery/XPath lexical analyzer.
 */
class XQueryLexer extends Lexer;

options {
	k = 4;
	testLiterals = false;
	charVocabulary = '\u0003'..'\uFFFE';
	codeGenBitsetTestThreshold = 20;
	exportVocab=XQuery;
}

{
	protected boolean wsExplicit= false;
	protected boolean parseStringLiterals= true;
	protected boolean inStringConstructor = false;
	protected boolean inElementContent= false;
	protected boolean inAttributeContent= false;
	protected boolean inFunctionBody= false;
	protected char attrDelimChar = '"';
	protected boolean inComment= false;
	protected boolean inPragma = false;
	protected String xqDoc = null;
	protected XQueryContext context = null;

	public XQueryLexer(XQueryContext context, Reader in) {
		this(in);
		this.context = context;
	}

	public String getXQDoc() {
		String doc = xqDoc;
		xqDoc = null;
		return doc;
	}

	private void parseLinefeeds(String str) {
		char ch;
		for (int i = 0;  i < str.length(); i++) {
			ch = str.charAt(i);
			if (ch == '\n')
				newline();
		}
	}
}

protected SLASH options { paraphrase="single slash '/'"; }: '/' ;
protected DSLASH options { paraphrase="double slash '//'"; }: '/' '/' ;
protected BANG : '!' ;
protected MOD : '%' ;
protected COLON : ':' ;
protected COMMA : ',' ;
protected HASH : '#' ;
protected SEMICOLON options { paraphrase="semicolon ';'"; }: ';' ;
protected STAR options { paraphrase="wildcard '*'"; }: '*';
protected QUESTION options { paraphrase="question mark '?'"; }: '?' ;
protected PLUS options { paraphrase="+"; }: '+' ;
protected MINUS options { paraphrase="-"; }: '-' ;
protected LPPAREN options { paraphrase="opening brace '['"; }: '[' ;
protected RPPAREN options { paraphrase="closing brace ']'"; }: ']' ;
protected LPAREN options { paraphrase="opening parenthesis '('"; } : '(' ;
protected RPAREN options { paraphrase="closing parenthesis ')'"; } : ')' ;
protected SELF options { paraphrase="."; }: '.' ;
protected PARENT options { paraphrase=".."; }: ".." ;
protected UNION options { paraphrase="union"; }: '|' ;
protected CONCAT options { paraphrase="||"; }: '|' '|';
protected ARROW_OP options { paraphrase="arrow operator"; }: '=' '>';
protected AT options { paraphrase="@ char"; }: '@' ;
protected DOLLAR options { paraphrase="dollar sign '$'"; }: '$' ;
protected EQ options { paraphrase="="; }: '=' ;
protected NEQ options { paraphrase="!="; }: "!=" ;
protected GT options { paraphrase=">"; }: '>' ;
protected QUOT options { paraphrase="double quote '\"'"; }: '"' ;
protected APOS options { paraphrase="single quote '"; }: "'";
protected LTEQ options { paraphrase="<="; }: "<=" ;

protected BEFORE : "<<" ;
protected AFTER : ">>" ;

protected LT options { paraphrase="<"; }: '<' ;

protected END_TAG_START
options { paraphrase="XML end tag"; }: "</" ;

protected LCURLY options { paraphrase="opening curly brace '{'"; }: '{' ;
protected RCURLY options { paraphrase="closing curly brace '}'"; }: '}' ;

protected XML_COMMENT_END options { paraphrase="end of XML comment"; }: "-->" ;
protected XML_PI_START options { paraphrase="start of processing instruction"; }: "<?" ;
protected XML_PI_END options { paraphrase="end of processing instruction"; }: "?>" ;
protected XML_CDATA_START options { paraphrase="CDATA section start"; }: "<![CDATA[";
protected XML_CDATA_END options { paraphrase="end of CDATA section"; }: "]]>";

protected LETTER
:
	( BASECHAR | IDEOGRAPHIC )
	;

protected DIGITS
:
	( DIGIT )+
	;

protected HEX_DIGITS
:
	( '0'..'9' | 'a'..'f' | 'A'..'F' )+
	;

protected NCNAME
options {
	testLiterals=true;
	paraphrase="ncname";
}
:
    NAME_START_CHAR ( NAME_CHAR)*
	;

protected QNAME
options {
    paraphrase="qname";
}
:
    NAME_START_CHAR ( NAME_CHAR)* COLON NAME_START_CHAR ( NAME_CHAR)*
    ;

protected WS
:
	(
		options { greedy=true; }:
		' '
		|
		'\t'
		|
		'\n' { newline(); }
		|
		'\r'
	)+
	;

protected XQDOC_COMMENT
options {
	testLiterals=false;
	paraphrase="XQuery XQDoc comment";
}
:
	"(:~" ( options { greedy=false; }: ( EXPR_COMMENT | . ) )* ":)"
	;

protected EXPR_COMMENT
options {
	testLiterals=false;
	paraphrase="XQuery comment";
}
:
	"(:" ( options { greedy=false; }: ( EXPR_COMMENT | . ) )* ":)"
	;

protected INTEGER_LITERAL
:
	{ !(inElementContent || inAttributeContent) }? DIGITS
	;

protected DOUBLE_LITERAL
:
	{ !(inElementContent || inAttributeContent) }?
	( ( '.' DIGITS ) | ( DIGITS ( '.' ( DIGIT )* )? ) ) ( 'e' | 'E' ) ( '+' | '-' )? DIGITS
	;

protected DECIMAL_LITERAL
:
	{ !(inElementContent || inAttributeContent) }?
	( '.' DIGITS ) | ( DIGITS ( '.' ( DIGIT )* )? )
	;

protected PREDEFINED_ENTITY_REF
:
	'&' ( "lt" | "gt" | "amp" | "quot" | "apos" ) ';'
	;

protected CHAR_REF
:
	'&' '#' ( DIGITS | ( 'x' HEX_DIGITS ) ) ';'
	;

protected STRING_LITERAL
options {
	testLiterals = false;
	paraphrase="string literal";
}
:
	'"'! ( PREDEFINED_ENTITY_REF | CHAR_REF | ('\n') => '\n' { newline(); } | ( '"'! '"' ) | ~ ( '"' | '&' ) )*
	'"'!
	|
	'\''! ( PREDEFINED_ENTITY_REF | CHAR_REF | ('\n') => '\n' { newline(); } | ( '\''! '\'' ) | ~ ( '\'' | '&' ) )*
	'\''!
	;

protected STRING_CONSTRUCTOR_START options { paraphrase="start of string constructor"; }: "``[";
protected STRING_CONSTRUCTOR_END options { paraphrase="start of string constructor"; }: "]``";
protected STRING_CONSTRUCTOR_INTERPOLATION_START
options { paraphrase="start of interpolated expression"; }: "`{";
protected STRING_CONSTRUCTOR_INTERPOLATION_END
options { paraphrase="end of interpolated expression"; }: "}`";

protected STRING_CONSTRUCTOR_CONTENT
options {
	testLiterals = false;
	paraphrase = "string constructor content";
}
:
	(
        ( '\n' ) => '\n' { newline(); } |
		( '&' ) => ( PREDEFINED_ENTITY_REF | CHAR_REF ) |
		( ( ']' '`' ) ~ ( '`' ) ) => ( ']' '`' ) |
		( ']' ~ ( '`' ) ) => ']' |
		( '`' ~ ( '{') ) => '`' |
		~ ( ']' | '`')
	)+
	;

protected BRACED_URI_LITERAL
options {
    paraphrase="braced uri literal";
}
:
    'Q'! LCURLY! ( PREDEFINED_ENTITY_REF | CHAR_REF |  ~( '&' | '{' | '}' ) )* RCURLY!
    ;

protected QUOT_ATTRIBUTE_CONTENT
options {
	testLiterals=false;
}
:
	( ~( '"' | '{' | '}' | '<' ) )+
	;

/**
 * The following definition differs from the spec by allowing the
 * ampersand character, which is handled by the constructor classes.
 *
 * TODO: Allow escaped quotes in attribute content. Doesn't work.
 */
protected APOS_ATTRIBUTE_CONTENT
options {
	testLiterals=false;
}
:
	( ~( '\'' | '{' | '}' | '<' ) )+
	;

protected ESCAPE_APOS
:
	'\'' '\''
	;

protected ESCAPE_QUOT
:
	'"' '"'
	;

/**
 * The following definition differs from the spec by allowing the
 * ampersand character, which is handled by the constructor classes.
 *
 * TODO: Allow escaped quotes in attribute content. Doesn't work.
 */
protected ELEMENT_CONTENT
:
	( '\t' | '\r' | '\n' { newline(); } | '\u0020'..'\u003b' | '\u003d'..'\u007a' | '\u007c' | '\u007e'..'\uFFFD' )+
	;

protected XML_COMMENT
options {
	testLiterals=false;
	paraphrase="XML comment";
}
:
	"<!--"! ( ~ ( '-' ) | ( '-' ~ ( '-' ) ) => '-' )*
	;

protected XML_PI
options {
	testLiterals=false;
	paraphrase="processing instruction";
}
:
	XML_PI_START! NCNAME (' ' ( ~ ( '?' ) | ( '?' ~ ( '>' ) ) => '?' )* )?
	;

protected XML_CDATA
options {
	testLiterals=false;
	paraphrase="CDATA section";
}:
	XML_CDATA_START!
	( ~ ( ']' ) | ( ']' ~ ( ']' ) ) => ']' | ( ']' ']' ~ ( '>' ) ) => ( ']' ']' ) )*
	XML_CDATA_END!
	;

protected S
:
    ( options { greedy=true; }: ( ' ' | '\n' | '\r' | '\t' ) )+
	;

protected PRAGMA_START
:
	"(#" ( WS )?
	{ inPragma = true; }
	;

protected PRAGMA_END
options {
	paraphrase="pragma expression";
	testLiterals=false;
}
:
    (
        WS!
        ( options { greedy=false; }: . )*
    )?
	"#)"!
	;

/**
 * Main method that decides which token to return next.
 * We need this as many things depend on the current
 * context.
 */
NEXT_TOKEN
options {
	testLiterals = false;
}
:
	{ !inStringConstructor }?
	STRING_CONSTRUCTOR_START {
		$setType(STRING_CONSTRUCTOR_START);
	}
	|
	{ inStringConstructor }?
	STRING_CONSTRUCTOR_END {
		$setType(STRING_CONSTRUCTOR_END);
	}
	|
	{ inStringConstructor }?
	STRING_CONSTRUCTOR_INTERPOLATION_START {
		$setType(STRING_CONSTRUCTOR_INTERPOLATION_START);
	}
	|
	{ !inStringConstructor }?
	STRING_CONSTRUCTOR_INTERPOLATION_END {
		$setType(STRING_CONSTRUCTOR_INTERPOLATION_END);
	}
	|
	{ !inStringConstructor }?
	XML_COMMENT
	{
		String data = $getText;
		parseLinefeeds(data);
		$setType(XML_COMMENT);
	}
	|
	( XML_PI_START )
	=> XML_PI { $setType(XML_PI); }
	|
	{ !inStringConstructor }?
	XML_CDATA { $setType(XML_CDATA);  }
	|
	{ !inStringConstructor }?
	END_TAG_START
	{
		inElementContent= false;
		wsExplicit= false;
		$setType(END_TAG_START);
	}
	|
	{ !inStringConstructor }?
	BEFORE { $setType(BEFORE); }
	|
	{ !inStringConstructor }?
	LT
	{
		inElementContent= false;
		$setType(LT);
	}
	|
	{ !inStringConstructor }?
	LTEQ { $setType(LTEQ); }
	|
	{ !inStringConstructor }?
	LCURLY
	{
		inElementContent= false;
		inAttributeContent= false;
		$setType(LCURLY);
	}
	|
	{ !inStringConstructor }?
	RCURLY { $setType(RCURLY); }
	|
	{ inAttributeContent && attrDelimChar == '\'' }?
	ESCAPE_APOS { $setType(ESCAPE_APOS); }
	|
	{ inAttributeContent && attrDelimChar == '"' }?
	ESCAPE_QUOT { $setType(ESCAPE_QUOT); }
	|
	{ inAttributeContent && attrDelimChar == '"' }?
	QUOT_ATTRIBUTE_CONTENT
	{ $setType(QUOT_ATTRIBUTE_CONTENT); }
	|
	{ inAttributeContent && attrDelimChar == '\'' }?
	APOS_ATTRIBUTE_CONTENT
	{ $setType(APOS_ATTRIBUTE_CONTENT); }
	|
	{ !(parseStringLiterals || inElementContent || inStringConstructor) }?
	QUOT { $setType(QUOT); }
	|
	{ !(parseStringLiterals || inElementContent || inStringConstructor) }?
	APOS { $setType(APOS); }
	|
	{ inElementContent }?
	ELEMENT_CONTENT
	{ $setType(ELEMENT_CONTENT); }
	|
	{ !(inPragma || inStringConstructor) }?
	WS
	{
		if (wsExplicit) {
			$setType(WS);
			$setText("WS");
		} else
			$setType(Token.SKIP);
	}
	|
	( '(' ':' '~' ) => XQDOC_COMMENT
	{
		xqDoc = $getText;
		for (int i = 0; i < xqDoc.length(); i++) {
			if (xqDoc.charAt(i) == '\n')
				newline();
		}
		$setType(Token.SKIP);
	}
	|
	{ !(inAttributeContent || inElementContent || inStringConstructor) }?
	EXPR_COMMENT
	{
		String comment = $getText;
		for (int i = 0; i < comment.length(); i++) {
			if (comment.charAt(i) == '\n')
				newline();
		}
		$setType(Token.SKIP);
	}
	|
	{ inStringConstructor }?
	STRING_CONSTRUCTOR_CONTENT {
		$setType(STRING_CONSTRUCTOR_CONTENT);
	}
	|
	{ !inAttributeContent && !inElementContent && !inStringConstructor }?
	( NCNAME COLON NCNAME ) =>
	QNAME { $setType(QNAME); }
	|
	( NAME_START_CHAR ) =>
	ncname:NCNAME { $setType(ncname.getType()); }
	|
	{ parseStringLiterals && !inElementContent && !inStringConstructor }?
	STRING_LITERAL { $setType(STRING_LITERAL); }
	|
	BRACED_URI_LITERAL { $setType(BRACED_URI_LITERAL); }
	|
	{ !inAttributeContent && !inElementContent && !inStringConstructor }?
	( '|' '|' ) =>
	CONCAT { $setType(CONCAT); }
	|
	UNION { $setType(UNION); }
	|
	( '.' '.' ) =>
	{ !(inAttributeContent || inElementContent) }?
	PARENT { $setType(PARENT); }
	|
    ( '.' INTEGER_LITERAL ( 'e' | 'E' ) )
	=> DOUBLE_LITERAL { $setType(DOUBLE_LITERAL); }
    |
	( '.' INTEGER_LITERAL )
	=> DECIMAL_LITERAL { $setType(DECIMAL_LITERAL); }
	|
	( '.' )
	=> SELF { $setType(SELF); }
	|
	( INTEGER_LITERAL ( '.' ( INTEGER_LITERAL )? )? ( 'e' | 'E' ) )
	=> DOUBLE_LITERAL
	{ $setType(DOUBLE_LITERAL); }
	|
	( INTEGER_LITERAL '.' )
	=> DECIMAL_LITERAL
	{ $setType(DECIMAL_LITERAL); }
	|
	INTEGER_LITERAL { $setType(INTEGER_LITERAL); }
	|
	SLASH { $setType(SLASH); }
	|
	{ !(inAttributeContent || inElementContent) }?
	DSLASH { $setType(DSLASH); }
	|
	BANG { $setType(BANG); }
	|
	COLON { $setType(COLON); }
	|
	MOD { $setType(MOD); }
	|
	COMMA { $setType(COMMA); }
	|
	SEMICOLON { $setType(SEMICOLON); }
	|
	STAR { $setType(STAR); }
	|
	QUESTION { $setType(QUESTION); }
	|
	PLUS { $setType(PLUS); }
	|
	MINUS { $setType(MINUS); }
	|
	LPPAREN { $setType(LPPAREN); }
	|
	RPPAREN { $setType(RPPAREN); }
	|
	LPAREN { $setType(LPAREN); }
	|
	RPAREN { $setType(RPAREN); }
	|
	AT { $setType(AT); }
	|
	DOLLAR { $setType(DOLLAR); }
	|
    ARROW_OP { $setType(ARROW_OP); }
    |
	EQ { $setType(EQ); }
	|
	{ !(inAttributeContent || inElementContent) }?
	NEQ { $setType(NEQ); }
	|
	XML_COMMENT_END { $setType(XML_COMMENT_END); }
	|
	AFTER { $setType(AFTER); }
	|
	GT { $setType(GT); }
	|
	XML_PI_END { $setType(XML_PI_END); }
	|
	XML_CDATA_END { $setType(XML_CDATA_END); }
	|
	PRAGMA_START
	{
		$setType(PRAGMA_START);
	}
	|
	{ inPragma }?
	PRAGMA_END
	{
		inPragma = false;
        //wsExplicit = true;
		$setType(PRAGMA_END);
	}
	|
	HASH { $setType(HASH); }
	;

protected NAME_START_CHAR
:
    ( 'A'..'Z' | '_' | 'a'..'z' | '\u00C0'..'\u00D6' | '\u00D8'..'\u00F6' | '\u00F8'..'\u02FF' | '\u0370'..'\u037D' | '\u037F'..'\u1FFF' | '\u200C'..'\u200D' | '\u2070'..'\u218F' |
    '\u2C00'..'\u2FEF' | '\u3001'..'\uD7FF' | '\uF900'..'\uFDCF' | '\uFDF0'..'\uFFFD' )
    ;

protected NAME_CHAR
:
    ( NAME_START_CHAR | '-' | '.' | '0'..'9' | '\u00B7' | '\u0300'..'\u036F' | '\u203F'..'\u2040' )
    ;

protected CHAR
:
	( '\t' | '\n' { newline(); } | '\r' | '\u0020'..'\u0039' | '\u003B'..'\uD7FF' | '\uE000'..'\uFFFD' )
	;

protected BASECHAR
:
	(
		'\u0041'..'\u005a'
		|
		'\u0061'..'\u007a'
		|
		'\u00c0'..'\u00d6'
		|
		'\u00d8'..'\u00f6'
		|
		'\u00f8'..'\u00ff'
		|
		'\u0100'..'\u0131'
		|
		'\u0134'..'\u013e'
		|
		'\u0141'..'\u0148'
		|
		'\u014a'..'\u017e'
		|
		'\u0180'..'\u01c3'
		|
		'\u01cd'..'\u01f0'
		|
		'\u01f4'..'\u01f5'
		|
		'\u01fa'..'\u0217'
		|
		'\u0250'..'\u02a8'
		|
		'\u02bb'..'\u02c1'
		|
		'\u0386'
		|
		'\u0388'..'\u038a'
		|
		'\u038c'
		|
		'\u038e'..'\u03a1'
		|
		'\u03a3'..'\u03ce'
		|
		'\u03d0'..'\u03d6'
		|
		'\u03da'
		|
		'\u03dc'
		|
		'\u03de'
		|
		'\u03e0'
		|
		'\u03e2'..'\u03f3'
		|
		'\u0401'..'\u040c'
		|
		'\u040e'..'\u044f'
		|
		'\u0451'..'\u045c'
		|
		'\u045e'..'\u0481'
		|
		'\u0490'..'\u04c4'
		|
		'\u04c7'..'\u04c8'
		|
		'\u04cb'..'\u04cc'
		|
		'\u04d0'..'\u04eb'
		|
		'\u04ee'..'\u04f5'
		|
		'\u04f8'..'\u04f9'
		|
		'\u0531'..'\u0556'
		|
		'\u0559'
		|
		'\u0561'..'\u0586'
		|
		'\u05d0'..'\u05ea'
		|
		'\u05f0'..'\u05f2'
		|
		'\u0621'..'\u063a'
		|
		'\u0641'..'\u064a'
		|
		'\u0671'..'\u06b7'
		|
		'\u06ba'..'\u06be'
		|
		'\u06c0'..'\u06ce'
		|
		'\u06d0'..'\u06d3'
		|
		'\u06d5'
		|
		'\u06e5'..'\u06e6'
		|
		'\u0905'..'\u0939'
		|
		'\u093d'
		|
		'\u0958'..'\u0961'
		|
		'\u0985'..'\u098c'
		|
		'\u098f'..'\u0990'
		|
		'\u0993'..'\u09a8'
		|
		'\u09aa'..'\u09b0'
		|
		'\u09b2'
		|
		'\u09b6'..'\u09b9'
		|
		'\u09dc'..'\u09dd'
		|
		'\u09df'..'\u09e1'
		|
		'\u09f0'..'\u09f1'
		|
		'\u0a05'..'\u0a0a'
		|
		'\u0a0f'..'\u0a10'
		|
		'\u0a13'..'\u0a28'
		|
		'\u0a2a'..'\u0a30'
		|
		'\u0a32'..'\u0a33'
		|
		'\u0a35'..'\u0a36'
		|
		'\u0a38'..'\u0a39'
		|
		'\u0a59'..'\u0a5c'
		|
		'\u0a5e'
		|
		'\u0a72'..'\u0a74'
		|
		'\u0a85'..'\u0a8b'
		|
		'\u0a8d'
		|
		'\u0a8f'..'\u0a91'
		|
		'\u0a93'..'\u0aa8'
		|
		'\u0aaa'..'\u0ab0'
		|
		'\u0ab2'..'\u0ab3'
		|
		'\u0ab5'..'\u0ab9'
		|
		'\u0abd'
		|
		'\u0ae0'
		|
		'\u0b05'..'\u0b0c'
		|
		'\u0b0f'..'\u0b10'
		|
		'\u0b13'..'\u0b28'
		|
		'\u0b2a'..'\u0b30'
		|
		'\u0b32'..'\u0b33'
		|
		'\u0b36'..'\u0b39'
		|
		'\u0b3d'
		|
		'\u0b5c'..'\u0b5d'
		|
		'\u0b5f'..'\u0b61'
		|
		'\u0b85'..'\u0b8a'
		|
		'\u0b8e'..'\u0b90'
		|
		'\u0b92'..'\u0b95'
		|
		'\u0b99'..'\u0b9a'
		|
		'\u0b9c'
		|
		'\u0b9e'..'\u0b9f'
		|
		'\u0ba3'..'\u0ba4'
		|
		'\u0ba8'..'\u0baa'
		|
		'\u0bae'..'\u0bb5'
		|
		'\u0bb7'..'\u0bb9'
		|
		'\u0c05'..'\u0c0c'
		|
		'\u0c0e'..'\u0c10'
		|
		'\u0c12'..'\u0c28'
		|
		'\u0c2a'..'\u0c33'
		|
		'\u0c35'..'\u0c39'
		|
		'\u0c60'..'\u0c61'
		|
		'\u0c85'..'\u0c8c'
		|
		'\u0c8e'..'\u0c90'
		|
		'\u0c92'..'\u0ca8'
		|
		'\u0caa'..'\u0cb3'
		|
		'\u0cb5'..'\u0cb9'
		|
		'\u0cde'
		|
		'\u0ce0'..'\u0ce1'
		|
		'\u0d05'..'\u0d0c'
		|
		'\u0d0e'..'\u0d10'
		|
		'\u0d12'..'\u0d28'
		|
		'\u0d2a'..'\u0d39'
		|
		'\u0d60'..'\u0d61'
		|
		'\u0e01'..'\u0e2e'
		|
		'\u0e30'
		|
		'\u0e32'..'\u0e33'
		|
		'\u0e40'..'\u0e45'
		|
		'\u0e81'..'\u0e82'
		|
		'\u0e84'
		|
		'\u0e87'..'\u0e88'
		|
		'\u0e8a'
		|
		'\u0e8d'
		|
		'\u0e94'..'\u0e97'
		|
		'\u0e99'..'\u0e9f'
		|
		'\u0ea1'..'\u0ea3'
		|
		'\u0ea5'
		|
		'\u0ea7'
		|
		'\u0eaa'..'\u0eab'
		|
		'\u0ead'..'\u0eae'
		|
		'\u0eb0'
		|
		'\u0eb2'..'\u0eb3'
		|
		'\u0ebd'
		|
		'\u0ec0'..'\u0ec4'
		|
		'\u0f40'..'\u0f47'
		|
		'\u0f49'..'\u0f69'
		|
		'\u10a0'..'\u10c5'
		|
		'\u10d0'..'\u10f6'
		|
		'\u1100'
		|
		'\u1102'..'\u1103'
		|
		'\u1105'..'\u1107'
		|
		'\u1109'
		|
		'\u110b'..'\u110c'
		|
		'\u110e'..'\u1112'
		|
		'\u113c'
		|
		'\u113e'
		|
		'\u1140'
		|
		'\u114c'
		|
		'\u114e'
		|
		'\u1150'
		|
		'\u1154'..'\u1155'
		|
		'\u1159'
		|
		'\u115f'..'\u1161'
		|
		'\u1163'
		|
		'\u1165'
		|
		'\u1167'
		|
		'\u1169'
		|
		'\u116d'..'\u116e'
		|
		'\u1172'..'\u1173'
		|
		'\u1175'
		|
		'\u119e'
		|
		'\u11a8'
		|
		'\u11ab'
		|
		'\u11ae'..'\u11af'
		|
		'\u11b7'..'\u11b8'
		|
		'\u11ba'
		|
		'\u11bc'..'\u11c2'
		|
		'\u11eb'
		|
		'\u11f0'
		|
		'\u11f9'
		|
		'\u1e00'..'\u1e9b'
		|
		'\u1ea0'..'\u1ef9'
		|
		'\u1f00'..'\u1f15'
		|
		'\u1f18'..'\u1f1d'
		|
		'\u1f20'..'\u1f45'
		|
		'\u1f48'..'\u1f4d'
		|
		'\u1f50'..'\u1f57'
		|
		'\u1f59'
		|
		'\u1f5b'
		|
		'\u1f5d'
		|
		'\u1f5f'..'\u1f7d'
		|
		'\u1f80'..'\u1fb4'
		|
		'\u1fb6'..'\u1fbc'
		|
		'\u1fbe'
		|
		'\u1fc2'..'\u1fc4'
		|
		'\u1fc6'..'\u1fcc'
		|
		'\u1fd0'..'\u1fd3'
		|
		'\u1fd6'..'\u1fdb'
		|
		'\u1fe0'..'\u1fec'
		|
		'\u1ff2'..'\u1ff4'
		|
		'\u1ff6'..'\u1ffc'
		|
		'\u2126'
		|
		'\u212a'..'\u212b'
		|
		'\u212e'
		|
		'\u2180'..'\u2182'
		|
		'\u3041'..'\u3094'
		|
		'\u30a1'..'\u30fa'
		|
		'\u3105'..'\u312c'
		|
		'\uac00'..'\ud7a3'
	)
	;

protected IDEOGRAPHIC
:
	( '\u4e00'..'\u9fa5' | '\u3007' | '\u3021'..'\u3029' )
	;

protected COMBINING_CHAR
:
	(
		'\u0300'..'\u0345'
		|
		'\u0360'..'\u0361'
		|
		'\u0483'..'\u0486'
		|
		'\u0591'..'\u05a1'
		|
		'\u05a3'..'\u05b9'
		|
		'\u05bb'..'\u05bd'
		|
		'\u05bf'
		|
		'\u05c1'..'\u05c2'
		|
		'\u05c4'
		|
		'\u064b'..'\u0652'
		|
		'\u0670'
		|
		'\u06d6'..'\u06dc'
		|
		'\u06dd'..'\u06df'
		|
		'\u06e0'..'\u06e4'
		|
		'\u06e7'..'\u06e8'
		|
		'\u06ea'..'\u06ed'
		|
		'\u0901'..'\u0903'
		|
		'\u093c'
		|
		'\u093e'..'\u094c'
		|
		'\u094d'
		|
		'\u0951'..'\u0954'
		|
		'\u0962'..'\u0963'
		|
		'\u0981'..'\u0983'
		|
		'\u09bc'
		|
		'\u09be'
		|
		'\u09bf'
		|
		'\u09c0'..'\u09c4'
		|
		'\u09c7'..'\u09c8'
		|
		'\u09cb'..'\u09cd'
		|
		'\u09d7'
		|
		'\u09e2'..'\u09e3'
		|
		'\u0a02'
		|
		'\u0a3c'
		|
		'\u0a3e'
		|
		'\u0a3f'
		|
		'\u0a40'..'\u0a42'
		|
		'\u0a47'..'\u0a48'
		|
		'\u0a4b'..'\u0a4d'
		|
		'\u0a70'..'\u0a71'
		|
		'\u0a81'..'\u0a83'
		|
		'\u0abc'
		|
		'\u0abe'..'\u0ac5'
		|
		'\u0ac7'..'\u0ac9'
		|
		'\u0acb'..'\u0acd'
		|
		'\u0b01'..'\u0b03'
		|
		'\u0b3c'
		|
		'\u0b3e'..'\u0b43'
		|
		'\u0b47'..'\u0b48'
		|
		'\u0b4b'..'\u0b4d'
		|
		'\u0b56'..'\u0b57'
		|
		'\u0b82'..'\u0b83'
		|
		'\u0bbe'..'\u0bc2'
		|
		'\u0bc6'..'\u0bc8'
		|
		'\u0bca'..'\u0bcd'
		|
		'\u0bd7'
		|
		'\u0c01'..'\u0c03'
		|
		'\u0c3e'..'\u0c44'
		|
		'\u0c46'..'\u0c48'
		|
		'\u0c4a'..'\u0c4d'
		|
		'\u0c55'..'\u0c56'
		|
		'\u0c82'..'\u0c83'
		|
		'\u0cbe'..'\u0cc4'
		|
		'\u0cc6'..'\u0cc8'
		|
		'\u0cca'..'\u0ccd'
		|
		'\u0cd5'..'\u0cd6'
		|
		'\u0d02'..'\u0d03'
		|
		'\u0d3e'..'\u0d43'
		|
		'\u0d46'..'\u0d48'
		|
		'\u0d4a'..'\u0d4d'
		|
		'\u0d57'
		|
		'\u0e31'
		|
		'\u0e34'..'\u0e3a'
		|
		'\u0e47'..'\u0e4e'
		|
		'\u0eb1'
		|
		'\u0eb4'..'\u0eb9'
		|
		'\u0ebb'..'\u0ebc'
		|
		'\u0ec8'..'\u0ecd'
		|
		'\u0f18'..'\u0f19'
		|
		'\u0f35'
		|
		'\u0f37'
		|
		'\u0f39'
		|
		'\u0f3e'
		|
		'\u0f3f'
		|
		'\u0f71'..'\u0f84'
		|
		'\u0f86'..'\u0f8b'
		|
		'\u0f90'..'\u0f95'
		|
		'\u0f97'
		|
		'\u0f99'..'\u0fad'
		|
		'\u0fb1'..'\u0fb7'
		|
		'\u0fb9'
		|
		'\u20d0'..'\u20dc'
		|
		'\u20e1'
		|
		'\u302a'..'\u302f'
		|
		'\u3099'
		|
		'\u309a'
	)
	;

protected DIGIT
:
	(
		'\u0030'..'\u0039'
		|
		'\u0660'..'\u0669'
		|
		'\u06f0'..'\u06f9'
		|
		'\u0966'..'\u096f'
		|
		'\u09e6'..'\u09ef'
		|
		'\u0a66'..'\u0a6f'
		|
		'\u0ae6'..'\u0aef'
		|
		'\u0b66'..'\u0b6f'
		|
		'\u0be7'..'\u0bef'
		|
		'\u0c66'..'\u0c6f'
		|
		'\u0ce6'..'\u0cef'
		|
		'\u0d66'..'\u0d6f'
		|
		'\u0e50'..'\u0e59'
		|
		'\u0ed0'..'\u0ed9'
		|
		'\u0f20'..'\u0f29'
	)
	;

protected EXTENDER
:
	(
		'\u00b7'
		|
		'\u02d0'
		|
		'\u02d1'
		|
		'\u0387'
		|
		'\u0640'
		|
		'\u0e46'
		|
		'\u0ec6'
		|
		'\u3005'
		|
		'\u3031'..'\u3035'
		|
		'\u309d'..'\u309e'
		|
		'\u30fc'..'\u30fe'
	)
	;

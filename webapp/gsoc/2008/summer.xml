<?xml version="1.0" encoding="UTF-8"?>
<book>
  <bookinfo>
    <graphic fileref="logo.jpg"/>
    <productname>Open Source Native XML Database</productname>
    <title>Google Summer of Code 2008</title>
    <author>
      <firstname>Adam</firstname>
      <surname>Retter</surname>
    </author>
  </bookinfo>

  <ci:include xmlns:ci="http://apache.org/cocoon/include/1.0" src="sidebar.xml"/>

  <chapter>
    <title>Google Summer of Code 2008</title>
    
        <para>Last year eXist participated in the Google Summer of Code for the first time and after
        what we feel was a successful summer, we have decided to apply to participate again this year.</para>
        
        <para>In 2007 we had two students working on an XQJ implementation and Text Searc Extensions for XQuery respectively.
        The first version of the XQJ implementation is almost complete and waiting to be merged with the main code base and the
        Text Search Extensions whilst needing a little more work should also be merged in soon.</para>
        
        <para>Suggested projects are listed below, however students may also propose their own projects. If proposing a project we
        suggest discussing it with us before submitting you student application to ensure that it is suitable and viable.</para>
        
        <para>For all questions concerning the Summmer of Code,
        contact our GSoC administrators <ulink url="mailto:existadmin@gmail.com">eXistAdmin@gmail.com</ulink>, send an email to the
        exist-open <ulink url="http://sourceforge.net/mail/?group_id=17691">mailing list</ulink>
        or meet us in <ulink url="http://irc.exist-db.org/">IRC</ulink>. For short questions, IRC
        is the preferred medium.</para>
    
    <section>
    	<title>Timeline</title>
    	<itemizedlist>
   	    	<listitem><del>5th - 12th March - eXist applies to Google Summer of Code</del></listitem>
   	    	<listitem><del>13th - 14th March - eXists application considered by Google</del></listitem>
	    	<listitem><del>14th - 26th March - Student Applications</del></listitem>
	    	<listitem><del>26th March - 10th April - Appraisal and evaluation of student applications</del></listitem>
	    	<listitem><del>11th April - Successful student applications announced</del></listitem>
	    	<listitem><del>11th April - 27th May - Students learn about eXist community and project</del></listitem>
	    	<listitem>28th May - Students begin coding</listitem>
	    	<listitem>9th July - Students upload work in progress / Mentors start mid-term evaluation</listitem>
	    	<listitem>16th July - Mentors finish mid-term evaluation</listitem>
	    	<listitem>20th August - Students finish coding and start evaluation / Mentors start final evaluation</listitem>
	    	<listitem>31st August - Students and Mentors finish final evaluation</listitem>
	    	<listitem>3rd September - Students submit required code samples to Google</listitem> 
    	</itemizedlist>
    </section>
    
    <section>
	    <title>Accepted Projects</title>
	    <para>No projects have been accepted yet.</para>
    </section>
                
    <section>
      <title>Suggested Project Ideas</title>

      <section>
	<title>Remote Debugging Interface</title>

	<para>XQuery programs can get quite complex (scripts with more than 1000 lines are not uncommon), especially
	if they use a lot of modules. However, debugging the code is currently a tedious, time-consuming job due to the lack
	of tool support. While some commercial XML editors do already include XQuery debuggers (e.g. Oxygen), eXist lacks an appropriate
	debugging API to interface with them.</para>

	<para>A remote debugging API should be implemented on top of the eXist server. This should at least include the
	ability to stop XQuery execution at predefined breakpoints, inspect the current query context and switch into single-step
	execution. A basic command-line or graphical debugging interface should be shipped with eXist. The Oxygen team
	already expressed their interest to support eXist from their commercial XQuery debugger.</para>

	<para><emphasis>Resources:</emphasis></para>

	<itemizedlist>
	  <listitem>
	    <para>see the debugging API in <ulink url="saxon.sf.net">saxon</ulink></para>
	  </listitem>
	  <listitem>
	    <para>XQuery debugger in <ulink url="http://www.oxygenxml.com/xquery_debugger.html">Oxygen</ulink> (commercial product)</para>
	  </listitem>
	</itemizedlist>
      </section>

   <section>
	<title>Implement Full ACID Transaction Support</title>

	<para>Transaction support in eXist is currently limited to the functionality needed for crash recovery. Though eXist
	maintains transactions internally, they are currently not exposed to applications. Also, read operations are
	not transactional right now. In order to allow full user-controlled ACID transactions, some missing functionality
	needs to be implemented:</para>

	<itemizedlist>
	  <listitem>
	    <para>Concurrency control: eXist currently implements locking on the level of documents and collections. For
	    better transaction support, we need a more fine-grained concurrency control within the core B+-tree and an improved
	    lock management to detect or avoid deadlock situations.</para>
	  </listitem>

	  <listitem>
	    <para>While eXist does already support full redo/undo operations during crash recovery, it does not provide a
	    rollback facility at runtime. Users can not explicitely abort and roll back a transaction (that's why we don't
	    expose transactions to the user at all). Performing a rollback on the core db files would be easily possible, but
	    we also need to take care of any indexes defined on the data.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
	<title>Implement an XSLT 2.0 Processor</title>

	<para>eXist aims to be compliant with XQuery 2.0 specifications. It would be interesting that the "sister" recommendation, XSLT 2.0, should be implemented as well,
	thus allowing XSLT 2.0 processing on (eventually huge) persistent documents. Most of the code is already here since both recommendations are built on-top of XPath 2.0. </para>
	<para>However, this is still to be implemented:</para>
	<itemizedlist>
	  <listitem>
	    <para>Clean separation of XPath 2.0 and XQuery 1.0 code. 
	    Exist used to have a dedicated package for XPath in the past: it somehow has to be revived and the XQuery 1.0 specific classes have to be moved to a dedicated package. 
	    Functions, including experimental grouping ones (which have to be improved with regard to performance) have to be moved as well.</para>
	  </listitem>
	  <listitem>
	    <para>Write a dedicated XSLT 2.0 frontend to the existing XQuery 1.0 parser that would be used to build the expression tree.</para>
	  </listitem>
	  <listitem>
	    <para>Attention should be drawn to performance concerns. Recent code is definitely more friendly to the programmer with regard to performance. Implementing an XSLT 2.0 processor could help in bringing even more improvements in this area.</para>
	  </listitem>
	</itemizedlist>
	
	<para><emphasis>Resources:</emphasis></para>

	<itemizedlist>
	  <listitem>
	    <para><ulink url="http://www.w3.org/TR/xslt20/">XSL Transformations (XSLT) Version 2.0</ulink>. W3C Recommendation.</para>
	  </listitem>
	  <listitem>
	    <para><ulink url="http://monet.nag.co.uk/xq2xml//xsltest-20061026.zip">XQ2XML: XML syntaxes for XQuery</ulink>. A test suite by David Carlisle that provides an XSLT 2.0 syntax for some of the <ulink url="http://www.w3.org/XML/Query/test-suite/">XQuery test suite</ulink> tests.</para>
	  </listitem>
	</itemizedlist>
      </section>

      <section>
	<title>Distributed Search</title>

	<para>Implement a federated search service over distributed eXist databases. There are various reasons why users may
	have more than one database instance deployed, for example, to distribute load or to keep sensitive data in its own
	data store. Another important area of application would be in the context of grid computing.</para>

	<para>Unfortunately, there's no simple way to combine results from distributed data stores in a single XQuery. eXist's
	query engine can only operate on local resources. It can retrieve data from external locations, but only to store them into a
	local, temporary resource, which is then used for querying. A distributed search facility would allow eXist to directly forward parts of an expression to a remote database
	instance. The XQuery specification already provides the necessary framework: the collection() and doc() functions
	both accept arbitrary URIs, so collections as well as resources can be at external locations.</para>

	<para>The main challenge will be to properly merge intermediate results from different database instances and track references
	to remote node sequences throughout the query.</para>
      </section>

      <section>
	<title>Process control and management service</title>

	<para>Implement a process control and management service à la the top and ps tools. There are various uses for a process control and management service, keeping track of running processes in the current DB instance, showing cache and memory statistics, be able to cancel or set different processing permissions on the fly for each query process, etc.</para>

	<para>The fundamentals for this could be JMX with the current cache and memory statistics and the QueryWatchDog which at the moment only restricts queries in number of created temmporary nodes and in the total time allowed for processing it, while not allowing any interactive management.</para>
	<para><emphasis>Resources:</emphasis></para>
	<itemizedlist>
	  <listitem>
	  <para><ulink url="http://jcp.org/aboutJava/communityprocess/final/jsr003/index3.html">JSR 003</ulink></para>
	  </listitem>
	  <listitem>
	    <para><ulink url="http://java.sun.com/javase/technologies/core/mntr-mgmt/javamanagement/">JMX resources</ulink></para>
	  </listitem>
	</itemizedlist>
      </section>

        <section>
          <title>Add index-support for order-by, distinct-values and aggregate functions</title>

            <para>Sorting a set of nodes is a frequent operation in many XQuery applications. The "order by" clause in XQuery is
            very powerful and allows the definition of an arbitrary number of ordering specificiations to be applied on the tuple stream
            returned by a FLWOR expression.</para>

            <para>However, ordering is quite expensive: for each tuple in the return sequence we have to evaluate all ordering expressions once
                and atomize the result, i.e. transform it into an atomic sequence. Atomization requires access to the actual node stored
                in the db, thus generating a huge amount of IO. As a result, "order by" expressions should always be applied with care. Query execution times will increase linearily with
                the size of the return sequence.</para>

            <para>To improve this, eXist should at least provide indexed access to the atomized values needed for the ordering.
                Unfortunately, the existing index structures can not be directly used: the range index maps atomized node values to
                a sequence of node ids, while order by would need to order node ids by their node value. So either the existing range
                index has to be extended to support value lookups by node id or a new index structure has to be implemented.</para>

            <para>Other XQuery operations could benefit from such an index as well: this includes the aggregate functions min, max
            and sum, as well as distinct-values.</para>
      </section>
    </section>

    <section>
        <title>Mentors</title>
        
        <para>The following people are available as mentors. Once your project has been accepted,
        you will be assigned one or two mentors to support you directly, however all mentors will provide support where required.</para>
        
        <itemizedlist>
            <listitem>
                <para>Adam Retter (GSoC Administrator)</para>
            </listitem>
            <!--
            <listitem>
                <para>Pierrick Brihaye</para>
            </listitem>
            
            <listitem>
                <para>Leif-Jöran Olsson</para>
            </listitem>
             -->
            <listitem>
                <para>Dannes Wessels</para>
            </listitem>
            <listitem>
                <para>Wolfgang Meier</para>
            </listitem>
            <!--
            <listitem>
	            <para>Kurt Cagle</para>
            </listitem>
             -->
        </itemizedlist>
        
     </section>
  </chapter>
</book>
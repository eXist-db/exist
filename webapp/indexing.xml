<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:ci="http://apache.org/cocoon/include/1.0">
    <bookinfo>
        <graphic fileref="logo.jpg"/>
        <productname>Open Source Native XML Database</productname>
        <title>Configuring Database Indexes</title>
        <orgname>The eXist Project</orgname>
    </bookinfo>
    <ci:include src="sidebar.xml"/>
    <chapter>
        <title>Configuring Database Indexes</title>
        <section>
            <title>Overview</title>
            <para>In this section, we discuss the types of database indexes used by eXist, as well
                as how they are created, configured and maintained. It assumes readers have a basic
                understanding of XML and XQuery. For an introduction we suggest to first read the
                wiki article <ulink url="http://atomic.exist-db.org/wiki/blogs/eXist/NewIndexing">
                    "Understanding the new indexing features"</ulink>, which also lists some simple
                guidelines on which index should be used for what.</para>

            <para>Database indexes are used extensively by eXist to facilitate efficient querying of
                the database. This is accomplished both by system-generated and user-configured
                database indexes. The current version of eXist by default includes the following types of
                indexes:</para>

            <orderedlist>
                <listitem>
                    <para>
                        <emphasis>
                            <ulink url="#structuralidx">Structural Indexes</ulink>
                        </emphasis>: These index the nodal structure, elements (tags) and
                        attributes, of the documents in a collection.</para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>
                            <ulink url="#rangeidx">Range Indexes</ulink>
                        </emphasis>: These map specific text nodes and attributes of the documents in a collection
                        to typed values.</para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>
                            <ulink url="#ftidx">Full Text Indexes</ulink>
                        </emphasis>: These map specific text nodes and attributes of the documents
                        in a collection to text tokens.</para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis>
                            <ulink url="#ngramidx">NGram Indexes</ulink>
                        </emphasis>: These map specific text nodes and attributes of the documents in a collection
                        to splitted tokens of n-characters (where n = 3 by default). Very efficient for exact substring searches and for queries on
                        scripts (mostly non-european ones)  which can not be easily split into whitespace
                        separated tokens and are thus a bad match for the full text index. </para>
                </listitem>
                <listitem>
                    <para>
                        <emphasis><ulink url="#spatialidx">Spatial Indexes</ulink>
                        (Experimental)</emphasis>: These map elements of the documents in a collection
                        containing georeferenced geometries to dedicated data structures that allow efficient spatial queries. </para>                        
                </listitem>
            </orderedlist>
                <note>
                    <para>Currently, comment and processing instruction nodes are not indexed.</para>
                    <para>Whether they should be or not, and how some processing instructions could "hint" the
                    indexing process is still being considered.</para>
                </note>

            <para>Since version 1.2, eXist features a new modularized indexing architecture. Most
                types of indexes have been moved out of the database core and are now maintained as
                pluggable extensions. The full text, ngram and spatial indexes fall under this
                category. Please refer to the above-mentioned <ulink
                    url="http://atomic.exist-db.org/wiki/blogs/eXist/NewIndexing">article</ulink>
                for a description of the new architecture.</para>
        </section>

        <section>
            <title>Index Types</title>

            <para>This section describes the features of those indexes that are part of the eXist
                distribution. Some of those indexes (n-gram, spatial) may need to be enabled first
                (see <ulink url="#moduleconf">below</ulink>). </para>

            <section id="structuralidx">
                <title>Structural index</title>
                <para>This index keeps track of the elements (tags), attributes, and nodal structure
                    for all XML documents in a collection. It is created and maintained
                    automatically in eXist, and can neither be reconfigured nor disabled by the
                    user. The structural index is required for nearly all XPath and XQuery
                    expressions in eXist (with the exception of wildcard-only expressions such as
                        "<command>//*</command>"). This index is stored in the database file
                        <filename>elements.dbx</filename>. </para>
                <para>Technically, the structural index maps every element and attribute
                        <emphasis>qname</emphasis> (or <emphasis>qualified name</emphasis>) in a
                    document collection to a list of <sgmltag>documentId, nodeId</sgmltag> pairs.
                    This mapping is used by the query engine to resolve queries for a given XPath
                    expression.</para>
                <para>For example, given the following query:</para>
                <synopsis>//book/section</synopsis>
                <para>eXist uses two index lookups: the first for the <sgmltag>book</sgmltag> node, and the second
                    for the <sgmltag>section</sgmltag> node. It then computes the <emphasis>structural
                    join</emphasis> between these node sets to determine which <sgmltag>section</sgmltag> elements
                    are in fact children of <sgmltag>book</sgmltag> elements.</para>
            </section>

            <section id="rangeidx">
                <title>Range index</title>
                <para>Range indexes provide a shortcut for the database to directly select nodes
                    based on their typed values. They are used when matching or comparing nodes by
                    way of standard XPath operators and functions. Without a range index, comparison
                    operators like =, &gt; or &lt; will default to a "brute-force"
                    inspection of the DOM, which can be extremly slow if eXist has to search through
                    maybe millions of nodes: each node has to be loaded and cast to the target type.</para>

                <para>To see how range indexes work, consider the following fragment:</para>

                <example>
                    <title>Example: List Entry</title>
                    <programlisting>
<markup><![CDATA[<items>
    <item n="1">
       <name>Tall Bookcase</name>
       <price>299.99</price>
    </item>
    <item n="2">
       <name>Short Bookcase</name>
       <price>199.99</price>
    </item>
</items>]]></markup>
                    </programlisting>
                </example>

                <para>With this short inventory, the text nodes of the <sgmltag>price</sgmltag> elements have dollar
                    values expressed as a floating-point number, (e.g. "299.99"), which has an
                        <ulink url="http://www.w3.org/TR/xmlschema-0/">XML Schema Definition</ulink>
                    (XSD) data type of <command>xs:double</command>. Using this builtin type to
                    define a range index, we can improve the efficiency of searches for <sgmltag>price</sgmltag>
                    values. (Instructions on how to configure range indexes using configuration
                    files are provided under the <ulink url="#idxconf">Configuring Indexes</ulink> section
                    below.) During indexing, eXist will apply this data type selection by attempting
                    to cast all <sgmltag>price</sgmltag> values as double floating point numbers,
                    and add appropriate values to the index. Values that cannot be cast as double
                    floating point numbers are therefore ignored. This range index will then be used
                    by any expression that compares <sgmltag>price</sgmltag> to an <command>xs:double</command> value -
                    for instance:</para>

                <synopsis>//item[price &gt; 100.0]</synopsis>

                <para>For non-string data types, the range index provides the query engine a more
                    efficient method of data conversion. Instead of retrieving the value of each
                    selected element and casting it as a <command>xs:double</command> type, the
                    engine can evaluate the expression by using the range index as a form of lookup
                    index. Without an index, eXist has to do a full scan over all price <sgmltag>price</sgmltag> elements,
                    retrieve the string values of their text node and cast them to a double number. This is a
                    time-consuming process which also scales very bad with growing data sets. With a
                    proper index, eXist needs just a single index lookup to evaluate <command>price
                        = 100.0</command>. The range expression <command>price &gt;
                    100.0</command> is processed with an index scan starting at 100. </para>

                <para>For string data, the index will also be used by the standard functions
                        <function>fn:contains()</function>, <function>fn:starts-with()</function>,
                        <function>fn:ends-with()</function> and <function>fn:matches()</function>.</para>

                <para>To illustrate this functionality, let's return to the previous example. If you
                    define a range index of type <command>xs:string</command> for element
                        <sgmltag>name</sgmltag>, a query on this element to select tall bookcases
                    using <function>fn:matches()</function> will be supported by the following
                    index:</para>

                <synopsis>//item[fn:matches(name, '[Tt]all\s[Bb]')]</synopsis>

                <para>Note that <function>fn:matches</function> will by default try to match the regular expression
                        <emphasis>anywhere</emphasis> in the string. We can thus speed up the query
                    dramatically by using "^" to restrict the match to the start of the string: </para>

                <synopsis>//item[fn:matches(name, '^[Tt]all\s[Bb]')]</synopsis>

                <para>Also, if you really need to search for an exact substring in a longer text
                    sequence, it is often better to use the NGram index instead of the range index,
                    i.e. use <function>ngram:contains()</function> instead of
                        <function>fn:contains()</function>. Unfortunately, there's no equivalent
                    NGram function for <function>fn:matches()</function> yet, but we may add one in the future as it
                    could help to increase performance dramatically.</para>

                <para>In general, three conditions must be met in order to optimize a search using a
                    range index:</para>

                <orderedlist>
                    <listitem>
                        <para>
                            <emphasis>The range index must be defined on <emphasis>all</emphasis>
                                items in the input sequence.</emphasis>
                        </para>

                        <para>For example, suppose you have two collections in the database: C1 and
                            C2. If you have a range index defined for collection C1, but your query
                            happens to operate on both C1 and C2, then the range index would <emphasis>not</emphasis> be
                            used. The query optimizer selects an optimization strategy based on the
                            entire input sequence of the query. Since, in this example, since only
                            nodes in C1 have a range index, no range index optimization would be
                            applied.</para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>The index data type (first argument type) must match the test
                                data type (second argument type).</emphasis>
                        </para>

                        <para>In other words, with range indexes, there is no promotion of data
                            types (i.e. no data type precedes or replaces another data type). For
                            example, if you defined an index of type <command>xs:double</command> on
                                <sgmltag>price</sgmltag>, a query that compares this element's value
                            with a string literal would not use a range index, for instance:</para>

                        <synopsis>//item[price = '1000.0']</synopsis>

                        <para>In order to apply the range index, you would need to cast the value as
                            a type <command>xs:double</command>, i.e.:</para>

                        <synopsis>//item[price = xs:double($price)] (where $price is any test value)</synopsis>

                        <para>Similarly, when we compare <command>xs:double</command> values with
                                <command>xs:integer</command> values, as in, for instance:</para>

                        <synopsis>//item[price = 1000]</synopsis>

                        <para>the range index would again not be used since the
                            <sgmltag>price</sgmltag> data type differs from the test value type,
                            although this conflict might not seem as obvious as it is with string
                            values.</para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>The right-hand argument has no dependencies on the current
                                context item.</emphasis>
                        </para>
                        <para>That is, the test or conditional value must not depend on the value
                            against which it is being tested. For example, range indexes will not be
                            applied given the following expression:</para>
                        <synopsis>//item[price = self]</synopsis>
                    </listitem>
                </orderedlist>

                <para>Concerning range indexes on strings there's another restriction to be
                    considered: up to version 1.3, range indexes on strings can only be used with
                    the default unicode collation. Also, string indexes will always be case
                    sensitive (while n-gram and full text indexes are not). It is not yet possible to
                    define a string index on a different collation (e.g. for German or French) or to
                    make it case insensitve. This is a limitation we plan to address in the next
                    release.</para>
            </section>

            <section id="ftidx">
                <title>Fulltext Index</title>

                <para>This index is used to query for a sequence of separate "words" or tokens in a
                    longer stream of text. While building the index, the text is parsed into single
                    tokens which are then stored in the index.</para>

                <para>Historically, eXist has been creating a default full text index on all text
                    nodes and attribute values. This will likely change in the future as the index
                    is undergoing a major redesign. As the index becomes more configurable, we may
                    drop the current default indexing behaviour.</para>

                <para>Anyway, as for the other index types, you can configure the full text index in
                    the collection configuration and we will try to keep the configuration of the
                    new index backwards compatible. We thus recommend to create a collection
                    configuration file, disable the default index-all behaviour and define some
                    explicit full text indexes on your documents. The details of this process will
                    be described below.</para>

                <para>The full text index is only used in combination with eXist's fulltext search
                    extensions. In particular, you can use the following eXist-specific operators
                    and functions that apply a fulltext index:</para>

                <itemizedlist>
                    <listitem>
                        <para>Operators: <command>&amp;=</command> and
                        <command>|=</command></para>
                    </listitem>
                    <listitem>
                        <para>Main Functions: <function>text:match-all()</function>,
                                <function>text:match-any()</function> and
                            <function>near()</function></para>
                    </listitem>
                </itemizedlist>

                <para>Check the <ulink url="xquery.xml#ftidx">XQuery Documentation</ulink> for more
                    information.</para>

                <note>
                    <para>It is important to note that, if you have disabled full text indexing for
                        certain elements, these operators and functions will also be effectively
                        disabled, and will not return matches. As a result, eXist will not return
                        results for queries that normally would have results provided fulltext
                        indexing was enabled. Note also that this is in direct contrast to the
                        operation of range indexing, which does fallback to full searching of the
                        document if no range index applies (see below).</para>
                </note>
            </section>

            <section id="ngramidx">
                <title>NGram Index</title>

                <para>The n-gram index splits the text it receives into sequences of n-characters
                    (where n = 3 by default). For example, the text "love me" will be split into the
                    tri-grams: "lov", "ove", "ve_", "e_m", "_me" (I replaced the space char by a _).
                    From a user point of view, the n-gram index is comparable to the range index, though it processes
                    substring queries as fast as the full text index.</para>

                <para>The main motivation for creating the n-gram index was to better support
                    non-european languages (like Chinese). The full text index is a bad match for
                    these languages (and terribly slow) as they can not be easily split into
                    whitespace separated tokens (or "words").</para>

                <para>However, this type of index is also very efficient for exact substring
                    matches. The <function>ngram:contains()</function> function is much faster than the equivalent
                    <function>fn:contains()</function> with a range index. Contrary to the full text index, the n-gram
                    index does not split the text at word boundaries or whitespace. Whitespace and
                    punctuation are included in the index. To understand the difference, imagine you
                    have a paragraph:</para>

                <synopsis><![CDATA[<para>Hello, my friend!</para>]]></synopsis>

                <para>If you create a full text index on this paragraph, only the tokens "Hello",
                    "my" and "friend" will be stored in the index. The query</para>

                <synopsis>//para[near(., ", my friend")]</synopsis>

                <para>will thus return all paragraphs containing the words "my friend", but
                    punctuation and whitespace is simply ignored. Contrary to this, <function>ngram:contains()</function>
                    - like <function>fn:contains()</function> - searches for the exact string ", my friend":</para>

                <synopsis>//para[ngram:contains(., ", my friend")</synopsis>
            </section>

            <section id="spatialidx">
                <title>Spatial Index</title>

                <para>A working proof-of-concept index, which listens for spatial geometries
                    described through the Geography Markup Language (GML). A detailed description of
                    the implementation can be found in the <ulink url="devguide_indexes.xml"
                        >Developer's Guide to Modularized Indexes</ulink>.</para>
            </section>
        </section>

        <section id="moduleconf">
            <title>Enabling Index Modules in conf.xml</title>

            <para>Since version 1.2, eXist features a <emphasis>modularized indexing architecture</emphasis>, 
                which allows arbitrary indexes to be plugged into an indexing pipeline. Consequently, some
                indexes were moved out of the database core and are now available as plugins. For
                the DB core, those indexes are a black box: they handle their own creation,
                configuration, destruction etc. To activate an index plugin, it needs to be added to
                the <sgmltag>modules</sgmltag> section within the global configuration file
                    <filename>conf.xml</filename>:</para>

            <example>
                <title>Index Plugin Configuration in conf.xml</title>
                
                <programlisting>
<markup><![CDATA[<modules>
    <module id="ngram-index" class="org.exist.indexing.ngram.NGramIndex"
        file="ngram.dbx" n="3"/>
    <!-- The full text index is always required and should
         not be disabled. We still have some dependencies on
         this index in the database core. These will be removed
         once the redesign has been completed. -->
    <module id="ft-legacy-index" class="org.exist.fulltext.FTIndex"/>
</modules>]]></markup>
                </programlisting>
            </example>

            <para>Every <sgmltag>module</sgmltag> element needs at least an <option>id</option> and
                    <option>class</option> attribute. The class attribute contains the name of the
                plugin class, which has to be an implementation of
                    <classname>org.exist.indexing.Index</classname>.</para>
            
            <para>All other attributes or nested configuration elements below the <sgmltag>module</sgmltag>
            element are specific to the implementation and will differ between indexes. They should be
            documented by the index implementor.</para>
            
            <para>If an index implementation can not be loaded from the specified class, the entry will
            simply be ignored. A warning will be written to the logs which should provide more information
            on the issue which caused the configuration to fail.</para>
        </section>

        <section id="idxconf">
            <title>Configuring Indexes</title>

            <para>eXist has no "create index" command. Instead, indexes are configured in
                collection-specific configuration files. These files are stored as standard XML
                documents in the system collection: <filename>/db/system/config</filename>, which
                can be accessed like any other document (e.g. using the Admin interface or Java
                Client). In addition to defining settings for indexing collections, the
                configuration document specifies collection-specific other settings such as triggers
                or default permissions.</para>

            <para>The contents of the system collection (<filename>/db/system/config</filename>)
                mirrors the hierarchical structure of the main collection. Configurations are shared
                by descendants in the hierarchy unless they have their own configuration (i.e. the
                configuration settings for the child collection override those set for the parent).
                If no collection-specific configuration file is created for any document, the global
                settings in the main configuration file, <filename>conf.xml</filename>, will apply
                by default. That being said, the <filename>conf.xml</filename> file should only
                define the default global <emphasis>index creation policy</emphasis>.</para>

            <para> To configure a given collection - e.g. <filename>/db/foo</filename> - create a
                file <filename>collection.xconf</filename> and store it as
                    <filename>/db/system/config/db/foo/collection.xconf</filename>. Note the
                replication of the <filename>/db/foo</filename> hierarchy inside
                    <filename>/db/system/config/</filename>. Subcollections which do not have a
                    <filename>collection.xconf</filename> file of their own will be governed by the
                configuration policy specified for the closest ancestor collection which does have
                such a file, so you are not required to specify a configuration for every
                collection. Note, however, that configuration settings do not cascade. If you choose
                to deploy a <filename>collection.xconf</filename> file in a subcollection, you must
                specify in that file <emphasis>all</emphasis> the configuration options you wish to
                have applied to that subcollection (and any lower-level subcollections without
                    <filename>collection.xconf</filename> files of their own). </para>

            <note>
                <para>Due to backward compatibility concerns, the file does not have to be called
                        <filename>collection.xconf</filename>, which is now the preferred file name,
                    but it <emphasis>must</emphasis> have the <filename>.xconf</filename> extension.</para>
                <para>You can only have <emphasis>one</emphasis>
                    <filename>.xconf</filename> file at each level.</para>
            </note>

            <section>
                <title>Maintaining Indexes and Re-indexing</title>
                <table>
                    <title/>
                    <tgroup cols="2">
                        <tbody>
                            <tr>
                                <td>
                                    <para>The eXist index system automatically maintains and updates
                                        indexes defined by the user. You therefore do not need to
                                        update an index when you update a database document or
                                        collection. eXist will even update indexes following partial
                                        document updates via <emphasis>XUpdate</emphasis> or
                                            <emphasis>XQuery Update</emphasis> expressions.</para>
                                    <para>The only exception to eXist's automatic update occurs when
                                        you <emphasis>add a new index definition to an existing
                                            database collection</emphasis>. In this case, the new
                                        index settings will <emphasis>only</emphasis> apply to new data added to this
                                        collection, or any of its sub-collections, and <emphasis>not</emphasis> to
                                        previously existing data. To apply the new settings to the
                                        entire collection, you need to trigger a "manual reindex" of
                                        the collection being updated. You can re-index collections
                                        using the Java Admin Client (shown on the right). From the
                                        Admin menu, select
                                            <guimenu>File</guimenu>&#187;<guimenuitem>Reindex
                                            Collection</guimenuitem></para>
                                </td>
                                <td>
                                    <screenshot><graphic fileref="resources/client4.png"/></screenshot>
                                </td>
                            </tr>
                        </tbody>
                    </tgroup>
                </table>
            </section>

            <section>
                <title>Configuration Structure and Syntax</title>

                <para>Index configuration files are standard XML documents that have their elements
                    and attributes defined by the eXist namespace:</para>

                <synopsis>http://exist-db.org/collection-config/1.0</synopsis>

                <para>The following example shows a configuration example:</para>

                <example>
                    <title>Configuration Document</title>
                    <programlisting><markup><![CDATA[
<collection xmlns="http://exist-db.org/collection-config/1.0">
    <index>
        <fulltext default="none" attributes="false">
            <!-- Full text indexes -->
            <create qname="author"/>
            <create qname="title" content="mixed"/>
            <!-- "old" context-dependant configuration using the path attribute: -->
            <include path="booktitle"/>
        </fulltext>
        
        <!-- Range indexes -->
        <create qname="title" type="xs:string"/>
        <create qname="author" type="xs:string"/>
        <create qname="year" type="xs:int"/>
        <!-- "old" context-dependant configuration using the path attribute: -->
        <create path="//booktitle" type="xs:string"/>
        
        <!-- N-gram indexes -->
        <ngram qname="author"/>
        <ngram qname="title"/>
    </index>
</collection>
]]></markup></programlisting>
                </example>

                <para>All configuration documents have the <sgmltag>collection</sgmltag> root
                    element (in the <literal>http://exist-db.org/collection-config/1.0 namespace</literal>). 
                    These documents also have an <sgmltag>index</sgmltag> element directly
                    below the root element, which encloses the index configuration. Only <emphasis>one</emphasis>
                        <sgmltag>index</sgmltag> element is permitted in a document. Apart from the
                    index configuration, the document may also contain non index-related settings,
                    e.g. for triggers, which will not be covered here. </para>

                <para>In the <sgmltag>index</sgmltag> element are elements that define the various
                    index types. Each index type can add its own configuration elements, which are
                    directly forwarded to the corresponding index implementation. The example above
                    configures three different types of indexes: full text, range and ngram.</para>

                <section>
                    <title>Configuration by path vs. configuration by qname</title>

                    <para>It is important to note the difference between the <option>path</option>
                        and <option>qname</option> attributes used throughout above example. Both
                        attributes are used to define the elements or attributes to which the index
                        should be applied. However, the <option>path</option> attribute creates
                            <emphasis>context-dependant</emphasis> indexes, while the
                        <option>qname</option> attribute does not. The path attribute takes a simple
                        path expression: </para>

                    <synopsis><![CDATA[<create path="//book/title" type="xs:string"/>]]></synopsis>

                    <para>The path expression looks like XPath, but it's really not. Index path
                        syntax uses the following components to construct paths:</para>

                    <itemizedlist>
                        <listitem>
                            <para>Elements are specified by their <emphasis>qname</emphasis></para>
                        </listitem>
                        <listitem>
                            <para>Attributes are specified by <option>@[ATTRIBUTE]</option></para>
                        </listitem>
                        <listitem>
                            <para>Child nodes are selected using the forward-slash
                                (<option>/</option>)</para>
                        </listitem>
                        <listitem>
                            <para>All descendant nodes in a tree are selected using the double
                                forward-slash (<option>//</option>)</para>
                        </listitem>
                    </itemizedlist>

                    <para>The example above creates a range index of type string on all
                            <sgmltag>title</sgmltag> elements which are children of
                        <sgmltag>book</sgmltag> elements, which may occur at an arbitrary position
                        in the document tree. All other <sgmltag>title</sgmltag> elements, e.g.
                        those being children of <sgmltag>section</sgmltag> nodes, are not indexed.
                        The path expression thus defines a <emphasis>selective</emphasis> index,
                        which is also <emphasis>context-dependant</emphasis>: we always need look at
                        the context of each <sgmltag>title</sgmltag> node before we can determine if
                        this particular title is to be indexed or not.</para>

                    <para>This kind of context-dependant index definition helps to keep the index
                        small. But unfortunately, it makes it hard for the query optimizer to
                        properly rewrite the expression tree without missing some nodes. The
                        optimizer needs to make an optimization decision at compile time, where the
                        context of an expression is unknown or at least not exactly known (read the
                            <ulink url="http://atomic.exist-db.org/wiki/blogs/eXist/">blog
                        article</ulink> to get the whole picture). This means that some of the
                        highly efficient optimization techniques can not be applied to
                        context-dependant indexes!</para>

                    <para>We thus had to introduce an alternative configuration method which is not
                        context-dependant. To keep things simple, we decided to define the index on
                        the <emphasis>qname</emphasis> of the node alone and to ignore the context altogether:</para>

                    <synopsis><![CDATA[<create qname="title" type="xs:string"/>]]></synopsis>

                    <para>This results in an index being created on every <sgmltag>title</sgmltag>
                        element found in the document node tree. Section titles will be indexed as
                        well as chapter or book titles. This may result in a considerably larger
                        index, but it also allows the query engine to apply all available
                        optimization techniques, which can improve query times by an order of
                        magnitude. As so often, there's a trade-off between performance and storage
                        space. In many cases, the performance win can be dramatic enough to justify
                        an increase in index size.</para>

                    <important>
                        <para>To be on the safe side and to benefit from current and future
                            improvements in the query engine, you should prefer
                            <option>qname</option> over <option>path</option> - unless you really
                            need to exclude certain nodes from indexing.</para>
                    </important>
                </section>

                <section>
                    <title>Namespaces</title>

                    <para>If the document to be indexed uses namespaces, you should add an
                            <option>xmlns</option> attribute for each of the required namespaces to
                        the <sgmltag>index</sgmltag> element:</para>

                    <example>
                        <title>Using Namespaces</title>
                        <programlisting>
<markup><![CDATA[
<collection xmlns="http://exist-db.org/collection-config/1.0">
    <index xmlns:atom="http://www.w3.org/2005/Atom">
        <fulltext default="none" attributes="no">
            <create qname="atom:title"/>
        </fulltext>
        <create qname="atom:id" type="xs:string"/>
    </index>
</collection>
]]></markup>
                        </programlisting>
                    </example>

                    <para>The example configuration above creates two indexes on a collection of
                        atom documents. The two elements which should be indexed are both in the
                        <literal>atom</literal> namespace and we thus need to declare a mapping for this namespace.
                        Please note that the <option>xmlns</option> namespace attributes have to be specified on the
                            <sgmltag>index</sgmltag> element, not the <sgmltag>create</sgmltag> or
                            <sgmltag>fulltext</sgmltag> elements.</para>
                </section>

                <section>
                    <title>Range index configuration</title>

                    <example>
                        <title>Range Index Configuration</title>
                        <programlisting>
<markup><![CDATA[<!-- Range indexes -->
<create qname="title" type="xs:string"/>
<create qname="author" type="xs:string"/>
<create qname="year" type="xs:int"/>
<!-- "old" context-dependant configuration using the path attribute: -->
<create path="//booktitle" type="xs:string"/>]]></markup>
                        </programlisting>
                    </example>

                    <para>A range index is configured by adding a <sgmltag>create</sgmltag> element
                        directly below the root <sgmltag>index</sgmltag> node. As explained above,
                        the node to be indexed is either specified through a <option>path</option>
                        or a <option>qname</option> attribute.</para>

                    <para>As range indexes are type specific, the <option>type</option> attribute is
                        always required. The type should be one of the atomic XML schema types,
                        currently including <command>xs:string</command>, <command>xs:integer</command> and its derived types, <command>xs:double</command>,
                        <command>xs:float</command>, <command>xs:boolean</command> and <command>xs:dateTime</command>. 
                        Further types may be added in the
                        future. If the name of the type is unknown, the index configuration will be
                        ignored and you will get a warning written into the logs.</para>

                    <para>Please note that the index configuration will only apply to the node
                        specified via the <option>path</option> or <option>qname</option> attribute,
                        not to descendants of that node. Consider a mixed content element like:</para>

                    <example>
                        <title>Mixed Content Element</title>
                        <programlisting>
                            <markup><![CDATA[<mixed><s>un</s><s>even</s></mixed>]]></markup>
                        </programlisting>
                    </example>

                    <para>If an index is defined on <sgmltag>mixed</sgmltag>, the key for the index
                        is built from the concatenated text nodes of element
                        <sgmltag>mixed</sgmltag> and all its descendants, i.e. "uneven". The created
                        index will only be used to evaluate queries on <sgmltag>mixed</sgmltag>, but
                        not for queries on <sgmltag>s</sgmltag>. However, you can create an
                        additional index on <sgmltag>s</sgmltag> without getting into conflict with
                        the existing index on <sgmltag>mixed</sgmltag>.</para>
                </section>

                <section id="ftidxconf">
                    <title>Full text index configuration</title>

                    <para>The <emphasis>fulltext index</emphasis> is defined by the
                            <sgmltag>fulltext</sgmltag> element - along with
                        <sgmltag>include</sgmltag>, <sgmltag>exclude</sgmltag> and
                        <sgmltag>create</sgmltag> elements. The full text index is currently subject
                        to a major redesign and the configuration syntax somewhat reflects this
                        because it is a bit inconsistent. eXist's current default behaviour is to
                        create a full text index on all text nodes in a document. The <sgmltag>include</sgmltag> and
                        <sgmltag>exclude</sgmltag> tags are used to add or hide nodes from the default indexing. The
                        indexes created by the default indexing are always context-dependant. The
                        nodes to include/exclude are thus specified via a <option>path</option>
                        attribute, not a <option>qname</option> attribute. </para>

                    <para>However, you can create explicit indexes on a qname using the
                            <sgmltag>create</sgmltag> element. This is the recommended approach. In
                        fact, as the full text index is currently being redesigned, we are not sure
                        if we will keep the current default full text indexing in its current state.
                        A fulltext configuration which only uses <sgmltag>create</sgmltag> elements is shown below: </para>

                    <example>
                        <title>Full text index configuration</title>
                        <programlisting>
                            <markup><![CDATA[
<fulltext default="none" attributes="false">
      <!-- Full text indexes -->
      <create qname="author"/>
      <create qname="title" content="mixed"/>
</fulltext>
]]></markup>
                        </programlisting>
                    </example>

                    <para>With this example, the full text default attribute is set to "none", which
                        disables the default full text indexing for all document elements. Attribute
                        nodes are handled separately. Setting <option>attributes="false"</option>
                        disables the default indexing for attributes as well. </para>

                    <para>The first child element creates a standard full text index on all <sgmltag>author</sgmltag>
                        elements, identified by their <emphasis>qname</emphasis>. The second one puts an index on <sgmltag>title</sgmltag>,
                        but adds an option <option>content="mixed"</option>. This parameter causes
                        the indexer to watch out for mixed-content nodes. For example, if your
                        source XML contains markup like:</para>

                    <example>
                        <title>Mixed Content Element</title>
                        <programlisting>
                            <markup><![CDATA[<p>Some <span>un</span><span>even</span> amount.</p>]]></markup>
                        </programlisting>
                    </example>

                    <para>You may want to treat "uneven" as a single word so you can query for p |=
                        "uneven". In this case, you need to pass content="mixed" to the indexer. The
                        concatenated text nodes of element mixed and all its descendants will be
                        passed to the indexer as one single string. The indexer thus sees and
                        indexes "uneven" as a single token.</para>

                    <para>On the other hand, if you have</para>

                    <example>
                        <title>Not a Mixed Content Element</title>
                        <programlisting>
                            <markup><![CDATA[<date><year>1183</year><month>March</month><date>]]></markup>
                        </programlisting>
                    </example>

                    <para>you probably want to be able to query for "March" even though there's no
                        space between the year and month elements. In this case the standard
                        settings are ok as they will add a virtual break between the elements.</para>

                </section>

                <section>
                    <title>N-gram index configuration</title>

                    <para>To create an n-gram index, add a <sgmltag>ngram</sgmltag> element directly
                        below the root <sgmltag>index</sgmltag> node. The n-gram index only supports
                        index definitions by <option>qname</option>. The <option>path</option>
                        attribute is not supported (we currently don't see many real use cases for
                        it). Right now, the n-gram index has no additional parameters to be
                        specified; the default settings should just be ok for most cases (we may add
                        extra parameters in the future, e.g. for collapsing/normalizing
                    whitespace).</para>
                </section>
            </section>
        </section>
        <section>
            <title>Debugging the Range Index</title>
            <para>It is sometimes a bit difficult to see if a range index is correctly defined or
                not. The simplest way to get some information on index usage is to set the priority
                for eXist's standard logger to <option>TRACE</option>. For example, change the
                    <sgmltag>root</sgmltag> category in <filename>log4j.xml</filename> as follows:</para>
            <example>
                <title>Configure log4j to Display Trace Output</title>
                <programlisting>
                    <markup><![CDATA[<root>
    <priority value="trace"/>
    <appender-ref ref="console"/>
</root>]]></markup>
                </programlisting>
            </example>
            <para>This enables trace and sends all log output to the console instead of the log
                files. For expressions that can benefit from a range index, you should now see
                messages like "Checking if range index can be used ..." or "Using range index for
                key...".</para>

            <para>Another possibility to see what's in your index is to use the <function>util:index-keys</function>
                function:</para>

            <example>
                <title>Query to List Index Contents</title>
                <programlisting language="xquery"><![CDATA[
declare function local:term-callback($term as xs:string, $data as xs:int+) as element() {
   <entry>
     <term>{$term}</term>
     <frequency>{$data[1]}</frequency>
     <documents>{$data[2]}</documents>
     <position>{$data[3]}</position>     
   </entry>
};
util:index-keys(//city/name, "T", util:function("local:term-callback", 2), 1000)]]></programlisting>
            </example>
            <para>This query will show you 1000 keys (starting with the letter 'T') indexed for the
                element selected by the path expression <option>//city/name</option> together with
                some information about this key.</para>
        </section>
    </chapter>
</book>

// $ANTLR 2.7.7 (2006-11-01): "XQuery.g" -> "XQueryParser.java"$

	package org.exist.xquery.parser;

	import antlr.debug.misc.*;
	import java.io.StringReader;
	import java.io.BufferedReader;
	import java.io.InputStreamReader;
	import java.util.ArrayDeque;
	import java.util.ArrayList;
	import java.util.Deque;
	import java.util.List;
	import java.util.Iterator;
	import org.exist.storage.BrokerPool;
	import org.exist.storage.DBBroker;
	import org.exist.EXistException;
	import org.exist.dom.persistent.DocumentSet;
	import org.exist.dom.persistent.DocumentImpl;
	import org.exist.dom.QName;
	import org.exist.security.PermissionDeniedException;
	import org.exist.xquery.*;
	import org.exist.xquery.value.*;
	import org.exist.xquery.functions.fn.*;

import antlr.TokenBuffer;
import antlr.TokenStreamException;
import antlr.TokenStreamIOException;
import antlr.ANTLRException;
import antlr.LLkParser;
import antlr.Token;
import antlr.TokenStream;
import antlr.RecognitionException;
import antlr.NoViableAltException;
import antlr.MismatchedTokenException;
import antlr.SemanticException;
import antlr.ParserSharedInputState;
import antlr.collections.impl.BitSet;
import antlr.collections.AST;
import java.util.Hashtable;
import antlr.ASTFactory;
import antlr.ASTPair;
import antlr.collections.impl.ASTArray;

/**
eXist parses an XQuery expression in (currently) 4 phases:

1) lexical analysis in XQueryLexer
2) syntax analysis and construction of an intermediate AST (abstract
	syntax tree) in XQueryParser
3) analysis of the intermediate AST, and construction of the executable XQuery
	expression tree from the intermediate AST in {@link XQueryTreeParser}
4) static analysis of the final expression tree

The grammar in XQuery.g corresponds to phase 2. It generates an
intermediate AST which will then be parsed a second time by
XQueryTree.g.

ANTLR provides a special syntax for tree parsers. Every
action returns an AST node and the # references these nodes.
#[VARIABLE_BINDING, varName] constructs a new AST node of type
VARIABLE_BINDING, which is prepended to the default AST generated by
the production.

ANTLR's meta language for tree construction is described in the ANTLR reference manual:
http://www.antlr.org/doc/index.html .

 */
public class XQueryParser extends antlr.LLkParser       implements XQueryTokenTypes
 {

	protected List<Exception> exceptions = new ArrayList<>(2);
	protected boolean foundError = false;
	protected Deque<Deque<String>> globalStack = new ArrayDeque<>();
	protected Deque<String> elementStack = new ArrayDeque<>();
	protected XQueryLexer lexer;

	public XQueryParser(XQueryLexer lexer) {
		this((TokenStream)lexer);
		this.lexer= lexer;
		setASTNodeClass("org.exist.xquery.parser.XQueryAST");
	}

	public boolean foundErrors() {
		return foundError;
	}

	public String getErrorMessage() {
		StringBuilder buf= new StringBuilder();
		for (Iterator i= exceptions.iterator(); i.hasNext();) {
			buf.append(((Exception) i.next()).toString());
			buf.append('\n');
		}
		return buf.toString();
	}

	public String getXQDoc() {
		return lexer.getXQDoc();
	}

	protected void handleException(Exception e) {
		foundError= true;
		exceptions.add(e);
	}

protected XQueryParser(TokenBuffer tokenBuf, int k) {
  super(tokenBuf,k);
  tokenNames = _tokenNames;
  buildTokenTypeASTClassMap();
  astFactory = new ASTFactory(getTokenTypeToASTClassMap());
}

public XQueryParser(TokenBuffer tokenBuf) {
  this(tokenBuf,1);
}

protected XQueryParser(TokenStream lexer, int k) {
  super(lexer,k);
  tokenNames = _tokenNames;
  buildTokenTypeASTClassMap();
  astFactory = new ASTFactory(getTokenTypeToASTClassMap());
}

public XQueryParser(TokenStream lexer) {
  this(lexer,1);
}

public XQueryParser(ParserSharedInputState state) {
  super(state,1);
  tokenNames = _tokenNames;
  buildTokenTypeASTClassMap();
  astFactory = new ASTFactory(getTokenTypeToASTClassMap());
}

	public final void imaginaryTokenDefinitions() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST imaginaryTokenDefinitions_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp1_AST = null;
		tmp1_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp1_AST);
		match(QNAME);
		org.exist.xquery.parser.XQueryAST tmp2_AST = null;
		tmp2_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp2_AST);
		match(EQNAME);
		org.exist.xquery.parser.XQueryAST tmp3_AST = null;
		tmp3_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp3_AST);
		match(PREDICATE);
		org.exist.xquery.parser.XQueryAST tmp4_AST = null;
		tmp4_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp4_AST);
		match(FLWOR);
		org.exist.xquery.parser.XQueryAST tmp5_AST = null;
		tmp5_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp5_AST);
		match(PARENTHESIZED);
		org.exist.xquery.parser.XQueryAST tmp6_AST = null;
		tmp6_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp6_AST);
		match(ABSOLUTE_SLASH);
		org.exist.xquery.parser.XQueryAST tmp7_AST = null;
		tmp7_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp7_AST);
		match(ABSOLUTE_DSLASH);
		org.exist.xquery.parser.XQueryAST tmp8_AST = null;
		tmp8_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp8_AST);
		match(WILDCARD);
		org.exist.xquery.parser.XQueryAST tmp9_AST = null;
		tmp9_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp9_AST);
		match(PREFIX_WILDCARD);
		org.exist.xquery.parser.XQueryAST tmp10_AST = null;
		tmp10_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp10_AST);
		match(FUNCTION);
		org.exist.xquery.parser.XQueryAST tmp11_AST = null;
		tmp11_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp11_AST);
		match(DYNAMIC_FCALL);
		org.exist.xquery.parser.XQueryAST tmp12_AST = null;
		tmp12_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp12_AST);
		match(UNARY_MINUS);
		org.exist.xquery.parser.XQueryAST tmp13_AST = null;
		tmp13_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp13_AST);
		match(UNARY_PLUS);
		org.exist.xquery.parser.XQueryAST tmp14_AST = null;
		tmp14_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp14_AST);
		match(XPOINTER);
		org.exist.xquery.parser.XQueryAST tmp15_AST = null;
		tmp15_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp15_AST);
		match(XPOINTER_ID);
		org.exist.xquery.parser.XQueryAST tmp16_AST = null;
		tmp16_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp16_AST);
		match(VARIABLE_REF);
		org.exist.xquery.parser.XQueryAST tmp17_AST = null;
		tmp17_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp17_AST);
		match(VARIABLE_BINDING);
		org.exist.xquery.parser.XQueryAST tmp18_AST = null;
		tmp18_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp18_AST);
		match(ELEMENT);
		org.exist.xquery.parser.XQueryAST tmp19_AST = null;
		tmp19_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp19_AST);
		match(ATTRIBUTE);
		org.exist.xquery.parser.XQueryAST tmp20_AST = null;
		tmp20_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp20_AST);
		match(ATTRIBUTE_CONTENT);
		org.exist.xquery.parser.XQueryAST tmp21_AST = null;
		tmp21_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp21_AST);
		match(TEXT);
		org.exist.xquery.parser.XQueryAST tmp22_AST = null;
		tmp22_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp22_AST);
		match(VERSION_DECL);
		org.exist.xquery.parser.XQueryAST tmp23_AST = null;
		tmp23_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp23_AST);
		match(NAMESPACE_DECL);
		org.exist.xquery.parser.XQueryAST tmp24_AST = null;
		tmp24_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp24_AST);
		match(DEF_NAMESPACE_DECL);
		org.exist.xquery.parser.XQueryAST tmp25_AST = null;
		tmp25_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp25_AST);
		match(DEF_COLLATION_DECL);
		org.exist.xquery.parser.XQueryAST tmp26_AST = null;
		tmp26_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp26_AST);
		match(DEF_FUNCTION_NS_DECL);
		org.exist.xquery.parser.XQueryAST tmp27_AST = null;
		tmp27_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp27_AST);
		match(CONTEXT_ITEM_DECL);
		org.exist.xquery.parser.XQueryAST tmp28_AST = null;
		tmp28_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp28_AST);
		match(ANNOT_DECL);
		org.exist.xquery.parser.XQueryAST tmp29_AST = null;
		tmp29_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp29_AST);
		match(GLOBAL_VAR);
		org.exist.xquery.parser.XQueryAST tmp30_AST = null;
		tmp30_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp30_AST);
		match(FUNCTION_DECL);
		org.exist.xquery.parser.XQueryAST tmp31_AST = null;
		tmp31_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp31_AST);
		match(INLINE_FUNCTION_DECL);
		org.exist.xquery.parser.XQueryAST tmp32_AST = null;
		tmp32_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp32_AST);
		match(FUNCTION_INLINE);
		org.exist.xquery.parser.XQueryAST tmp33_AST = null;
		tmp33_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp33_AST);
		match(FUNCTION_TEST);
		org.exist.xquery.parser.XQueryAST tmp34_AST = null;
		tmp34_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp34_AST);
		match(MAP);
		org.exist.xquery.parser.XQueryAST tmp35_AST = null;
		tmp35_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp35_AST);
		match(MAP_TEST);
		org.exist.xquery.parser.XQueryAST tmp36_AST = null;
		tmp36_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp36_AST);
		match(LOOKUP);
		org.exist.xquery.parser.XQueryAST tmp37_AST = null;
		tmp37_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp37_AST);
		match(ARRAY);
		org.exist.xquery.parser.XQueryAST tmp38_AST = null;
		tmp38_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp38_AST);
		match(ARRAY_TEST);
		org.exist.xquery.parser.XQueryAST tmp39_AST = null;
		tmp39_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp39_AST);
		match(PROLOG);
		org.exist.xquery.parser.XQueryAST tmp40_AST = null;
		tmp40_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp40_AST);
		match(OPTION);
		org.exist.xquery.parser.XQueryAST tmp41_AST = null;
		tmp41_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp41_AST);
		match(ATOMIC_TYPE);
		org.exist.xquery.parser.XQueryAST tmp42_AST = null;
		tmp42_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp42_AST);
		match(MODULE);
		org.exist.xquery.parser.XQueryAST tmp43_AST = null;
		tmp43_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp43_AST);
		match(ORDER_BY);
		org.exist.xquery.parser.XQueryAST tmp44_AST = null;
		tmp44_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp44_AST);
		match(GROUP_BY);
		org.exist.xquery.parser.XQueryAST tmp45_AST = null;
		tmp45_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp45_AST);
		match(POSITIONAL_VAR);
		org.exist.xquery.parser.XQueryAST tmp46_AST = null;
		tmp46_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp46_AST);
		match(CATCH_ERROR_CODE);
		org.exist.xquery.parser.XQueryAST tmp47_AST = null;
		tmp47_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp47_AST);
		match(CATCH_ERROR_DESC);
		org.exist.xquery.parser.XQueryAST tmp48_AST = null;
		tmp48_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp48_AST);
		match(CATCH_ERROR_VAL);
		org.exist.xquery.parser.XQueryAST tmp49_AST = null;
		tmp49_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp49_AST);
		match(MODULE_DECL);
		org.exist.xquery.parser.XQueryAST tmp50_AST = null;
		tmp50_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp50_AST);
		match(MODULE_IMPORT);
		org.exist.xquery.parser.XQueryAST tmp51_AST = null;
		tmp51_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp51_AST);
		match(SCHEMA_IMPORT);
		org.exist.xquery.parser.XQueryAST tmp52_AST = null;
		tmp52_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp52_AST);
		match(ATTRIBUTE_TEST);
		org.exist.xquery.parser.XQueryAST tmp53_AST = null;
		tmp53_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp53_AST);
		match(COMP_ELEM_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp54_AST = null;
		tmp54_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp54_AST);
		match(COMP_ATTR_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp55_AST = null;
		tmp55_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp55_AST);
		match(COMP_TEXT_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp56_AST = null;
		tmp56_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp56_AST);
		match(COMP_COMMENT_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp57_AST = null;
		tmp57_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp57_AST);
		match(COMP_PI_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp58_AST = null;
		tmp58_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp58_AST);
		match(COMP_NS_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp59_AST = null;
		tmp59_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp59_AST);
		match(COMP_DOC_CONSTRUCTOR);
		org.exist.xquery.parser.XQueryAST tmp60_AST = null;
		tmp60_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp60_AST);
		match(PRAGMA);
		org.exist.xquery.parser.XQueryAST tmp61_AST = null;
		tmp61_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp61_AST);
		match(GTEQ);
		org.exist.xquery.parser.XQueryAST tmp62_AST = null;
		tmp62_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp62_AST);
		match(SEQUENCE);
		imaginaryTokenDefinitions_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = imaginaryTokenDefinitions_AST;
	}
	
	public final void xpointer() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST xpointer_AST = null;
		org.exist.xquery.parser.XQueryAST ex_AST = null;
		Token  nc = null;
		org.exist.xquery.parser.XQueryAST nc_AST = null;
		
		switch ( LA(1)) {
		case LITERAL_xpointer:
		{
			org.exist.xquery.parser.XQueryAST tmp63_AST = null;
			tmp63_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp63_AST);
			match(LITERAL_xpointer);
			match(LPAREN);
			expr();
			ex_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			match(RPAREN);
			if ( inputState.guessing==0 ) {
				xpointer_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				xpointer_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(XPOINTER,"xpointer")).add(ex_AST));
				currentAST.root = xpointer_AST;
				currentAST.child = xpointer_AST!=null &&xpointer_AST.getFirstChild()!=null ?
					xpointer_AST.getFirstChild() : xpointer_AST;
				currentAST.advanceChildToEnd();
			}
			xpointer_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case NCNAME:
		{
			nc = LT(1);
			nc_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(nc);
			astFactory.addASTChild(currentAST, nc_AST);
			match(NCNAME);
			if ( inputState.guessing==0 ) {
				xpointer_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				xpointer_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(XPOINTER_ID,"id")).add(nc_AST));
				currentAST.root = xpointer_AST;
				currentAST.child = xpointer_AST!=null &&xpointer_AST.getFirstChild()!=null ?
					xpointer_AST.getFirstChild() : xpointer_AST;
				currentAST.advanceChildToEnd();
			}
			xpointer_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = xpointer_AST;
	}
	
	public final void expr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST expr_AST = null;
		boolean isSequence = false;
		
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop167:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				exprSingle();
				astFactory.addASTChild(currentAST, returnAST);
				if ( inputState.guessing==0 ) {
					isSequence = true;
				}
			}
			else {
				break _loop167;
			}
			
		} while (true);
		}
		if ( inputState.guessing==0 ) {
			expr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
			if (isSequence)
			expr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(SEQUENCE,"sequence")).add(expr_AST));
			
			currentAST.root = expr_AST;
			currentAST.child = expr_AST!=null &&expr_AST.getFirstChild()!=null ?
				expr_AST.getFirstChild() : expr_AST;
			currentAST.advanceChildToEnd();
		}
		expr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = expr_AST;
	}
	
/** top-rule */
	public final void xpath() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST xpath_AST = null;
		
		try {      // for error handling
			{
			if ((_tokenSet_0.member(LA(1)))) {
				module();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else if ((LA(1)==EOF)) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			org.exist.xquery.parser.XQueryAST tmp67_AST = null;
			tmp67_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp67_AST);
			match(Token.EOF_TYPE);
			xpath_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
				// TODO: WM: not sure if we need handleException anymore.
				// we could just throw the exception.
				handleException(
					        new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage())
				);
				
			} else {
				throw e;
			}
		}
		returnAST = xpath_AST;
	}
	
	public final void module() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST module_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		
		{
		boolean synPredMatched8 = false;
		if (((LA(1)==LITERAL_xquery))) {
			int _m8 = mark();
			synPredMatched8 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_xquery);
				match(LITERAL_version);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched8 = false;
			}
			rewind(_m8);
inputState.guessing--;
		}
		if ( synPredMatched8 ) {
			versionDecl();
			v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			match(SEMICOLON);
		}
		else if ((_tokenSet_0.member(LA(1)))) {
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		{
		boolean synPredMatched11 = false;
		if (((LA(1)==LITERAL_module))) {
			int _m11 = mark();
			synPredMatched11 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_module);
				match(LITERAL_namespace);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched11 = false;
			}
			rewind(_m11);
inputState.guessing--;
		}
		if ( synPredMatched11 ) {
			libraryModule();
			astFactory.addASTChild(currentAST, returnAST);
		}
		else if ((_tokenSet_0.member(LA(1)))) {
			mainModule();
			astFactory.addASTChild(currentAST, returnAST);
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		module_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = module_AST;
	}
	
	public final void versionDecl() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST versionDecl_AST = null;
		Token  v = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		Token  enc = null;
		org.exist.xquery.parser.XQueryAST enc_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp69_AST = null;
		tmp69_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp69_AST);
		match(LITERAL_xquery);
		org.exist.xquery.parser.XQueryAST tmp70_AST = null;
		tmp70_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp70_AST);
		match(LITERAL_version);
		v = LT(1);
		v_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(v);
		astFactory.addASTChild(currentAST, v_AST);
		match(STRING_LITERAL);
		{
		switch ( LA(1)) {
		case LITERAL_encoding:
		{
			match(LITERAL_encoding);
			enc = LT(1);
			enc_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(enc);
			astFactory.addASTChild(currentAST, enc_AST);
			match(STRING_LITERAL);
			break;
		}
		case SEMICOLON:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			versionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			versionDecl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VERSION_DECL,v.getText())).add(enc_AST));
			currentAST.root = versionDecl_AST;
			currentAST.child = versionDecl_AST!=null &&versionDecl_AST.getFirstChild()!=null ?
				versionDecl_AST.getFirstChild() : versionDecl_AST;
			currentAST.advanceChildToEnd();
		}
		versionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = versionDecl_AST;
	}
	
	public final void libraryModule() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST libraryModule_AST = null;
		
		moduleDecl();
		astFactory.addASTChild(currentAST, returnAST);
		prolog();
		astFactory.addASTChild(currentAST, returnAST);
		libraryModule_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = libraryModule_AST;
	}
	
	public final void mainModule() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mainModule_AST = null;
		
		prolog();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			queryBody();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		mainModule_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = mainModule_AST;
	}
	
	public final void prolog() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST prolog_AST = null;
		org.exist.xquery.parser.XQueryAST s_AST = null;
		boolean inSetters = true;
		
		{
		_loop32:
		do {
			if ((LA(1)==LITERAL_declare||LA(1)==LITERAL_import)) {
				{
				if ((LA(1)==LITERAL_import)) {
					importDecl();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					boolean synPredMatched21 = false;
					if (((LA(1)==LITERAL_declare))) {
						int _m21 = mark();
						synPredMatched21 = true;
						inputState.guessing++;
						try {
							{
							match(LITERAL_declare);
							{
							switch ( LA(1)) {
							case LITERAL_default:
							{
								match(LITERAL_default);
								break;
							}
							case 79:
							{
								match(79);
								break;
							}
							case LITERAL_ordering:
							{
								match(LITERAL_ordering);
								break;
							}
							case LITERAL_construction:
							{
								match(LITERAL_construction);
								break;
							}
							case 82:
							{
								match(82);
								break;
							}
							case 83:
							{
								match(83);
								break;
							}
							case LITERAL_namespace:
							{
								match(LITERAL_namespace);
								break;
							}
							default:
							{
								throw new NoViableAltException(LT(1), getFilename());
							}
							}
							}
							}
						}
						catch (RecognitionException pe) {
							synPredMatched21 = false;
						}
						rewind(_m21);
inputState.guessing--;
					}
					if ( synPredMatched21 ) {
						setter();
						s_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
						astFactory.addASTChild(currentAST, returnAST);
						if ( inputState.guessing==0 ) {
							
											if(!inSetters)
												throw new XPathException(s_AST, "Default declarations have to come first");
										
						}
					}
					else {
						boolean synPredMatched23 = false;
						if (((LA(1)==LITERAL_declare))) {
							int _m23 = mark();
							synPredMatched23 = true;
							inputState.guessing++;
							try {
								{
								match(LITERAL_declare);
								match(LITERAL_option);
								}
							}
							catch (RecognitionException pe) {
								synPredMatched23 = false;
							}
							rewind(_m23);
inputState.guessing--;
						}
						if ( synPredMatched23 ) {
							optionDecl();
							astFactory.addASTChild(currentAST, returnAST);
							if ( inputState.guessing==0 ) {
								inSetters = false;
							}
						}
						else {
							boolean synPredMatched25 = false;
							if (((LA(1)==LITERAL_declare))) {
								int _m25 = mark();
								synPredMatched25 = true;
								inputState.guessing++;
								try {
									{
									match(LITERAL_declare);
									match(LITERAL_function);
									}
								}
								catch (RecognitionException pe) {
									synPredMatched25 = false;
								}
								rewind(_m25);
inputState.guessing--;
							}
							if ( synPredMatched25 ) {
								functionDeclUp();
								astFactory.addASTChild(currentAST, returnAST);
								if ( inputState.guessing==0 ) {
									inSetters = false;
								}
							}
							else {
								boolean synPredMatched27 = false;
								if (((LA(1)==LITERAL_declare))) {
									int _m27 = mark();
									synPredMatched27 = true;
									inputState.guessing++;
									try {
										{
										match(LITERAL_declare);
										match(LITERAL_variable);
										}
									}
									catch (RecognitionException pe) {
										synPredMatched27 = false;
									}
									rewind(_m27);
inputState.guessing--;
								}
								if ( synPredMatched27 ) {
									varDeclUp();
									astFactory.addASTChild(currentAST, returnAST);
									if ( inputState.guessing==0 ) {
										inSetters = false;
									}
								}
								else {
									boolean synPredMatched29 = false;
									if (((LA(1)==LITERAL_declare))) {
										int _m29 = mark();
										synPredMatched29 = true;
										inputState.guessing++;
										try {
											{
											match(LITERAL_declare);
											match(LITERAL_context);
											match(LITERAL_item);
											}
										}
										catch (RecognitionException pe) {
											synPredMatched29 = false;
										}
										rewind(_m29);
inputState.guessing--;
									}
									if ( synPredMatched29 ) {
										contextItemDeclUp();
										astFactory.addASTChild(currentAST, returnAST);
										if ( inputState.guessing==0 ) {
											inSetters = false;
										}
									}
									else {
										boolean synPredMatched31 = false;
										if (((LA(1)==LITERAL_declare))) {
											int _m31 = mark();
											synPredMatched31 = true;
											inputState.guessing++;
											try {
												{
												match(LITERAL_declare);
												match(MOD);
												}
											}
											catch (RecognitionException pe) {
												synPredMatched31 = false;
											}
											rewind(_m31);
inputState.guessing--;
										}
										if ( synPredMatched31 ) {
											annotateDecl();
											astFactory.addASTChild(currentAST, returnAST);
											if ( inputState.guessing==0 ) {
												inSetters = false;
											}
										}
										else {
											throw new NoViableAltException(LT(1), getFilename());
										}
										}}}}}}
										}
										match(SEMICOLON);
									}
									else {
										break _loop32;
									}
									
								} while (true);
								}
								prolog_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
								returnAST = prolog_AST;
							}
							
	public final void queryBody() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST queryBody_AST = null;
		
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		queryBody_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = queryBody_AST;
	}
	
	public final void moduleDecl() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST moduleDecl_AST = null;
		Token  uri = null;
		org.exist.xquery.parser.XQueryAST uri_AST = null;
		String prefix = null;
		
		match(LITERAL_module);
		match(LITERAL_namespace);
		prefix=ncnameOrKeyword();
		astFactory.addASTChild(currentAST, returnAST);
		match(EQ);
		uri = LT(1);
		uri_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(uri);
		astFactory.addASTChild(currentAST, uri_AST);
		match(STRING_LITERAL);
		match(SEMICOLON);
		if ( inputState.guessing==0 ) {
			moduleDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					moduleDecl_AST =
						(org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(MODULE_DECL,prefix,org.exist.xquery.parser.XQueryFunctionAST.class.getName())).add(uri_AST));
					moduleDecl_AST.setDoc(getXQDoc());
				
			currentAST.root = moduleDecl_AST;
			currentAST.child = moduleDecl_AST!=null &&moduleDecl_AST.getFirstChild()!=null ?
				moduleDecl_AST.getFirstChild() : moduleDecl_AST;
			currentAST.advanceChildToEnd();
		}
		moduleDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = moduleDecl_AST;
	}
	
	public final String  ncnameOrKeyword() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST ncnameOrKeyword_AST = null;
		Token  n1 = null;
		org.exist.xquery.parser.XQueryAST n1_AST = null;
		name= null;
		
		switch ( LA(1)) {
		case NCNAME:
		{
			n1 = LT(1);
			n1_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(n1);
			astFactory.addASTChild(currentAST, n1_AST);
			match(NCNAME);
			if ( inputState.guessing==0 ) {
				
					    name= n1.getText();
				
			}
			ncnameOrKeyword_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_xpointer:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			name=reservedKeywords();
			astFactory.addASTChild(currentAST, returnAST);
			ncnameOrKeyword_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = ncnameOrKeyword_AST;
		return name;
	}
	
	public final void importDecl() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST importDecl_AST = null;
		
		boolean synPredMatched35 = false;
		if (((LA(1)==LITERAL_import))) {
			int _m35 = mark();
			synPredMatched35 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_import);
				match(LITERAL_module);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched35 = false;
			}
			rewind(_m35);
inputState.guessing--;
		}
		if ( synPredMatched35 ) {
			moduleImport();
			astFactory.addASTChild(currentAST, returnAST);
			importDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_import)) {
			schemaImport();
			astFactory.addASTChild(currentAST, returnAST);
			importDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = importDecl_AST;
	}
	
	public final void setter() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST setter_AST = null;
		Token  defc = null;
		org.exist.xquery.parser.XQueryAST defc_AST = null;
		Token  defu = null;
		org.exist.xquery.parser.XQueryAST defu_AST = null;
		Token  deff = null;
		org.exist.xquery.parser.XQueryAST deff_AST = null;
		
		{
		boolean synPredMatched41 = false;
		if (((LA(1)==LITERAL_declare))) {
			int _m41 = mark();
			synPredMatched41 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_declare);
				match(LITERAL_default);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched41 = false;
			}
			rewind(_m41);
inputState.guessing--;
		}
		if ( synPredMatched41 ) {
			match(LITERAL_declare);
			match(LITERAL_default);
			{
			switch ( LA(1)) {
			case LITERAL_collation:
			{
				match(LITERAL_collation);
				defc = LT(1);
				defc_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(defc);
				astFactory.addASTChild(currentAST, defc_AST);
				match(STRING_LITERAL);
				if ( inputState.guessing==0 ) {
					setter_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					setter_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(DEF_COLLATION_DECL,"defaultCollationDecl")).add(defc_AST));
					currentAST.root = setter_AST;
					currentAST.child = setter_AST!=null &&setter_AST.getFirstChild()!=null ?
						setter_AST.getFirstChild() : setter_AST;
					currentAST.advanceChildToEnd();
				}
				break;
			}
			case LITERAL_element:
			{
				match(LITERAL_element);
				match(LITERAL_namespace);
				defu = LT(1);
				defu_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(defu);
				astFactory.addASTChild(currentAST, defu_AST);
				match(STRING_LITERAL);
				if ( inputState.guessing==0 ) {
					setter_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					setter_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(DEF_NAMESPACE_DECL,"defaultNamespaceDecl")).add(defu_AST));
					currentAST.root = setter_AST;
					currentAST.child = setter_AST!=null &&setter_AST.getFirstChild()!=null ?
						setter_AST.getFirstChild() : setter_AST;
					currentAST.advanceChildToEnd();
				}
				break;
			}
			case LITERAL_function:
			{
				match(LITERAL_function);
				match(LITERAL_namespace);
				deff = LT(1);
				deff_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(deff);
				astFactory.addASTChild(currentAST, deff_AST);
				match(STRING_LITERAL);
				if ( inputState.guessing==0 ) {
					setter_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					setter_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(DEF_FUNCTION_NS_DECL,"defaultFunctionNSDecl")).add(deff_AST));
					currentAST.root = setter_AST;
					currentAST.child = setter_AST!=null &&setter_AST.getFirstChild()!=null ?
						setter_AST.getFirstChild() : setter_AST;
					currentAST.advanceChildToEnd();
				}
				break;
			}
			case LITERAL_order:
			{
				org.exist.xquery.parser.XQueryAST tmp84_AST = null;
				tmp84_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp84_AST);
				match(LITERAL_order);
				match(LITERAL_empty);
				{
				switch ( LA(1)) {
				case LITERAL_greatest:
				{
					org.exist.xquery.parser.XQueryAST tmp86_AST = null;
					tmp86_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp86_AST);
					match(LITERAL_greatest);
					break;
				}
				case LITERAL_least:
				{
					org.exist.xquery.parser.XQueryAST tmp87_AST = null;
					tmp87_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp87_AST);
					match(LITERAL_least);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
		}
		else {
			boolean synPredMatched45 = false;
			if (((LA(1)==LITERAL_declare))) {
				int _m45 = mark();
				synPredMatched45 = true;
				inputState.guessing++;
				try {
					{
					match(LITERAL_declare);
					match(79);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched45 = false;
				}
				rewind(_m45);
inputState.guessing--;
			}
			if ( synPredMatched45 ) {
				match(LITERAL_declare);
				org.exist.xquery.parser.XQueryAST tmp89_AST = null;
				tmp89_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp89_AST);
				match(79);
				{
				switch ( LA(1)) {
				case LITERAL_preserve:
				{
					org.exist.xquery.parser.XQueryAST tmp90_AST = null;
					tmp90_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp90_AST);
					match(LITERAL_preserve);
					break;
				}
				case LITERAL_strip:
				{
					org.exist.xquery.parser.XQueryAST tmp91_AST = null;
					tmp91_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp91_AST);
					match(LITERAL_strip);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
			}
			else {
				boolean synPredMatched48 = false;
				if (((LA(1)==LITERAL_declare))) {
					int _m48 = mark();
					synPredMatched48 = true;
					inputState.guessing++;
					try {
						{
						match(LITERAL_declare);
						match(82);
						}
					}
					catch (RecognitionException pe) {
						synPredMatched48 = false;
					}
					rewind(_m48);
inputState.guessing--;
				}
				if ( synPredMatched48 ) {
					match(LITERAL_declare);
					org.exist.xquery.parser.XQueryAST tmp93_AST = null;
					tmp93_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp93_AST);
					match(82);
					org.exist.xquery.parser.XQueryAST tmp94_AST = null;
					tmp94_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp94_AST);
					match(STRING_LITERAL);
				}
				else {
					boolean synPredMatched50 = false;
					if (((LA(1)==LITERAL_declare))) {
						int _m50 = mark();
						synPredMatched50 = true;
						inputState.guessing++;
						try {
							{
							match(LITERAL_declare);
							match(LITERAL_ordering);
							}
						}
						catch (RecognitionException pe) {
							synPredMatched50 = false;
						}
						rewind(_m50);
inputState.guessing--;
					}
					if ( synPredMatched50 ) {
						match(LITERAL_declare);
						org.exist.xquery.parser.XQueryAST tmp96_AST = null;
						tmp96_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
						astFactory.makeASTRoot(currentAST, tmp96_AST);
						match(LITERAL_ordering);
						{
						switch ( LA(1)) {
						case LITERAL_ordered:
						{
							org.exist.xquery.parser.XQueryAST tmp97_AST = null;
							tmp97_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
							astFactory.addASTChild(currentAST, tmp97_AST);
							match(LITERAL_ordered);
							break;
						}
						case LITERAL_unordered:
						{
							org.exist.xquery.parser.XQueryAST tmp98_AST = null;
							tmp98_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
							astFactory.addASTChild(currentAST, tmp98_AST);
							match(LITERAL_unordered);
							break;
						}
						default:
						{
							throw new NoViableAltException(LT(1), getFilename());
						}
						}
						}
					}
					else {
						boolean synPredMatched53 = false;
						if (((LA(1)==LITERAL_declare))) {
							int _m53 = mark();
							synPredMatched53 = true;
							inputState.guessing++;
							try {
								{
								match(LITERAL_declare);
								match(LITERAL_construction);
								}
							}
							catch (RecognitionException pe) {
								synPredMatched53 = false;
							}
							rewind(_m53);
inputState.guessing--;
						}
						if ( synPredMatched53 ) {
							match(LITERAL_declare);
							org.exist.xquery.parser.XQueryAST tmp100_AST = null;
							tmp100_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
							astFactory.makeASTRoot(currentAST, tmp100_AST);
							match(LITERAL_construction);
							{
							switch ( LA(1)) {
							case LITERAL_preserve:
							{
								org.exist.xquery.parser.XQueryAST tmp101_AST = null;
								tmp101_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
								astFactory.addASTChild(currentAST, tmp101_AST);
								match(LITERAL_preserve);
								break;
							}
							case LITERAL_strip:
							{
								org.exist.xquery.parser.XQueryAST tmp102_AST = null;
								tmp102_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
								astFactory.addASTChild(currentAST, tmp102_AST);
								match(LITERAL_strip);
								break;
							}
							default:
							{
								throw new NoViableAltException(LT(1), getFilename());
							}
							}
							}
						}
						else {
							boolean synPredMatched56 = false;
							if (((LA(1)==LITERAL_declare))) {
								int _m56 = mark();
								synPredMatched56 = true;
								inputState.guessing++;
								try {
									{
									match(LITERAL_declare);
									match(83);
									}
								}
								catch (RecognitionException pe) {
									synPredMatched56 = false;
								}
								rewind(_m56);
inputState.guessing--;
							}
							if ( synPredMatched56 ) {
								match(LITERAL_declare);
								org.exist.xquery.parser.XQueryAST tmp104_AST = null;
								tmp104_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
								astFactory.makeASTRoot(currentAST, tmp104_AST);
								match(83);
								preserveMode();
								astFactory.addASTChild(currentAST, returnAST);
								match(COMMA);
								inheritMode();
								astFactory.addASTChild(currentAST, returnAST);
							}
							else {
								boolean synPredMatched58 = false;
								if (((LA(1)==LITERAL_declare))) {
									int _m58 = mark();
									synPredMatched58 = true;
									inputState.guessing++;
									try {
										{
										match(LITERAL_declare);
										match(LITERAL_namespace);
										}
									}
									catch (RecognitionException pe) {
										synPredMatched58 = false;
									}
									rewind(_m58);
inputState.guessing--;
								}
								if ( synPredMatched58 ) {
									namespaceDecl();
									astFactory.addASTChild(currentAST, returnAST);
								}
								else {
									throw new NoViableAltException(LT(1), getFilename());
								}
								}}}}}}
								}
								setter_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
								returnAST = setter_AST;
							}
							
	public final void optionDecl() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST optionDecl_AST = null;
		Token  decl = null;
		org.exist.xquery.parser.XQueryAST decl_AST = null;
		Token  opt = null;
		org.exist.xquery.parser.XQueryAST opt_AST = null;
		String eq = null;
		
		decl = LT(1);
		decl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(decl);
		match(LITERAL_declare);
		opt = LT(1);
		opt_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(opt);
		match(LITERAL_option);
		eq=eqName();
		org.exist.xquery.parser.XQueryAST tmp106_AST = null;
		tmp106_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp106_AST);
		match(STRING_LITERAL);
		if ( inputState.guessing==0 ) {
			optionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					optionDecl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(OPTION,eq)).add(optionDecl_AST));
					optionDecl_AST.copyLexInfo(decl_AST);
				
			currentAST.root = optionDecl_AST;
			currentAST.child = optionDecl_AST!=null &&optionDecl_AST.getFirstChild()!=null ?
				optionDecl_AST.getFirstChild() : optionDecl_AST;
			currentAST.advanceChildToEnd();
		}
		optionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = optionDecl_AST;
	}
	
	public final void functionDeclUp() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionDeclUp_AST = null;
		org.exist.xquery.parser.XQueryAST f_AST = null;
		
		match(LITERAL_declare);
		functionDecl(null);
		f_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		if ( inputState.guessing==0 ) {
			functionDeclUp_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			functionDeclUp_AST = f_AST;
			currentAST.root = functionDeclUp_AST;
			currentAST.child = functionDeclUp_AST!=null &&functionDeclUp_AST.getFirstChild()!=null ?
				functionDeclUp_AST.getFirstChild() : functionDeclUp_AST;
			currentAST.advanceChildToEnd();
		}
		returnAST = functionDeclUp_AST;
	}
	
	public final void varDeclUp() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST varDeclUp_AST = null;
		Token  decl = null;
		org.exist.xquery.parser.XQueryAST decl_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		
		decl = LT(1);
		decl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(decl);
		match(LITERAL_declare);
		varDecl(decl_AST, null);
		v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		if ( inputState.guessing==0 ) {
			varDeclUp_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			varDeclUp_AST = v_AST;
			currentAST.root = varDeclUp_AST;
			currentAST.child = varDeclUp_AST!=null &&varDeclUp_AST.getFirstChild()!=null ?
				varDeclUp_AST.getFirstChild() : varDeclUp_AST;
			currentAST.advanceChildToEnd();
		}
		returnAST = varDeclUp_AST;
	}
	
	public final void contextItemDeclUp() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST contextItemDeclUp_AST = null;
		Token  decl = null;
		org.exist.xquery.parser.XQueryAST decl_AST = null;
		org.exist.xquery.parser.XQueryAST c_AST = null;
		
		decl = LT(1);
		decl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(decl);
		match(LITERAL_declare);
		contextItemDecl(decl_AST);
		c_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		if ( inputState.guessing==0 ) {
			contextItemDeclUp_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			contextItemDeclUp_AST = c_AST;
			currentAST.root = contextItemDeclUp_AST;
			currentAST.child = contextItemDeclUp_AST!=null &&contextItemDeclUp_AST.getFirstChild()!=null ?
				contextItemDeclUp_AST.getFirstChild() : contextItemDeclUp_AST;
			currentAST.advanceChildToEnd();
		}
		returnAST = contextItemDeclUp_AST;
	}
	
	public final void annotateDecl() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST annotateDecl_AST = null;
		Token  decl = null;
		org.exist.xquery.parser.XQueryAST decl_AST = null;
		org.exist.xquery.parser.XQueryAST ann_AST = null;
		org.exist.xquery.parser.XQueryAST f_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		
		decl = LT(1);
		decl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(decl);
		match(LITERAL_declare);
		annotations();
		ann_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		{
		switch ( LA(1)) {
		case LITERAL_function:
		{
			functionDecl(ann_AST);
			f_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			if ( inputState.guessing==0 ) {
				annotateDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				annotateDecl_AST = f_AST;
				currentAST.root = annotateDecl_AST;
				currentAST.child = annotateDecl_AST!=null &&annotateDecl_AST.getFirstChild()!=null ?
					annotateDecl_AST.getFirstChild() : annotateDecl_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		case LITERAL_variable:
		{
			varDecl(decl_AST, ann_AST);
			v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			if ( inputState.guessing==0 ) {
				annotateDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				annotateDecl_AST = v_AST;
				currentAST.root = annotateDecl_AST;
				currentAST.child = annotateDecl_AST!=null &&annotateDecl_AST.getFirstChild()!=null ?
					annotateDecl_AST.getFirstChild() : annotateDecl_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		returnAST = annotateDecl_AST;
	}
	
	public final void moduleImport() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST moduleImport_AST = null;
		Token  i = null;
		org.exist.xquery.parser.XQueryAST i_AST = null;
		
		i = LT(1);
		i_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(i);
		match(LITERAL_import);
		match(LITERAL_module);
		{
		switch ( LA(1)) {
		case LITERAL_namespace:
		{
			moduleNamespace();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case STRING_LITERAL:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		org.exist.xquery.parser.XQueryAST tmp109_AST = null;
		tmp109_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp109_AST);
		match(STRING_LITERAL);
		{
		switch ( LA(1)) {
		case LITERAL_at:
		{
			uriList();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case SEMICOLON:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			moduleImport_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					moduleImport_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(MODULE_IMPORT,"module")).add(moduleImport_AST));
					moduleImport_AST.copyLexInfo(i_AST);
				
			currentAST.root = moduleImport_AST;
			currentAST.child = moduleImport_AST!=null &&moduleImport_AST.getFirstChild()!=null ?
				moduleImport_AST.getFirstChild() : moduleImport_AST;
			currentAST.advanceChildToEnd();
		}
		moduleImport_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = moduleImport_AST;
	}
	
	public final void schemaImport() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST schemaImport_AST = null;
		Token  i = null;
		org.exist.xquery.parser.XQueryAST i_AST = null;
		String prefix = null;
		
		i = LT(1);
		i_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(i);
		match(LITERAL_import);
		match(LITERAL_schema);
		{
		switch ( LA(1)) {
		case LITERAL_namespace:
		case LITERAL_default:
		{
			schemaPrefix();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case STRING_LITERAL:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		org.exist.xquery.parser.XQueryAST tmp111_AST = null;
		tmp111_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp111_AST);
		match(STRING_LITERAL);
		{
		switch ( LA(1)) {
		case LITERAL_at:
		{
			uriList();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case SEMICOLON:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			schemaImport_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					schemaImport_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(SCHEMA_IMPORT,"schema")).add(schemaImport_AST));
					schemaImport_AST.copyLexInfo(i_AST);
				
			currentAST.root = schemaImport_AST;
			currentAST.child = schemaImport_AST!=null &&schemaImport_AST.getFirstChild()!=null ?
				schemaImport_AST.getFirstChild() : schemaImport_AST;
			currentAST.advanceChildToEnd();
		}
		schemaImport_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = schemaImport_AST;
	}
	
	public final void preserveMode() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST preserveMode_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_preserve:
		{
			org.exist.xquery.parser.XQueryAST tmp112_AST = null;
			tmp112_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp112_AST);
			match(LITERAL_preserve);
			break;
		}
		case 103:
		{
			org.exist.xquery.parser.XQueryAST tmp113_AST = null;
			tmp113_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp113_AST);
			match(103);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		preserveMode_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = preserveMode_AST;
	}
	
	public final void inheritMode() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST inheritMode_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_inherit:
		{
			org.exist.xquery.parser.XQueryAST tmp114_AST = null;
			tmp114_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp114_AST);
			match(LITERAL_inherit);
			break;
		}
		case 105:
		{
			org.exist.xquery.parser.XQueryAST tmp115_AST = null;
			tmp115_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp115_AST);
			match(105);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		inheritMode_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = inheritMode_AST;
	}
	
	public final void namespaceDecl() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST namespaceDecl_AST = null;
		Token  decl = null;
		org.exist.xquery.parser.XQueryAST decl_AST = null;
		Token  uri = null;
		org.exist.xquery.parser.XQueryAST uri_AST = null;
		String prefix = null;
		
		decl = LT(1);
		decl_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(decl);
		astFactory.addASTChild(currentAST, decl_AST);
		match(LITERAL_declare);
		org.exist.xquery.parser.XQueryAST tmp116_AST = null;
		tmp116_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp116_AST);
		match(LITERAL_namespace);
		prefix=ncnameOrKeyword();
		astFactory.addASTChild(currentAST, returnAST);
		match(EQ);
		uri = LT(1);
		uri_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(uri);
		astFactory.addASTChild(currentAST, uri_AST);
		match(STRING_LITERAL);
		if ( inputState.guessing==0 ) {
			namespaceDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					namespaceDecl_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(NAMESPACE_DECL,prefix)).add(uri_AST));
					namespaceDecl_AST.copyLexInfo(decl_AST);
				
			currentAST.root = namespaceDecl_AST;
			currentAST.child = namespaceDecl_AST!=null &&namespaceDecl_AST.getFirstChild()!=null ?
				namespaceDecl_AST.getFirstChild() : namespaceDecl_AST;
			currentAST.advanceChildToEnd();
		}
		namespaceDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = namespaceDecl_AST;
	}
	
	public final void varDecl(
		XQueryAST decl, XQueryAST ann
	) throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST varDecl_AST = null;
		org.exist.xquery.parser.XQueryAST e3_AST = null;
		org.exist.xquery.parser.XQueryAST e1_AST = null;
		org.exist.xquery.parser.XQueryAST e2_AST = null;
		String varName= null;
		
		match(LITERAL_variable);
		match(DOLLAR);
		varName=varName();
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_external:
		case COLON:
		case LCURLY:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_external:
		{
			org.exist.xquery.parser.XQueryAST tmp120_AST = null;
			tmp120_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp120_AST);
			match(LITERAL_external);
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				match(EQ);
				expr();
				e3_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case SEMICOLON:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		case LCURLY:
		{
			match(LCURLY);
			expr();
			e1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			match(RCURLY);
			break;
		}
		case COLON:
		{
			match(COLON);
			match(EQ);
			expr();
			e2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			varDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					varDecl_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(GLOBAL_VAR,varName)).add(ann).add(varDecl_AST));
					varDecl_AST.copyLexInfo(decl);
				
			currentAST.root = varDecl_AST;
			currentAST.child = varDecl_AST!=null &&varDecl_AST.getFirstChild()!=null ?
				varDecl_AST.getFirstChild() : varDecl_AST;
			currentAST.advanceChildToEnd();
		}
		varDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = varDecl_AST;
	}
	
	public final String  varName() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST varName_AST = null;
		org.exist.xquery.parser.XQueryAST eq_AST = null;
		
		{
		name=eqName();
		eq_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		}
		if ( inputState.guessing==0 ) {
			varName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			varName_AST.copyLexInfo(eq_AST);
		}
		varName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = varName_AST;
		return name;
	}
	
	public final String  eqName() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST eqName_AST = null;
		
			name= null;
		
		
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			name=qName();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case BRACED_URI_LITERAL:
		{
			name=uriQualifiedName();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		eqName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = eqName_AST;
		return name;
	}
	
	public final void typeDeclaration() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST typeDeclaration_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp127_AST = null;
		tmp127_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp127_AST);
		match(LITERAL_as);
		sequenceType();
		astFactory.addASTChild(currentAST, returnAST);
		typeDeclaration_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = typeDeclaration_AST;
	}
	
	public final void moduleNamespace() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST moduleNamespace_AST = null;
		String prefix = null;
		
		match(LITERAL_namespace);
		prefix=ncnameOrKeyword();
		astFactory.addASTChild(currentAST, returnAST);
		match(EQ);
		if ( inputState.guessing==0 ) {
			moduleNamespace_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			moduleNamespace_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(NCNAME,prefix);
			currentAST.root = moduleNamespace_AST;
			currentAST.child = moduleNamespace_AST!=null &&moduleNamespace_AST.getFirstChild()!=null ?
				moduleNamespace_AST.getFirstChild() : moduleNamespace_AST;
			currentAST.advanceChildToEnd();
		}
		moduleNamespace_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = moduleNamespace_AST;
	}
	
	public final void uriList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST uriList_AST = null;
		
		match(LITERAL_at);
		uri();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop117:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				uri();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop117;
			}
			
		} while (true);
		}
		uriList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = uriList_AST;
	}
	
	public final void schemaPrefix() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST schemaPrefix_AST = null;
		String prefix = null;
		
		switch ( LA(1)) {
		case LITERAL_namespace:
		{
			match(LITERAL_namespace);
			prefix=ncnameOrKeyword();
			astFactory.addASTChild(currentAST, returnAST);
			match(EQ);
			if ( inputState.guessing==0 ) {
				schemaPrefix_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				schemaPrefix_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(NCNAME,prefix);
				currentAST.root = schemaPrefix_AST;
				currentAST.child = schemaPrefix_AST!=null &&schemaPrefix_AST.getFirstChild()!=null ?
					schemaPrefix_AST.getFirstChild() : schemaPrefix_AST;
				currentAST.advanceChildToEnd();
			}
			schemaPrefix_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_default:
		{
			org.exist.xquery.parser.XQueryAST tmp134_AST = null;
			tmp134_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp134_AST);
			match(LITERAL_default);
			org.exist.xquery.parser.XQueryAST tmp135_AST = null;
			tmp135_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp135_AST);
			match(LITERAL_element);
			org.exist.xquery.parser.XQueryAST tmp136_AST = null;
			tmp136_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp136_AST);
			match(LITERAL_namespace);
			schemaPrefix_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = schemaPrefix_AST;
	}
	
	public final void annotations() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST annotations_AST = null;
		
		{
		_loop93:
		do {
			if ((LA(1)==MOD)) {
				annotation();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop93;
			}
			
		} while (true);
		}
		annotations_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = annotations_AST;
	}
	
	public final void functionDecl(
		XQueryAST ann
	) throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionDecl_AST = null;
		Token  lp = null;
		org.exist.xquery.parser.XQueryAST lp_AST = null;
		String name= null;
		
		try {      // for error handling
			match(LITERAL_function);
			name=eqName();
			lp = LT(1);
			lp_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(lp);
			match(LPAREN);
			{
			switch ( LA(1)) {
			case DOLLAR:
			{
				paramList();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RPAREN);
			{
			switch ( LA(1)) {
			case LITERAL_as:
			{
				returnType();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case LITERAL_external:
			case LCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			{
			switch ( LA(1)) {
			case LCURLY:
			{
				functionBody();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case LITERAL_external:
			{
				org.exist.xquery.parser.XQueryAST tmp139_AST = null;
				tmp139_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp139_AST);
				match(LITERAL_external);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			if ( inputState.guessing==0 ) {
				functionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					  	functionDecl_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(FUNCTION_DECL,name,org.exist.xquery.parser.XQueryFunctionAST.class.getName())).add(ann).add(functionDecl_AST));
						functionDecl_AST.copyLexInfo(lp_AST);
						functionDecl_AST.setDoc(getXQDoc());
					
				currentAST.root = functionDecl_AST;
				currentAST.child = functionDecl_AST!=null &&functionDecl_AST.getFirstChild()!=null ?
					functionDecl_AST.getFirstChild() : functionDecl_AST;
				currentAST.advanceChildToEnd();
			}
			functionDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
						if (lp_AST == null) {
							throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, "Syntax error within user defined function " +
								name + ": " + e.getMessage());
						} else {
							lp_AST.setLine(e.getLine());
							lp_AST.setColumn(e.getColumn());
							throw new XPathException(lp_AST, ErrorCodes.XPST0003, "Syntax error within user defined function " +
								name + ": " + e.getMessage());
						}
					
			} else {
				throw e;
			}
		}
		returnAST = functionDecl_AST;
	}
	
	public final void contextItemDecl(
		XQueryAST decl
	) throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST contextItemDecl_AST = null;
		org.exist.xquery.parser.XQueryAST e1_AST = null;
		org.exist.xquery.parser.XQueryAST e2_AST = null;
		
		match(LITERAL_context);
		match(LITERAL_item);
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_external:
		case COLON:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case COLON:
		{
			match(COLON);
			match(EQ);
			expr();
			e1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_external:
		{
			org.exist.xquery.parser.XQueryAST tmp144_AST = null;
			tmp144_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp144_AST);
			match(LITERAL_external);
			{
			switch ( LA(1)) {
			case COLON:
			{
				match(COLON);
				match(EQ);
				expr();
				e2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case SEMICOLON:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			contextItemDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
			contextItemDecl_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(CONTEXT_ITEM_DECL,"context item")).add(contextItemDecl_AST));
			contextItemDecl_AST.copyLexInfo(decl);
			
			currentAST.root = contextItemDecl_AST;
			currentAST.child = contextItemDecl_AST!=null &&contextItemDecl_AST.getFirstChild()!=null ?
				contextItemDecl_AST.getFirstChild() : contextItemDecl_AST;
			currentAST.advanceChildToEnd();
		}
		contextItemDecl_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = contextItemDecl_AST;
	}
	
	public final void annotation() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST annotation_AST = null;
		
			String name= null;
		
		
		match(MOD);
		name=eqName();
		{
		switch ( LA(1)) {
		case LPAREN:
		{
			match(LPAREN);
			literal();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop97:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					literal();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop97;
				}
				
			} while (true);
			}
			match(RPAREN);
			break;
		}
		case LITERAL_function:
		case LITERAL_variable:
		case MOD:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			annotation_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			annotation_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ANNOT_DECL,name)).add(annotation_AST));
			currentAST.root = annotation_AST;
			currentAST.child = annotation_AST!=null &&annotation_AST.getFirstChild()!=null ?
				annotation_AST.getFirstChild() : annotation_AST;
			currentAST.advanceChildToEnd();
		}
		annotation_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = annotation_AST;
	}
	
	public final void literal() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST literal_AST = null;
		
		switch ( LA(1)) {
		case STRING_LITERAL:
		{
			org.exist.xquery.parser.XQueryAST tmp151_AST = null;
			tmp151_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp151_AST);
			match(STRING_LITERAL);
			literal_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		{
			numericLiteral();
			astFactory.addASTChild(currentAST, returnAST);
			literal_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = literal_AST;
	}
	
	public final String  qName() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST qName_AST = null;
		Token  n = null;
		org.exist.xquery.parser.XQueryAST n_AST = null;
		
			name= null;
			String name2;
		
		
		switch ( LA(1)) {
		case QNAME:
		{
			n = LT(1);
			n_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(n);
			astFactory.addASTChild(currentAST, n_AST);
			match(QNAME);
			if ( inputState.guessing==0 ) {
				
					    name = n.getText();
				
			}
			qName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			name=ncnameOrKeyword();
			astFactory.addASTChild(currentAST, returnAST);
			qName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = qName_AST;
		return name;
	}
	
	public final String  uriQualifiedName() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST uriQualifiedName_AST = null;
		
		name = null;
		String uri;
		
		
		{
		uri=bracedUriLiteral();
		astFactory.addASTChild(currentAST, returnAST);
		name=ncnameOrKeyword();
		astFactory.addASTChild(currentAST, returnAST);
		}
		if ( inputState.guessing==0 ) {
			name = "{" + uri + "}" + name;
		}
		uriQualifiedName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = uriQualifiedName_AST;
		return name;
	}
	
	public final String  bracedUriLiteral() throws RecognitionException, TokenStreamException {
		String uri;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST bracedUriLiteral_AST = null;
		Token  lit = null;
		org.exist.xquery.parser.XQueryAST lit_AST = null;
		
		uri= null;
		
		
		lit = LT(1);
		lit_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(lit);
		astFactory.addASTChild(currentAST, lit_AST);
		match(BRACED_URI_LITERAL);
		if ( inputState.guessing==0 ) {
			uri = lit.getText();
		}
		bracedUriLiteral_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = bracedUriLiteral_AST;
		return uri;
	}
	
	public final void paramList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST paramList_AST = null;
		org.exist.xquery.parser.XQueryAST p1_AST = null;
		
		param();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop112:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				param();
				p1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop112;
			}
			
		} while (true);
		}
		paramList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = paramList_AST;
	}
	
	public final void returnType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST returnType_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp153_AST = null;
		tmp153_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp153_AST);
		match(LITERAL_as);
		sequenceType();
		astFactory.addASTChild(currentAST, returnAST);
		returnType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = returnType_AST;
	}
	
	public final void functionBody() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionBody_AST = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp154_AST = null;
		tmp154_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp154_AST);
		match(LCURLY);
		expr();
		e_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		functionBody_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = functionBody_AST;
	}
	
	public final void sequenceType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST sequenceType_AST = null;
		
		switch ( LA(1)) {
		case 115:
		{
			org.exist.xquery.parser.XQueryAST tmp156_AST = null;
			tmp156_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp156_AST);
			match(115);
			match(LPAREN);
			match(RPAREN);
			sequenceType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			itemType();
			astFactory.addASTChild(currentAST, returnAST);
			{
			if (((LA(1) >= QUESTION && LA(1) <= PLUS))) {
				occurrenceIndicator();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else if ((_tokenSet_1.member(LA(1)))) {
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			
			}
			sequenceType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = sequenceType_AST;
	}
	
	public final void param() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST param_AST = null;
		org.exist.xquery.parser.XQueryAST t_AST = null;
		String varName= null;
		
		match(DOLLAR);
		varName=eqName();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			t_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case RPAREN:
		case COMMA:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			param_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			param_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName)).add(t_AST));
			currentAST.root = param_AST;
			currentAST.child = param_AST!=null &&param_AST.getFirstChild()!=null ?
				param_AST.getFirstChild() : param_AST;
			currentAST.advanceChildToEnd();
		}
		param_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = param_AST;
	}
	
	public final void uri() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST uri_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp160_AST = null;
		tmp160_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp160_AST);
		match(STRING_LITERAL);
		uri_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = uri_AST;
	}
	
	public final void itemType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST itemType_AST = null;
		
		boolean synPredMatched128 = false;
		if (((LA(1)==LITERAL_item))) {
			int _m128 = mark();
			synPredMatched128 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_item);
				match(LPAREN);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched128 = false;
			}
			rewind(_m128);
inputState.guessing--;
		}
		if ( synPredMatched128 ) {
			org.exist.xquery.parser.XQueryAST tmp161_AST = null;
			tmp161_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp161_AST);
			match(LITERAL_item);
			match(LPAREN);
			match(RPAREN);
			itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			boolean synPredMatched130 = false;
			if (((LA(1)==LITERAL_function))) {
				int _m130 = mark();
				synPredMatched130 = true;
				inputState.guessing++;
				try {
					{
					match(LITERAL_function);
					match(LPAREN);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched130 = false;
				}
				rewind(_m130);
inputState.guessing--;
			}
			if ( synPredMatched130 ) {
				functionTest();
				astFactory.addASTChild(currentAST, returnAST);
				itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else {
				boolean synPredMatched132 = false;
				if (((LA(1)==LITERAL_map))) {
					int _m132 = mark();
					synPredMatched132 = true;
					inputState.guessing++;
					try {
						{
						match(LITERAL_map);
						match(LPAREN);
						}
					}
					catch (RecognitionException pe) {
						synPredMatched132 = false;
					}
					rewind(_m132);
inputState.guessing--;
				}
				if ( synPredMatched132 ) {
					mapType();
					astFactory.addASTChild(currentAST, returnAST);
					itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				}
				else {
					boolean synPredMatched134 = false;
					if (((LA(1)==LITERAL_array))) {
						int _m134 = mark();
						synPredMatched134 = true;
						inputState.guessing++;
						try {
							{
							match(LITERAL_array);
							match(LPAREN);
							}
						}
						catch (RecognitionException pe) {
							synPredMatched134 = false;
						}
						rewind(_m134);
inputState.guessing--;
					}
					if ( synPredMatched134 ) {
						arrayType();
						astFactory.addASTChild(currentAST, returnAST);
						itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					}
					else {
						boolean synPredMatched136 = false;
						if (((LA(1)==LPAREN))) {
							int _m136 = mark();
							synPredMatched136 = true;
							inputState.guessing++;
							try {
								{
								match(LPAREN);
								}
							}
							catch (RecognitionException pe) {
								synPredMatched136 = false;
							}
							rewind(_m136);
inputState.guessing--;
						}
						if ( synPredMatched136 ) {
							parenthesizedItemType();
							astFactory.addASTChild(currentAST, returnAST);
							itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
						}
						else {
							boolean synPredMatched138 = false;
							if (((_tokenSet_2.member(LA(1))))) {
								int _m138 = mark();
								synPredMatched138 = true;
								inputState.guessing++;
								try {
									{
									matchNot(EOF);
									match(LPAREN);
									}
								}
								catch (RecognitionException pe) {
									synPredMatched138 = false;
								}
								rewind(_m138);
inputState.guessing--;
							}
							if ( synPredMatched138 ) {
								kindTest();
								astFactory.addASTChild(currentAST, returnAST);
								itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
							}
							else if ((_tokenSet_3.member(LA(1)))) {
								atomicType();
								astFactory.addASTChild(currentAST, returnAST);
								itemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
							}
							else {
								throw new NoViableAltException(LT(1), getFilename());
							}
							}}}}}
							returnAST = itemType_AST;
						}
						
	public final void occurrenceIndicator() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST occurrenceIndicator_AST = null;
		
		{
		switch ( LA(1)) {
		case QUESTION:
		{
			org.exist.xquery.parser.XQueryAST tmp164_AST = null;
			tmp164_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp164_AST);
			match(QUESTION);
			break;
		}
		case STAR:
		{
			org.exist.xquery.parser.XQueryAST tmp165_AST = null;
			tmp165_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp165_AST);
			match(STAR);
			break;
		}
		case PLUS:
		{
			org.exist.xquery.parser.XQueryAST tmp166_AST = null;
			tmp166_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp166_AST);
			match(PLUS);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		occurrenceIndicator_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = occurrenceIndicator_AST;
	}
	
	public final void functionTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionTest_AST = null;
		
		boolean synPredMatched145 = false;
		if (((LA(1)==LITERAL_function))) {
			int _m145 = mark();
			synPredMatched145 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_function);
				match(LPAREN);
				match(STAR);
				match(RPAREN);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched145 = false;
			}
			rewind(_m145);
inputState.guessing--;
		}
		if ( synPredMatched145 ) {
			anyFunctionTest();
			astFactory.addASTChild(currentAST, returnAST);
			functionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_function)) {
			typedFunctionTest();
			astFactory.addASTChild(currentAST, returnAST);
			functionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = functionTest_AST;
	}
	
	public final void mapType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mapType_AST = null;
		
		boolean synPredMatched153 = false;
		if (((LA(1)==LITERAL_map))) {
			int _m153 = mark();
			synPredMatched153 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_map);
				match(LPAREN);
				match(STAR);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched153 = false;
			}
			rewind(_m153);
inputState.guessing--;
		}
		if ( synPredMatched153 ) {
			anyMapTypeTest();
			astFactory.addASTChild(currentAST, returnAST);
			mapType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_map)) {
			mapTypeTest();
			astFactory.addASTChild(currentAST, returnAST);
			mapType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = mapType_AST;
	}
	
	public final void arrayType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST arrayType_AST = null;
		
		boolean synPredMatched161 = false;
		if (((LA(1)==LITERAL_array))) {
			int _m161 = mark();
			synPredMatched161 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_array);
				match(LPAREN);
				match(STAR);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched161 = false;
			}
			rewind(_m161);
inputState.guessing--;
		}
		if ( synPredMatched161 ) {
			anyArrayTypeTest();
			astFactory.addASTChild(currentAST, returnAST);
			arrayType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_array)) {
			arrayTypeTest();
			astFactory.addASTChild(currentAST, returnAST);
			arrayType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = arrayType_AST;
	}
	
	public final void parenthesizedItemType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST parenthesizedItemType_AST = null;
		
		match(LPAREN);
		itemType();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		parenthesizedItemType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = parenthesizedItemType_AST;
	}
	
	public final void kindTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST kindTest_AST = null;
		
		switch ( LA(1)) {
		case LITERAL_text:
		{
			textTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_node:
		{
			anyKindTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_element:
		{
			elementTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_attribute:
		{
			attributeTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_comment:
		{
			commentTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 193:
		{
			namespaceNodeTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 194:
		{
			piTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 195:
		{
			documentTest();
			astFactory.addASTChild(currentAST, returnAST);
			kindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = kindTest_AST;
	}
	
	public final void atomicType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST atomicType_AST = null;
		String name= null;
		
		name=qName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			atomicType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			atomicType_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(ATOMIC_TYPE,name);
			currentAST.root = atomicType_AST;
			currentAST.child = atomicType_AST!=null &&atomicType_AST.getFirstChild()!=null ?
				atomicType_AST.getFirstChild() : atomicType_AST;
			currentAST.advanceChildToEnd();
		}
		atomicType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = atomicType_AST;
	}
	
	public final void singleType() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST singleType_AST = null;
		
		atomicType();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case QUESTION:
		{
			org.exist.xquery.parser.XQueryAST tmp169_AST = null;
			tmp169_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp169_AST);
			match(QUESTION);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case UNION:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_treat:
		case LITERAL_castable:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		singleType_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = singleType_AST;
	}
	
	public final void anyFunctionTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST anyFunctionTest_AST = null;
		Token  s = null;
		org.exist.xquery.parser.XQueryAST s_AST = null;
		
		match(LITERAL_function);
		match(LPAREN);
		s = LT(1);
		s_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(s);
		astFactory.addASTChild(currentAST, s_AST);
		match(STAR);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			anyFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			anyFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(FUNCTION_TEST,"anyFunction")).add(s_AST));
			currentAST.root = anyFunctionTest_AST;
			currentAST.child = anyFunctionTest_AST!=null &&anyFunctionTest_AST.getFirstChild()!=null ?
				anyFunctionTest_AST.getFirstChild() : anyFunctionTest_AST;
			currentAST.advanceChildToEnd();
		}
		anyFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = anyFunctionTest_AST;
	}
	
	public final void typedFunctionTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST typedFunctionTest_AST = null;
		
		match(LITERAL_function);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case 115:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			sequenceType();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop150:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					sequenceType();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop150;
				}
				
			} while (true);
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		org.exist.xquery.parser.XQueryAST tmp177_AST = null;
		tmp177_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp177_AST);
		match(LITERAL_as);
		sequenceType();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			typedFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			typedFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(FUNCTION_TEST,"anyFunction")).add(typedFunctionTest_AST));
			currentAST.root = typedFunctionTest_AST;
			currentAST.child = typedFunctionTest_AST!=null &&typedFunctionTest_AST.getFirstChild()!=null ?
				typedFunctionTest_AST.getFirstChild() : typedFunctionTest_AST;
			currentAST.advanceChildToEnd();
		}
		typedFunctionTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = typedFunctionTest_AST;
	}
	
	public final void anyMapTypeTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST anyMapTypeTest_AST = null;
		Token  m = null;
		org.exist.xquery.parser.XQueryAST m_AST = null;
		Token  s = null;
		org.exist.xquery.parser.XQueryAST s_AST = null;
		
		m = LT(1);
		m_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(m);
		match(LITERAL_map);
		match(LPAREN);
		s = LT(1);
		s_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(s);
		astFactory.addASTChild(currentAST, s_AST);
		match(STAR);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			anyMapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					anyMapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(MAP_TEST,"map")).add(s_AST));
					anyMapTypeTest_AST.copyLexInfo(m_AST);
				
			currentAST.root = anyMapTypeTest_AST;
			currentAST.child = anyMapTypeTest_AST!=null &&anyMapTypeTest_AST.getFirstChild()!=null ?
				anyMapTypeTest_AST.getFirstChild() : anyMapTypeTest_AST;
			currentAST.advanceChildToEnd();
		}
		anyMapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = anyMapTypeTest_AST;
	}
	
	public final void mapTypeTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mapTypeTest_AST = null;
		Token  m = null;
		org.exist.xquery.parser.XQueryAST m_AST = null;
		
		m = LT(1);
		m_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(m);
		match(LITERAL_map);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case 115:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			sequenceType();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop158:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					sequenceType();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop158;
				}
				
			} while (true);
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			mapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					mapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(MAP_TEST,"map")).add(mapTypeTest_AST));
				
			currentAST.root = mapTypeTest_AST;
			currentAST.child = mapTypeTest_AST!=null &&mapTypeTest_AST.getFirstChild()!=null ?
				mapTypeTest_AST.getFirstChild() : mapTypeTest_AST;
			currentAST.advanceChildToEnd();
		}
		mapTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = mapTypeTest_AST;
	}
	
	public final void anyArrayTypeTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST anyArrayTypeTest_AST = null;
		Token  m = null;
		org.exist.xquery.parser.XQueryAST m_AST = null;
		Token  s = null;
		org.exist.xquery.parser.XQueryAST s_AST = null;
		
		m = LT(1);
		m_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(m);
		match(LITERAL_array);
		match(LPAREN);
		s = LT(1);
		s_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(s);
		astFactory.addASTChild(currentAST, s_AST);
		match(STAR);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			anyArrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					anyArrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ARRAY_TEST,"array")).add(s_AST));
					anyArrayTypeTest_AST.copyLexInfo(m_AST);
				
			currentAST.root = anyArrayTypeTest_AST;
			currentAST.child = anyArrayTypeTest_AST!=null &&anyArrayTypeTest_AST.getFirstChild()!=null ?
				anyArrayTypeTest_AST.getFirstChild() : anyArrayTypeTest_AST;
			currentAST.advanceChildToEnd();
		}
		anyArrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = anyArrayTypeTest_AST;
	}
	
	public final void arrayTypeTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST arrayTypeTest_AST = null;
		Token  m = null;
		org.exist.xquery.parser.XQueryAST m_AST = null;
		
		m = LT(1);
		m_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(m);
		match(LITERAL_array);
		match(LPAREN);
		sequenceType();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			arrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					arrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ARRAY_TEST,"array")).add(arrayTypeTest_AST));
				
			currentAST.root = arrayTypeTest_AST;
			currentAST.child = arrayTypeTest_AST!=null &&arrayTypeTest_AST.getFirstChild()!=null ?
				arrayTypeTest_AST.getFirstChild() : arrayTypeTest_AST;
			currentAST.advanceChildToEnd();
		}
		arrayTypeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = arrayTypeTest_AST;
	}
	
	public final void exprSingle() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST exprSingle_AST = null;
		
		boolean synPredMatched171 = false;
		if (((LA(1)==LITERAL_for||LA(1)==LITERAL_let))) {
			int _m171 = mark();
			synPredMatched171 = true;
			inputState.guessing++;
			try {
				{
				{
				switch ( LA(1)) {
				case LITERAL_for:
				{
					match(LITERAL_for);
					break;
				}
				case LITERAL_let:
				{
					match(LITERAL_let);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(DOLLAR);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched171 = false;
			}
			rewind(_m171);
inputState.guessing--;
		}
		if ( synPredMatched171 ) {
			flworExpr();
			astFactory.addASTChild(currentAST, returnAST);
			exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			boolean synPredMatched173 = false;
			if (((LA(1)==LITERAL_try))) {
				int _m173 = mark();
				synPredMatched173 = true;
				inputState.guessing++;
				try {
					{
					match(LITERAL_try);
					match(LCURLY);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched173 = false;
				}
				rewind(_m173);
inputState.guessing--;
			}
			if ( synPredMatched173 ) {
				tryCatchExpr();
				astFactory.addASTChild(currentAST, returnAST);
				exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else {
				boolean synPredMatched176 = false;
				if (((LA(1)==LITERAL_some||LA(1)==LITERAL_every))) {
					int _m176 = mark();
					synPredMatched176 = true;
					inputState.guessing++;
					try {
						{
						{
						switch ( LA(1)) {
						case LITERAL_some:
						{
							match(LITERAL_some);
							break;
						}
						case LITERAL_every:
						{
							match(LITERAL_every);
							break;
						}
						default:
						{
							throw new NoViableAltException(LT(1), getFilename());
						}
						}
						}
						match(DOLLAR);
						}
					}
					catch (RecognitionException pe) {
						synPredMatched176 = false;
					}
					rewind(_m176);
inputState.guessing--;
				}
				if ( synPredMatched176 ) {
					quantifiedExpr();
					astFactory.addASTChild(currentAST, returnAST);
					exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				}
				else {
					boolean synPredMatched178 = false;
					if (((LA(1)==LITERAL_if))) {
						int _m178 = mark();
						synPredMatched178 = true;
						inputState.guessing++;
						try {
							{
							match(LITERAL_if);
							match(LPAREN);
							}
						}
						catch (RecognitionException pe) {
							synPredMatched178 = false;
						}
						rewind(_m178);
inputState.guessing--;
					}
					if ( synPredMatched178 ) {
						ifExpr();
						astFactory.addASTChild(currentAST, returnAST);
						exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					}
					else {
						boolean synPredMatched180 = false;
						if (((LA(1)==LITERAL_switch))) {
							int _m180 = mark();
							synPredMatched180 = true;
							inputState.guessing++;
							try {
								{
								match(LITERAL_switch);
								match(LPAREN);
								}
							}
							catch (RecognitionException pe) {
								synPredMatched180 = false;
							}
							rewind(_m180);
inputState.guessing--;
						}
						if ( synPredMatched180 ) {
							switchExpr();
							astFactory.addASTChild(currentAST, returnAST);
							exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
						}
						else {
							boolean synPredMatched182 = false;
							if (((LA(1)==LITERAL_typeswitch))) {
								int _m182 = mark();
								synPredMatched182 = true;
								inputState.guessing++;
								try {
									{
									match(LITERAL_typeswitch);
									match(LPAREN);
									}
								}
								catch (RecognitionException pe) {
									synPredMatched182 = false;
								}
								rewind(_m182);
inputState.guessing--;
							}
							if ( synPredMatched182 ) {
								typeswitchExpr();
								astFactory.addASTChild(currentAST, returnAST);
								exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
							}
							else {
								boolean synPredMatched185 = false;
								if (((LA(1)==LITERAL_update))) {
									int _m185 = mark();
									synPredMatched185 = true;
									inputState.guessing++;
									try {
										{
										match(LITERAL_update);
										{
										switch ( LA(1)) {
										case LITERAL_replace:
										{
											match(LITERAL_replace);
											break;
										}
										case LITERAL_value:
										{
											match(LITERAL_value);
											break;
										}
										case LITERAL_insert:
										{
											match(LITERAL_insert);
											break;
										}
										case LITERAL_delete:
										{
											match(LITERAL_delete);
											break;
										}
										case LITERAL_rename:
										{
											match(LITERAL_rename);
											break;
										}
										default:
										{
											throw new NoViableAltException(LT(1), getFilename());
										}
										}
										}
										}
									}
									catch (RecognitionException pe) {
										synPredMatched185 = false;
									}
									rewind(_m185);
inputState.guessing--;
								}
								if ( synPredMatched185 ) {
									updateExpr();
									astFactory.addASTChild(currentAST, returnAST);
									exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
								}
								else if ((_tokenSet_4.member(LA(1)))) {
									orExpr();
									astFactory.addASTChild(currentAST, returnAST);
									exprSingle_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
								}
								else {
									throw new NoViableAltException(LT(1), getFilename());
								}
								}}}}}}
								returnAST = exprSingle_AST;
							}
							
	public final void flworExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST flworExpr_AST = null;
		
		initialClause();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop213:
		do {
			if ((_tokenSet_5.member(LA(1)))) {
				intermediateClause();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop213;
			}
			
		} while (true);
		}
		org.exist.xquery.parser.XQueryAST tmp187_AST = null;
		tmp187_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp187_AST);
		match(LITERAL_return);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		flworExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = flworExpr_AST;
	}
	
	public final void tryCatchExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST tryCatchExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp188_AST = null;
		tmp188_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp188_AST);
		match(LITERAL_try);
		match(LCURLY);
		tryTargetExpr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		{
		int _cnt198=0;
		_loop198:
		do {
			if ((LA(1)==LITERAL_catch)) {
				catchClause();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt198>=1 ) { break _loop198; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt198++;
		} while (true);
		}
		tryCatchExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = tryCatchExpr_AST;
	}
	
	public final void quantifiedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST quantifiedExpr_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_some:
		{
			org.exist.xquery.parser.XQueryAST tmp191_AST = null;
			tmp191_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp191_AST);
			match(LITERAL_some);
			break;
		}
		case LITERAL_every:
		{
			org.exist.xquery.parser.XQueryAST tmp192_AST = null;
			tmp192_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp192_AST);
			match(LITERAL_every);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		quantifiedInVarBinding();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop254:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				quantifiedInVarBinding();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop254;
			}
			
		} while (true);
		}
		match(LITERAL_satisfies);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		quantifiedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = quantifiedExpr_AST;
	}
	
	public final void ifExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST ifExpr_AST = null;
		Token  t = null;
		org.exist.xquery.parser.XQueryAST t_AST = null;
		org.exist.xquery.parser.XQueryAST thenExpr_AST = null;
		Token  e = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		org.exist.xquery.parser.XQueryAST elseExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp195_AST = null;
		tmp195_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp195_AST);
		match(LITERAL_if);
		match(LPAREN);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		t = LT(1);
		t_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(t);
		match(LITERAL_then);
		exprSingle();
		thenExpr_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		e = LT(1);
		e_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(e);
		match(LITERAL_else);
		exprSingle();
		elseExpr_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			
			thenExpr_AST.copyLexInfo(t_AST);
			elseExpr_AST.copyLexInfo(e_AST);
			
		}
		ifExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = ifExpr_AST;
	}
	
	public final void switchExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST switchExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp198_AST = null;
		tmp198_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp198_AST);
		match(LITERAL_switch);
		match(LPAREN);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		{
		int _cnt259=0;
		_loop259:
		do {
			if ((LA(1)==LITERAL_case)) {
				switchCaseClause();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt259>=1 ) { break _loop259; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt259++;
		} while (true);
		}
		org.exist.xquery.parser.XQueryAST tmp201_AST = null;
		tmp201_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp201_AST);
		match(LITERAL_default);
		match(LITERAL_return);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		switchExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = switchExpr_AST;
	}
	
	public final void typeswitchExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST typeswitchExpr_AST = null;
		String varName;
		
		org.exist.xquery.parser.XQueryAST tmp203_AST = null;
		tmp203_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp203_AST);
		match(LITERAL_typeswitch);
		match(LPAREN);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		{
		int _cnt265=0;
		_loop265:
		do {
			if ((LA(1)==LITERAL_case)) {
				caseClause();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt265>=1 ) { break _loop265; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt265++;
		} while (true);
		}
		org.exist.xquery.parser.XQueryAST tmp206_AST = null;
		tmp206_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp206_AST);
		match(LITERAL_default);
		{
		switch ( LA(1)) {
		case DOLLAR:
		{
			defaultVar();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_return:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(LITERAL_return);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		typeswitchExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = typeswitchExpr_AST;
	}
	
	public final void updateExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST updateExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp208_AST = null;
		tmp208_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp208_AST);
		match(LITERAL_update);
		{
		switch ( LA(1)) {
		case LITERAL_replace:
		{
			replaceExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_value:
		{
			updateValueExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_insert:
		{
			insertExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_delete:
		{
			deleteExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_rename:
		{
			renameExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		updateExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = updateExpr_AST;
	}
	
	public final void orExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orExpr_AST = null;
		
		andExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop278:
		do {
			if ((LA(1)==LITERAL_or)) {
				org.exist.xquery.parser.XQueryAST tmp209_AST = null;
				tmp209_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp209_AST);
				match(LITERAL_or);
				andExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop278;
			}
			
		} while (true);
		}
		orExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orExpr_AST;
	}
	
	public final void replaceExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST replaceExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp210_AST = null;
		tmp210_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp210_AST);
		match(LITERAL_replace);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(LITERAL_with);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		replaceExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = replaceExpr_AST;
	}
	
	public final void updateValueExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST updateValueExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp212_AST = null;
		tmp212_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp212_AST);
		match(LITERAL_value);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(LITERAL_with);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		updateValueExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = updateValueExpr_AST;
	}
	
	public final void insertExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST insertExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp214_AST = null;
		tmp214_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp214_AST);
		match(LITERAL_insert);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_into:
		{
			org.exist.xquery.parser.XQueryAST tmp215_AST = null;
			tmp215_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp215_AST);
			match(LITERAL_into);
			break;
		}
		case LITERAL_preceding:
		{
			org.exist.xquery.parser.XQueryAST tmp216_AST = null;
			tmp216_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp216_AST);
			match(LITERAL_preceding);
			break;
		}
		case LITERAL_following:
		{
			org.exist.xquery.parser.XQueryAST tmp217_AST = null;
			tmp217_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp217_AST);
			match(LITERAL_following);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		insertExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = insertExpr_AST;
	}
	
	public final void deleteExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST deleteExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp218_AST = null;
		tmp218_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp218_AST);
		match(LITERAL_delete);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		deleteExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = deleteExpr_AST;
	}
	
	public final void renameExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST renameExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp219_AST = null;
		tmp219_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp219_AST);
		match(LITERAL_rename);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		match(LITERAL_as);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		renameExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = renameExpr_AST;
	}
	
	public final void tryTargetExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST tryTargetExpr_AST = null;
		
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		tryTargetExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = tryTargetExpr_AST;
	}
	
	public final void catchClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchClause_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp221_AST = null;
		tmp221_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp221_AST);
		match(LITERAL_catch);
		catchErrorList();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LPAREN:
		{
			catchVars();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LCURLY:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(LCURLY);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		catchClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchClause_AST;
	}
	
	public final void catchErrorList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchErrorList_AST = null;
		
		nameTest();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop204:
		do {
			if ((LA(1)==UNION)) {
				match(UNION);
				nameTest();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop204;
			}
			
		} while (true);
		}
		catchErrorList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchErrorList_AST;
	}
	
	public final void catchVars() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchVars_AST = null;
		
		match(LPAREN);
		catchErrorCode();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case COMMA:
		{
			match(COMMA);
			catchErrorDesc();
			astFactory.addASTChild(currentAST, returnAST);
			{
			switch ( LA(1)) {
			case COMMA:
			{
				match(COMMA);
				catchErrorVal();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		catchVars_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchVars_AST;
	}
	
	public final void nameTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST nameTest_AST = null;
		org.exist.xquery.parser.XQueryAST n_AST = null;
		String name= null;
		
		boolean synPredMatched378 = false;
		if (((_tokenSet_6.member(LA(1))))) {
			int _m378 = mark();
			synPredMatched378 = true;
			inputState.guessing++;
			try {
				{
				switch ( LA(1)) {
				case LITERAL_xpointer:
				case NCNAME:
				case LITERAL_xquery:
				case LITERAL_version:
				case LITERAL_module:
				case LITERAL_namespace:
				case LITERAL_declare:
				case LITERAL_default:
				case 79:
				case LITERAL_ordering:
				case LITERAL_construction:
				case 82:
				case LITERAL_option:
				case LITERAL_function:
				case LITERAL_variable:
				case LITERAL_context:
				case LITERAL_item:
				case LITERAL_import:
				case LITERAL_encoding:
				case LITERAL_collation:
				case LITERAL_element:
				case LITERAL_order:
				case LITERAL_empty:
				case LITERAL_preserve:
				case LITERAL_strip:
				case LITERAL_ordered:
				case LITERAL_unordered:
				case 103:
				case LITERAL_inherit:
				case 105:
				case LITERAL_external:
				case LITERAL_schema:
				case LITERAL_as:
				case LITERAL_at:
				case LITERAL_map:
				case LITERAL_array:
				case LITERAL_for:
				case LITERAL_let:
				case LITERAL_try:
				case LITERAL_some:
				case LITERAL_every:
				case LITERAL_if:
				case LITERAL_switch:
				case LITERAL_typeswitch:
				case LITERAL_update:
				case LITERAL_replace:
				case LITERAL_value:
				case LITERAL_insert:
				case LITERAL_delete:
				case LITERAL_rename:
				case LITERAL_with:
				case LITERAL_into:
				case LITERAL_preceding:
				case LITERAL_following:
				case LITERAL_catch:
				case LITERAL_return:
				case LITERAL_where:
				case LITERAL_in:
				case LITERAL_by:
				case LITERAL_stable:
				case LITERAL_group:
				case LITERAL_case:
				case LITERAL_then:
				case LITERAL_else:
				case LITERAL_or:
				case LITERAL_and:
				case LITERAL_instance:
				case LITERAL_of:
				case LITERAL_treat:
				case LITERAL_cast:
				case LITERAL_eq:
				case LITERAL_ne:
				case LITERAL_lt:
				case LITERAL_le:
				case LITERAL_gt:
				case LITERAL_ge:
				case LITERAL_is:
				case LITERAL_isnot:
				case LITERAL_to:
				case LITERAL_div:
				case LITERAL_mod:
				case LITERAL_union:
				case LITERAL_intersect:
				case LITERAL_except:
				case LITERAL_text:
				case LITERAL_node:
				case LITERAL_attribute:
				case LITERAL_comment:
				case 193:
				case 195:
				case LITERAL_document:
				case LITERAL_child:
				case LITERAL_self:
				case LITERAL_descendant:
				case 209:
				case 210:
				case LITERAL_parent:
				case LITERAL_ancestor:
				case 213:
				case 214:
				case LITERAL_collection:
				case LITERAL_validate:
				{
					{
					ncnameOrKeyword();
					match(COLON);
					match(STAR);
					}
					break;
				}
				case STAR:
				{
					match(STAR);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
			}
			catch (RecognitionException pe) {
				synPredMatched378 = false;
			}
			rewind(_m378);
inputState.guessing--;
		}
		if ( synPredMatched378 ) {
			wildcard();
			astFactory.addASTChild(currentAST, returnAST);
			nameTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((_tokenSet_7.member(LA(1)))) {
			name=eqName();
			n_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				nameTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
						nameTest_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(EQNAME,name);
						nameTest_AST.copyLexInfo(n_AST);
					
				currentAST.root = nameTest_AST;
				currentAST.child = nameTest_AST!=null &&nameTest_AST.getFirstChild()!=null ?
					nameTest_AST.getFirstChild() : nameTest_AST;
				currentAST.advanceChildToEnd();
			}
			nameTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = nameTest_AST;
	}
	
	public final void catchErrorCode() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchErrorCode_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=qName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			catchErrorCode_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			catchErrorCode_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(CATCH_ERROR_CODE,varName);
			currentAST.root = catchErrorCode_AST;
			currentAST.child = catchErrorCode_AST!=null &&catchErrorCode_AST.getFirstChild()!=null ?
				catchErrorCode_AST.getFirstChild() : catchErrorCode_AST;
			currentAST.advanceChildToEnd();
		}
		catchErrorCode_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchErrorCode_AST;
	}
	
	public final void catchErrorDesc() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchErrorDesc_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=qName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			catchErrorDesc_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			catchErrorDesc_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(CATCH_ERROR_DESC,varName);
			currentAST.root = catchErrorDesc_AST;
			currentAST.child = catchErrorDesc_AST!=null &&catchErrorDesc_AST.getFirstChild()!=null ?
				catchErrorDesc_AST.getFirstChild() : catchErrorDesc_AST;
			currentAST.advanceChildToEnd();
		}
		catchErrorDesc_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchErrorDesc_AST;
	}
	
	public final void catchErrorVal() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST catchErrorVal_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=qName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			catchErrorVal_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			catchErrorVal_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(CATCH_ERROR_VAL,varName);
			currentAST.root = catchErrorVal_AST;
			currentAST.child = catchErrorVal_AST!=null &&catchErrorVal_AST.getFirstChild()!=null ?
				catchErrorVal_AST.getFirstChild() : catchErrorVal_AST;
			currentAST.advanceChildToEnd();
		}
		catchErrorVal_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = catchErrorVal_AST;
	}
	
	public final void initialClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST initialClause_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_for:
		{
			forClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_let:
		{
			letClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		initialClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = initialClause_AST;
	}
	
	public final void intermediateClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST intermediateClause_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_for:
		case LITERAL_let:
		{
			initialClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_where:
		{
			whereClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_group:
		{
			groupByClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_order:
		case LITERAL_stable:
		{
			orderByClause();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		intermediateClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = intermediateClause_AST;
	}
	
	public final void forClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST forClause_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp232_AST = null;
		tmp232_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp232_AST);
		match(LITERAL_for);
		inVarBinding();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop221:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				inVarBinding();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop221;
			}
			
		} while (true);
		}
		forClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = forClause_AST;
	}
	
	public final void letClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST letClause_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp234_AST = null;
		tmp234_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp234_AST);
		match(LITERAL_let);
		letVarBinding();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop224:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				letVarBinding();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop224;
			}
			
		} while (true);
		}
		letClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = letClause_AST;
	}
	
	public final void whereClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST whereClause_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp236_AST = null;
		tmp236_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp236_AST);
		match(LITERAL_where);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		whereClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = whereClause_AST;
	}
	
	public final void groupByClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST groupByClause_AST = null;
		
		match(LITERAL_group);
		match(LITERAL_by);
		groupingSpecList();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			groupByClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			groupByClause_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(GROUP_BY,"group by")).add(groupByClause_AST));
			currentAST.root = groupByClause_AST;
			currentAST.child = groupByClause_AST!=null &&groupByClause_AST.getFirstChild()!=null ?
				groupByClause_AST.getFirstChild() : groupByClause_AST;
			currentAST.advanceChildToEnd();
		}
		groupByClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = groupByClause_AST;
	}
	
	public final void orderByClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orderByClause_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_order:
		{
			match(LITERAL_order);
			match(LITERAL_by);
			break;
		}
		case LITERAL_stable:
		{
			match(LITERAL_stable);
			match(LITERAL_order);
			match(LITERAL_by);
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		orderSpecList();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			orderByClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			orderByClause_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ORDER_BY,"order by")).add(orderByClause_AST));
			currentAST.root = orderByClause_AST;
			currentAST.child = orderByClause_AST!=null &&orderByClause_AST.getFirstChild()!=null ?
				orderByClause_AST.getFirstChild() : orderByClause_AST;
			currentAST.advanceChildToEnd();
		}
		orderByClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orderByClause_AST;
	}
	
	public final void inVarBinding() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST inVarBinding_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=varName();
		v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_at:
		case LITERAL_in:
		case LITERAL_allowing:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_allowing:
		{
			allowingEmpty();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_at:
		case LITERAL_in:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_at:
		{
			positionalVar();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_in:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(LITERAL_in);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			inVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					inVarBinding_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName)).add(inVarBinding_AST));
					inVarBinding_AST.copyLexInfo(v_AST);
				
			currentAST.root = inVarBinding_AST;
			currentAST.child = inVarBinding_AST!=null &&inVarBinding_AST.getFirstChild()!=null ?
				inVarBinding_AST.getFirstChild() : inVarBinding_AST;
			currentAST.advanceChildToEnd();
		}
		inVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = inVarBinding_AST;
	}
	
	public final void letVarBinding() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST letVarBinding_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=varName();
		v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case COLON:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(COLON);
		match(EQ);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			letVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					letVarBinding_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName)).add(letVarBinding_AST));
					letVarBinding_AST.copyLexInfo(v_AST);
				
			currentAST.root = letVarBinding_AST;
			currentAST.child = letVarBinding_AST!=null &&letVarBinding_AST.getFirstChild()!=null ?
				letVarBinding_AST.getFirstChild() : letVarBinding_AST;
			currentAST.advanceChildToEnd();
		}
		letVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = letVarBinding_AST;
	}
	
	public final void allowingEmpty() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST allowingEmpty_AST = null;
		
		match(LITERAL_allowing);
		org.exist.xquery.parser.XQueryAST tmp250_AST = null;
		tmp250_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp250_AST);
		match(LITERAL_empty);
		allowingEmpty_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = allowingEmpty_AST;
	}
	
	public final void positionalVar() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST positionalVar_AST = null;
		String varName;
		
		org.exist.xquery.parser.XQueryAST tmp251_AST = null;
		tmp251_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp251_AST);
		match(LITERAL_at);
		match(DOLLAR);
		varName=varName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			positionalVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			positionalVar_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(POSITIONAL_VAR,varName);
			currentAST.root = positionalVar_AST;
			currentAST.child = positionalVar_AST!=null &&positionalVar_AST.getFirstChild()!=null ?
				positionalVar_AST.getFirstChild() : positionalVar_AST;
			currentAST.advanceChildToEnd();
		}
		positionalVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = positionalVar_AST;
	}
	
	public final void orderSpecList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orderSpecList_AST = null;
		
		orderSpec();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop237:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				orderSpec();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop237;
			}
			
		} while (true);
		}
		orderSpecList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orderSpecList_AST;
	}
	
	public final void orderSpec() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orderSpec_AST = null;
		
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		orderModifier();
		astFactory.addASTChild(currentAST, returnAST);
		orderSpec_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orderSpec_AST;
	}
	
	public final void orderModifier() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orderModifier_AST = null;
		
		{
		switch ( LA(1)) {
		case LITERAL_ascending:
		{
			org.exist.xquery.parser.XQueryAST tmp254_AST = null;
			tmp254_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp254_AST);
			match(LITERAL_ascending);
			break;
		}
		case LITERAL_descending:
		{
			org.exist.xquery.parser.XQueryAST tmp255_AST = null;
			tmp255_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp255_AST);
			match(LITERAL_descending);
			break;
		}
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_group:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_empty:
		{
			org.exist.xquery.parser.XQueryAST tmp256_AST = null;
			tmp256_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp256_AST);
			match(LITERAL_empty);
			{
			switch ( LA(1)) {
			case LITERAL_greatest:
			{
				org.exist.xquery.parser.XQueryAST tmp257_AST = null;
				tmp257_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp257_AST);
				match(LITERAL_greatest);
				break;
			}
			case LITERAL_least:
			{
				org.exist.xquery.parser.XQueryAST tmp258_AST = null;
				tmp258_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp258_AST);
				match(LITERAL_least);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		case LITERAL_collation:
		case LITERAL_order:
		case COMMA:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_group:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_collation:
		{
			org.exist.xquery.parser.XQueryAST tmp259_AST = null;
			tmp259_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp259_AST);
			match(LITERAL_collation);
			org.exist.xquery.parser.XQueryAST tmp260_AST = null;
			tmp260_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp260_AST);
			match(STRING_LITERAL);
			break;
		}
		case LITERAL_order:
		case COMMA:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_group:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		orderModifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orderModifier_AST;
	}
	
	public final void groupingSpecList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST groupingSpecList_AST = null;
		
		groupingSpec();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop247:
		do {
			if ((LA(1)==COMMA)) {
				match(COMMA);
				groupingSpec();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop247;
			}
			
		} while (true);
		}
		groupingSpecList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = groupingSpecList_AST;
	}
	
	public final void groupingSpec() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST groupingSpec_AST = null;
		String groupKeyVarName;
		
		match(DOLLAR);
		groupKeyVarName=varName();
		{
		switch ( LA(1)) {
		case COLON:
		{
			match(COLON);
			match(EQ);
			exprSingle();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_collation:
		case LITERAL_order:
		case COMMA:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_group:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		{
		switch ( LA(1)) {
		case LITERAL_collation:
		{
			org.exist.xquery.parser.XQueryAST tmp265_AST = null;
			tmp265_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp265_AST);
			match(LITERAL_collation);
			org.exist.xquery.parser.XQueryAST tmp266_AST = null;
			tmp266_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp266_AST);
			match(STRING_LITERAL);
			break;
		}
		case LITERAL_order:
		case COMMA:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_group:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		if ( inputState.guessing==0 ) {
			groupingSpec_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			groupingSpec_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,groupKeyVarName)).add(groupingSpec_AST));
			currentAST.root = groupingSpec_AST;
			currentAST.child = groupingSpec_AST!=null &&groupingSpec_AST.getFirstChild()!=null ?
				groupingSpec_AST.getFirstChild() : groupingSpec_AST;
			currentAST.advanceChildToEnd();
		}
		groupingSpec_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = groupingSpec_AST;
	}
	
	public final void quantifiedInVarBinding() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST quantifiedInVarBinding_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=varName();
		{
		switch ( LA(1)) {
		case LITERAL_as:
		{
			typeDeclaration();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_in:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(LITERAL_in);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			quantifiedInVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			quantifiedInVarBinding_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName)).add(quantifiedInVarBinding_AST));
			currentAST.root = quantifiedInVarBinding_AST;
			currentAST.child = quantifiedInVarBinding_AST!=null &&quantifiedInVarBinding_AST.getFirstChild()!=null ?
				quantifiedInVarBinding_AST.getFirstChild() : quantifiedInVarBinding_AST;
			currentAST.advanceChildToEnd();
		}
		quantifiedInVarBinding_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = quantifiedInVarBinding_AST;
	}
	
	public final void switchCaseClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST switchCaseClause_AST = null;
		
		{
		int _cnt262=0;
		_loop262:
		do {
			if ((LA(1)==LITERAL_case)) {
				org.exist.xquery.parser.XQueryAST tmp269_AST = null;
				tmp269_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp269_AST);
				match(LITERAL_case);
				exprSingle();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt262>=1 ) { break _loop262; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt262++;
		} while (true);
		}
		caseReturn();
		astFactory.addASTChild(currentAST, returnAST);
		switchCaseClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = switchCaseClause_AST;
	}
	
	public final void caseReturn() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST caseReturn_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp270_AST = null;
		tmp270_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp270_AST);
		match(LITERAL_return);
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		caseReturn_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = caseReturn_AST;
	}
	
	public final void caseClause() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST caseClause_AST = null;
		String varName;
		
		org.exist.xquery.parser.XQueryAST tmp271_AST = null;
		tmp271_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp271_AST);
		match(LITERAL_case);
		{
		switch ( LA(1)) {
		case DOLLAR:
		{
			caseVar();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case 115:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		sequenceTypeUnion();
		astFactory.addASTChild(currentAST, returnAST);
		caseReturn();
		astFactory.addASTChild(currentAST, returnAST);
		caseClause_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = caseClause_AST;
	}
	
	public final void defaultVar() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST defaultVar_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=varName();
		if ( inputState.guessing==0 ) {
			defaultVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			defaultVar_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName);
			currentAST.root = defaultVar_AST;
			currentAST.child = defaultVar_AST!=null &&defaultVar_AST.getFirstChild()!=null ?
				defaultVar_AST.getFirstChild() : defaultVar_AST;
			currentAST.advanceChildToEnd();
		}
		defaultVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = defaultVar_AST;
	}
	
	public final void caseVar() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST caseVar_AST = null;
		String varName;
		
		match(DOLLAR);
		varName=varName();
		org.exist.xquery.parser.XQueryAST tmp274_AST = null;
		tmp274_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp274_AST);
		match(LITERAL_as);
		if ( inputState.guessing==0 ) {
			caseVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			caseVar_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_BINDING,varName);
			currentAST.root = caseVar_AST;
			currentAST.child = caseVar_AST!=null &&caseVar_AST.getFirstChild()!=null ?
				caseVar_AST.getFirstChild() : caseVar_AST;
			currentAST.advanceChildToEnd();
		}
		caseVar_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = caseVar_AST;
	}
	
	public final void sequenceTypeUnion() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST sequenceTypeUnion_AST = null;
		
		sequenceType();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop271:
		do {
			if ((LA(1)==UNION)) {
				match(UNION);
				sequenceType();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop271;
			}
			
		} while (true);
		}
		sequenceTypeUnion_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = sequenceTypeUnion_AST;
	}
	
	public final void andExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST andExpr_AST = null;
		
		comparisonExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop281:
		do {
			if ((LA(1)==LITERAL_and)) {
				org.exist.xquery.parser.XQueryAST tmp276_AST = null;
				tmp276_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp276_AST);
				match(LITERAL_and);
				comparisonExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop281;
			}
			
		} while (true);
		}
		andExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = andExpr_AST;
	}
	
	public final void comparisonExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST comparisonExpr_AST = null;
		org.exist.xquery.parser.XQueryAST r1_AST = null;
		org.exist.xquery.parser.XQueryAST r2_AST = null;
		
		stringConcatExpr();
		r1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case BEFORE:
		{
			org.exist.xquery.parser.XQueryAST tmp277_AST = null;
			tmp277_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp277_AST);
			match(BEFORE);
			stringConcatExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case AFTER:
		{
			org.exist.xquery.parser.XQueryAST tmp278_AST = null;
			tmp278_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp278_AST);
			match(AFTER);
			stringConcatExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		{
			{
			{
			switch ( LA(1)) {
			case LITERAL_eq:
			{
				org.exist.xquery.parser.XQueryAST tmp279_AST = null;
				tmp279_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp279_AST);
				match(LITERAL_eq);
				break;
			}
			case LITERAL_ne:
			{
				org.exist.xquery.parser.XQueryAST tmp280_AST = null;
				tmp280_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp280_AST);
				match(LITERAL_ne);
				break;
			}
			case LITERAL_lt:
			{
				org.exist.xquery.parser.XQueryAST tmp281_AST = null;
				tmp281_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp281_AST);
				match(LITERAL_lt);
				break;
			}
			case LITERAL_le:
			{
				org.exist.xquery.parser.XQueryAST tmp282_AST = null;
				tmp282_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp282_AST);
				match(LITERAL_le);
				break;
			}
			case LITERAL_gt:
			{
				org.exist.xquery.parser.XQueryAST tmp283_AST = null;
				tmp283_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp283_AST);
				match(LITERAL_gt);
				break;
			}
			case LITERAL_ge:
			{
				org.exist.xquery.parser.XQueryAST tmp284_AST = null;
				tmp284_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp284_AST);
				match(LITERAL_ge);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			stringConcatExpr();
			astFactory.addASTChild(currentAST, returnAST);
			}
			break;
		}
		case LITERAL_is:
		case LITERAL_isnot:
		{
			{
			{
			switch ( LA(1)) {
			case LITERAL_is:
			{
				org.exist.xquery.parser.XQueryAST tmp285_AST = null;
				tmp285_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp285_AST);
				match(LITERAL_is);
				break;
			}
			case LITERAL_isnot:
			{
				org.exist.xquery.parser.XQueryAST tmp286_AST = null;
				tmp286_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp286_AST);
				match(LITERAL_isnot);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			stringConcatExpr();
			astFactory.addASTChild(currentAST, returnAST);
			}
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
			boolean synPredMatched299 = false;
			if (((LA(1)==GT))) {
				int _m299 = mark();
				synPredMatched299 = true;
				inputState.guessing++;
				try {
					{
					match(GT);
					match(EQ);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched299 = false;
				}
				rewind(_m299);
inputState.guessing--;
			}
			if ( synPredMatched299 ) {
				org.exist.xquery.parser.XQueryAST tmp287_AST = null;
				tmp287_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp287_AST);
				match(GT);
				org.exist.xquery.parser.XQueryAST tmp288_AST = null;
				tmp288_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp288_AST);
				match(EQ);
				rangeExpr();
				r2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				if ( inputState.guessing==0 ) {
					comparisonExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					comparisonExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(GTEQ,">=")).add(r1_AST).add(r2_AST));
					currentAST.root = comparisonExpr_AST;
					currentAST.child = comparisonExpr_AST!=null &&comparisonExpr_AST.getFirstChild()!=null ?
						comparisonExpr_AST.getFirstChild() : comparisonExpr_AST;
					currentAST.advanceChildToEnd();
				}
			}
			else if ((_tokenSet_8.member(LA(1)))) {
				{
				{
				switch ( LA(1)) {
				case EQ:
				{
					org.exist.xquery.parser.XQueryAST tmp289_AST = null;
					tmp289_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp289_AST);
					match(EQ);
					break;
				}
				case NEQ:
				{
					org.exist.xquery.parser.XQueryAST tmp290_AST = null;
					tmp290_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp290_AST);
					match(NEQ);
					break;
				}
				case GT:
				{
					org.exist.xquery.parser.XQueryAST tmp291_AST = null;
					tmp291_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp291_AST);
					match(GT);
					break;
				}
				case LT:
				{
					org.exist.xquery.parser.XQueryAST tmp292_AST = null;
					tmp292_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp292_AST);
					match(LT);
					break;
				}
				case LTEQ:
				{
					org.exist.xquery.parser.XQueryAST tmp293_AST = null;
					tmp293_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp293_AST);
					match(LTEQ);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				stringConcatExpr();
				astFactory.addASTChild(currentAST, returnAST);
				}
			}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		comparisonExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = comparisonExpr_AST;
	}
	
	public final void instanceofExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST instanceofExpr_AST = null;
		
		treatExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_instance:
		{
			org.exist.xquery.parser.XQueryAST tmp294_AST = null;
			tmp294_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp294_AST);
			match(LITERAL_instance);
			match(LITERAL_of);
			sequenceType();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case UNION:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		instanceofExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = instanceofExpr_AST;
	}
	
	public final void treatExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST treatExpr_AST = null;
		
		castableExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_treat:
		{
			org.exist.xquery.parser.XQueryAST tmp296_AST = null;
			tmp296_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp296_AST);
			match(LITERAL_treat);
			match(LITERAL_as);
			sequenceType();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case UNION:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		treatExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = treatExpr_AST;
	}
	
	public final void castableExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST castableExpr_AST = null;
		
		castExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_castable:
		{
			org.exist.xquery.parser.XQueryAST tmp298_AST = null;
			tmp298_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp298_AST);
			match(LITERAL_castable);
			match(LITERAL_as);
			singleType();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case UNION:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_treat:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		castableExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = castableExpr_AST;
	}
	
	public final void castExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST castExpr_AST = null;
		
		arrowExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_cast:
		{
			org.exist.xquery.parser.XQueryAST tmp300_AST = null;
			tmp300_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp300_AST);
			match(LITERAL_cast);
			match(LITERAL_as);
			singleType();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case UNION:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_treat:
		case LITERAL_castable:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		castExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = castExpr_AST;
	}
	
	public final void arrowExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST arrowExpr_AST = null;
		
		unaryExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop393:
		do {
			if ((LA(1)==ARROW_OP)) {
				org.exist.xquery.parser.XQueryAST tmp302_AST = null;
				tmp302_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.makeASTRoot(currentAST, tmp302_AST);
				match(ARROW_OP);
				arrowFunctionSpecifier();
				astFactory.addASTChild(currentAST, returnAST);
				argumentList();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop393;
			}
			
		} while (true);
		}
		arrowExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = arrowExpr_AST;
	}
	
	public final void stringConcatExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST stringConcatExpr_AST = null;
		org.exist.xquery.parser.XQueryAST r1_AST = null;
		boolean isConcat = false;
		
		rangeExpr();
		r1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop306:
		do {
			if ((LA(1)==CONCAT)) {
				match(CONCAT);
				rangeExpr();
				astFactory.addASTChild(currentAST, returnAST);
				if ( inputState.guessing==0 ) {
					isConcat = true;
				}
			}
			else {
				break _loop306;
			}
			
		} while (true);
		}
		if ( inputState.guessing==0 ) {
			stringConcatExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					if (isConcat)
						stringConcatExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(CONCAT,"||")).add(stringConcatExpr_AST));
				
			currentAST.root = stringConcatExpr_AST;
			currentAST.child = stringConcatExpr_AST!=null &&stringConcatExpr_AST.getFirstChild()!=null ?
				stringConcatExpr_AST.getFirstChild() : stringConcatExpr_AST;
			currentAST.advanceChildToEnd();
		}
		stringConcatExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = stringConcatExpr_AST;
	}
	
	public final void rangeExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST rangeExpr_AST = null;
		
		additiveExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case LITERAL_to:
		{
			org.exist.xquery.parser.XQueryAST tmp304_AST = null;
			tmp304_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp304_AST);
			match(LITERAL_to);
			additiveExpr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		rangeExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = rangeExpr_AST;
	}
	
	public final void additiveExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST additiveExpr_AST = null;
		
		multiplicativeExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop312:
		do {
			if ((LA(1)==PLUS||LA(1)==MINUS)) {
				{
				switch ( LA(1)) {
				case PLUS:
				{
					org.exist.xquery.parser.XQueryAST tmp305_AST = null;
					tmp305_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp305_AST);
					match(PLUS);
					break;
				}
				case MINUS:
				{
					org.exist.xquery.parser.XQueryAST tmp306_AST = null;
					tmp306_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp306_AST);
					match(MINUS);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				multiplicativeExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop312;
			}
			
		} while (true);
		}
		additiveExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = additiveExpr_AST;
	}
	
	public final void multiplicativeExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST multiplicativeExpr_AST = null;
		
		unionExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop316:
		do {
			if ((_tokenSet_9.member(LA(1)))) {
				{
				switch ( LA(1)) {
				case STAR:
				{
					org.exist.xquery.parser.XQueryAST tmp307_AST = null;
					tmp307_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp307_AST);
					match(STAR);
					break;
				}
				case LITERAL_div:
				{
					org.exist.xquery.parser.XQueryAST tmp308_AST = null;
					tmp308_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp308_AST);
					match(LITERAL_div);
					break;
				}
				case LITERAL_idiv:
				{
					org.exist.xquery.parser.XQueryAST tmp309_AST = null;
					tmp309_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp309_AST);
					match(LITERAL_idiv);
					break;
				}
				case LITERAL_mod:
				{
					org.exist.xquery.parser.XQueryAST tmp310_AST = null;
					tmp310_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp310_AST);
					match(LITERAL_mod);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				unionExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop316;
			}
			
		} while (true);
		}
		multiplicativeExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = multiplicativeExpr_AST;
	}
	
	public final void unionExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST unionExpr_AST = null;
		
		intersectExceptExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		switch ( LA(1)) {
		case UNION:
		case LITERAL_union:
		{
			{
			switch ( LA(1)) {
			case LITERAL_union:
			{
				match(LITERAL_union);
				break;
			}
			case UNION:
			{
				match(UNION);
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			unionExpr();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				unionExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
							unionExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(UNION,"union")).add(unionExpr_AST));
						
				currentAST.root = unionExpr_AST;
				currentAST.child = unionExpr_AST!=null &&unionExpr_AST.getFirstChild()!=null ?
					unionExpr_AST.getFirstChild() : unionExpr_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		case EOF:
		case RPAREN:
		case SEMICOLON:
		case EQ:
		case LITERAL_default:
		case LITERAL_collation:
		case LITERAL_order:
		case LITERAL_empty:
		case COMMA:
		case COLON:
		case RCURLY:
		case LITERAL_as:
		case STAR:
		case PLUS:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_stable:
		case LITERAL_ascending:
		case LITERAL_descending:
		case LITERAL_group:
		case LITERAL_satisfies:
		case LITERAL_case:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case BEFORE:
		case AFTER:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case GT:
		case NEQ:
		case LT:
		case LTEQ:
		case LITERAL_is:
		case LITERAL_isnot:
		case CONCAT:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_idiv:
		case LITERAL_mod:
		case RPPAREN:
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		unionExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = unionExpr_AST;
	}
	
	public final void unaryExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST unaryExpr_AST = null;
		
		switch ( LA(1)) {
		case MINUS:
		{
			match(MINUS);
			{
			unaryExpr();
			astFactory.addASTChild(currentAST, returnAST);
			}
			if ( inputState.guessing==0 ) {
				unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(UNARY_MINUS,"-")).add(unaryExpr_AST));
				currentAST.root = unaryExpr_AST;
				currentAST.child = unaryExpr_AST!=null &&unaryExpr_AST.getFirstChild()!=null ?
					unaryExpr_AST.getFirstChild() : unaryExpr_AST;
				currentAST.advanceChildToEnd();
			}
			unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case PLUS:
		{
			match(PLUS);
			{
			unaryExpr();
			astFactory.addASTChild(currentAST, returnAST);
			}
			if ( inputState.guessing==0 ) {
				unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(UNARY_PLUS,"+")).add(unaryExpr_AST));
				currentAST.root = unaryExpr_AST;
				currentAST.child = unaryExpr_AST!=null &&unaryExpr_AST.getFirstChild()!=null ?
					unaryExpr_AST.getFirstChild() : unaryExpr_AST;
				currentAST.advanceChildToEnd();
			}
			unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			valueExpr();
			astFactory.addASTChild(currentAST, returnAST);
			unaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = unaryExpr_AST;
	}
	
	public final void valueExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST valueExpr_AST = null;
		
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			pathExpr();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop322:
			do {
				if ((LA(1)==BANG)) {
					org.exist.xquery.parser.XQueryAST tmp315_AST = null;
					tmp315_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp315_AST);
					match(BANG);
					pathExpr();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop322;
				}
				
			} while (true);
			}
			valueExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case PRAGMA_START:
		{
			extensionExpr();
			astFactory.addASTChild(currentAST, returnAST);
			valueExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = valueExpr_AST;
	}
	
	public final void pathExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST pathExpr_AST = null;
		org.exist.xquery.parser.XQueryAST relPath_AST = null;
		org.exist.xquery.parser.XQueryAST relPath2_AST = null;
		
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			relativePathExpr();
			astFactory.addASTChild(currentAST, returnAST);
			pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case DSLASH:
		{
			org.exist.xquery.parser.XQueryAST tmp316_AST = null;
			tmp316_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp316_AST);
			match(DSLASH);
			relativePathExpr();
			relPath2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				pathExpr_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ABSOLUTE_DSLASH,"AbsoluteSlashSlash")).add(relPath2_AST));
				currentAST.root = pathExpr_AST;
				currentAST.child = pathExpr_AST!=null &&pathExpr_AST.getFirstChild()!=null ?
					pathExpr_AST.getFirstChild() : pathExpr_AST;
				currentAST.advanceChildToEnd();
			}
			pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
			boolean synPredMatched336 = false;
			if (((LA(1)==SLASH))) {
				int _m336 = mark();
				synPredMatched336 = true;
				inputState.guessing++;
				try {
					{
					match(SLASH);
					relativePathExpr();
					}
				}
				catch (RecognitionException pe) {
					synPredMatched336 = false;
				}
				rewind(_m336);
inputState.guessing--;
			}
			if ( synPredMatched336 ) {
				org.exist.xquery.parser.XQueryAST tmp317_AST = null;
				tmp317_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp317_AST);
				match(SLASH);
				relativePathExpr();
				relPath_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				if ( inputState.guessing==0 ) {
					pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					pathExpr_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ABSOLUTE_SLASH,"AbsoluteSlash")).add(relPath_AST));
					currentAST.root = pathExpr_AST;
					currentAST.child = pathExpr_AST!=null &&pathExpr_AST.getFirstChild()!=null ?
						pathExpr_AST.getFirstChild() : pathExpr_AST;
					currentAST.advanceChildToEnd();
				}
				pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else if ((LA(1)==SLASH)) {
				org.exist.xquery.parser.XQueryAST tmp318_AST = null;
				tmp318_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp318_AST);
				match(SLASH);
				if ( inputState.guessing==0 ) {
					pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					pathExpr_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(ABSOLUTE_SLASH,"AbsoluteSlash");
					currentAST.root = pathExpr_AST;
					currentAST.child = pathExpr_AST!=null &&pathExpr_AST.getFirstChild()!=null ?
						pathExpr_AST.getFirstChild() : pathExpr_AST;
					currentAST.advanceChildToEnd();
				}
				pathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = pathExpr_AST;
	}
	
	public final void extensionExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST extensionExpr_AST = null;
		
		{
		int _cnt325=0;
		_loop325:
		do {
			if ((LA(1)==PRAGMA_START)) {
				pragma();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt325>=1 ) { break _loop325; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt325++;
		} while (true);
		}
		match(LCURLY);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		extensionExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = extensionExpr_AST;
	}
	
	public final void pragma() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST pragma_AST = null;
		String name = null;
		
		try {      // for error handling
			match(PRAGMA_START);
			name=eqName();
			org.exist.xquery.parser.XQueryAST tmp322_AST = null;
			tmp322_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp322_AST);
			match(PRAGMA_END);
			if ( inputState.guessing==0 ) {
				pragma_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
				lexer.wsExplicit = false;
						pragma_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(PRAGMA,name)).add(pragma_AST));
					
				currentAST.root = pragma_AST;
				currentAST.child = pragma_AST!=null &&pragma_AST.getFirstChild()!=null ?
					pragma_AST.getFirstChild() : pragma_AST;
				currentAST.advanceChildToEnd();
			}
			pragma_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
				lexer.wsExplicit = false;
				throw new XPathException(ErrorCodes.XPST0003, "Parse error: " + e.getMessage() + " at line: " + e.getLine() + " column: " + e.getColumn());
				
			} else {
				throw e;
			}
		}
		returnAST = pragma_AST;
	}
	
	public final void intersectExceptExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST intersectExceptExpr_AST = null;
		
		instanceofExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop333:
		do {
			if ((LA(1)==LITERAL_intersect||LA(1)==LITERAL_except)) {
				{
				switch ( LA(1)) {
				case LITERAL_intersect:
				{
					org.exist.xquery.parser.XQueryAST tmp323_AST = null;
					tmp323_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp323_AST);
					match(LITERAL_intersect);
					break;
				}
				case LITERAL_except:
				{
					org.exist.xquery.parser.XQueryAST tmp324_AST = null;
					tmp324_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp324_AST);
					match(LITERAL_except);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				instanceofExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop333;
			}
			
		} while (true);
		}
		intersectExceptExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = intersectExceptExpr_AST;
	}
	
	public final void relativePathExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST relativePathExpr_AST = null;
		
		stepExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop340:
		do {
			if ((LA(1)==SLASH||LA(1)==DSLASH)) {
				{
				switch ( LA(1)) {
				case SLASH:
				{
					org.exist.xquery.parser.XQueryAST tmp325_AST = null;
					tmp325_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp325_AST);
					match(SLASH);
					break;
				}
				case DSLASH:
				{
					org.exist.xquery.parser.XQueryAST tmp326_AST = null;
					tmp326_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.makeASTRoot(currentAST, tmp326_AST);
					match(DSLASH);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				stepExpr();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop340;
			}
			
		} while (true);
		}
		relativePathExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = relativePathExpr_AST;
	}
	
	public final void stepExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST stepExpr_AST = null;
		
		boolean synPredMatched344 = false;
		if (((_tokenSet_10.member(LA(1))))) {
			int _m344 = mark();
			synPredMatched344 = true;
			inputState.guessing++;
			try {
				{
				{
				switch ( LA(1)) {
				case LITERAL_text:
				{
					match(LITERAL_text);
					break;
				}
				case LITERAL_node:
				{
					match(LITERAL_node);
					break;
				}
				case LITERAL_element:
				{
					match(LITERAL_element);
					break;
				}
				case LITERAL_attribute:
				{
					match(LITERAL_attribute);
					break;
				}
				case LITERAL_comment:
				{
					match(LITERAL_comment);
					break;
				}
				case 193:
				{
					match(193);
					break;
				}
				case 194:
				{
					match(194);
					break;
				}
				case 195:
				{
					match(195);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				match(LPAREN);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched344 = false;
			}
			rewind(_m344);
inputState.guessing--;
		}
		if ( synPredMatched344 ) {
			axisStep();
			astFactory.addASTChild(currentAST, returnAST);
			stepExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			boolean synPredMatched347 = false;
			if (((_tokenSet_11.member(LA(1))))) {
				int _m347 = mark();
				synPredMatched347 = true;
				inputState.guessing++;
				try {
					{
					{
					switch ( LA(1)) {
					case LITERAL_element:
					{
						match(LITERAL_element);
						break;
					}
					case LITERAL_attribute:
					{
						match(LITERAL_attribute);
						break;
					}
					case LITERAL_text:
					{
						match(LITERAL_text);
						break;
					}
					case LITERAL_document:
					{
						match(LITERAL_document);
						break;
					}
					case LITERAL_comment:
					{
						match(LITERAL_comment);
						break;
					}
					case 193:
					{
						match(193);
						break;
					}
					case 194:
					{
						match(194);
						break;
					}
					case LITERAL_namespace:
					{
						match(LITERAL_namespace);
						break;
					}
					case LITERAL_ordered:
					{
						match(LITERAL_ordered);
						break;
					}
					case LITERAL_unordered:
					{
						match(LITERAL_unordered);
						break;
					}
					case LITERAL_map:
					{
						match(LITERAL_map);
						break;
					}
					case LITERAL_array:
					{
						match(LITERAL_array);
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
					match(LCURLY);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched347 = false;
				}
				rewind(_m347);
inputState.guessing--;
			}
			if ( synPredMatched347 ) {
				postfixExpr();
				astFactory.addASTChild(currentAST, returnAST);
				stepExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else {
				boolean synPredMatched350 = false;
				if (((_tokenSet_11.member(LA(1))))) {
					int _m350 = mark();
					synPredMatched350 = true;
					inputState.guessing++;
					try {
						{
						{
						switch ( LA(1)) {
						case LITERAL_element:
						{
							match(LITERAL_element);
							break;
						}
						case LITERAL_attribute:
						{
							match(LITERAL_attribute);
							break;
						}
						case 194:
						{
							match(194);
							break;
						}
						case LITERAL_namespace:
						{
							match(LITERAL_namespace);
							break;
						}
						default:
						{
							throw new NoViableAltException(LT(1), getFilename());
						}
						}
						}
						eqName();
						match(LCURLY);
						}
					}
					catch (RecognitionException pe) {
						synPredMatched350 = false;
					}
					rewind(_m350);
inputState.guessing--;
				}
				if ( synPredMatched350 ) {
					postfixExpr();
					astFactory.addASTChild(currentAST, returnAST);
					stepExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				}
				else {
					boolean synPredMatched354 = false;
					if (((_tokenSet_11.member(LA(1))))) {
						int _m354 = mark();
						synPredMatched354 = true;
						inputState.guessing++;
						try {
							{
							switch ( LA(1)) {
							case MOD:
							{
								match(MOD);
								break;
							}
							case DOLLAR:
							{
								match(DOLLAR);
								break;
							}
							case QNAME:
							case LITERAL_xpointer:
							case NCNAME:
							case LITERAL_xquery:
							case LITERAL_version:
							case LITERAL_module:
							case LITERAL_namespace:
							case LITERAL_declare:
							case LITERAL_default:
							case 79:
							case LITERAL_ordering:
							case LITERAL_construction:
							case 82:
							case LITERAL_option:
							case LITERAL_function:
							case LITERAL_variable:
							case LITERAL_context:
							case LITERAL_item:
							case LITERAL_import:
							case LITERAL_encoding:
							case LITERAL_collation:
							case LITERAL_element:
							case LITERAL_order:
							case LITERAL_empty:
							case LITERAL_preserve:
							case LITERAL_strip:
							case LITERAL_ordered:
							case LITERAL_unordered:
							case 103:
							case LITERAL_inherit:
							case 105:
							case LITERAL_external:
							case LITERAL_schema:
							case BRACED_URI_LITERAL:
							case LITERAL_as:
							case LITERAL_at:
							case LITERAL_map:
							case LITERAL_array:
							case LITERAL_for:
							case LITERAL_let:
							case LITERAL_try:
							case LITERAL_some:
							case LITERAL_every:
							case LITERAL_if:
							case LITERAL_switch:
							case LITERAL_typeswitch:
							case LITERAL_update:
							case LITERAL_replace:
							case LITERAL_value:
							case LITERAL_insert:
							case LITERAL_delete:
							case LITERAL_rename:
							case LITERAL_with:
							case LITERAL_into:
							case LITERAL_preceding:
							case LITERAL_following:
							case LITERAL_catch:
							case LITERAL_return:
							case LITERAL_where:
							case LITERAL_in:
							case LITERAL_by:
							case LITERAL_stable:
							case LITERAL_group:
							case LITERAL_case:
							case LITERAL_then:
							case LITERAL_else:
							case LITERAL_or:
							case LITERAL_and:
							case LITERAL_instance:
							case LITERAL_of:
							case LITERAL_treat:
							case LITERAL_cast:
							case LITERAL_eq:
							case LITERAL_ne:
							case LITERAL_lt:
							case LITERAL_le:
							case LITERAL_gt:
							case LITERAL_ge:
							case LITERAL_is:
							case LITERAL_isnot:
							case LITERAL_to:
							case LITERAL_div:
							case LITERAL_mod:
							case LITERAL_union:
							case LITERAL_intersect:
							case LITERAL_except:
							case LITERAL_text:
							case LITERAL_node:
							case LITERAL_attribute:
							case LITERAL_comment:
							case 193:
							case 195:
							case LITERAL_document:
							case LITERAL_child:
							case LITERAL_self:
							case LITERAL_descendant:
							case 209:
							case 210:
							case LITERAL_parent:
							case LITERAL_ancestor:
							case 213:
							case 214:
							case LITERAL_collection:
							case LITERAL_validate:
							{
								{
								eqName();
								{
								switch ( LA(1)) {
								case LPAREN:
								{
									match(LPAREN);
									break;
								}
								case HASH:
								{
									match(HASH);
									break;
								}
								default:
								{
									throw new NoViableAltException(LT(1), getFilename());
								}
								}
								}
								}
								break;
							}
							case SELF:
							{
								match(SELF);
								break;
							}
							case LPAREN:
							{
								match(LPAREN);
								break;
							}
							case STRING_LITERAL:
							case INTEGER_LITERAL:
							case DOUBLE_LITERAL:
							case DECIMAL_LITERAL:
							{
								literal();
								break;
							}
							case XML_COMMENT:
							{
								match(XML_COMMENT);
								break;
							}
							case LT:
							{
								match(LT);
								break;
							}
							case XML_PI:
							{
								match(XML_PI);
								break;
							}
							case QUESTION:
							{
								match(QUESTION);
								break;
							}
							case LPPAREN:
							{
								match(LPPAREN);
								break;
							}
							case STRING_CONSTRUCTOR_START:
							{
								match(STRING_CONSTRUCTOR_START);
								break;
							}
							default:
							{
								throw new NoViableAltException(LT(1), getFilename());
							}
							}
							}
						}
						catch (RecognitionException pe) {
							synPredMatched354 = false;
						}
						rewind(_m354);
inputState.guessing--;
					}
					if ( synPredMatched354 ) {
						postfixExpr();
						astFactory.addASTChild(currentAST, returnAST);
						stepExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					}
					else if ((_tokenSet_10.member(LA(1)))) {
						axisStep();
						astFactory.addASTChild(currentAST, returnAST);
						stepExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					}
					else {
						throw new NoViableAltException(LT(1), getFilename());
					}
					}}}
					returnAST = stepExpr_AST;
				}
				
	public final void axisStep() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST axisStep_AST = null;
		
		{
		forwardOrReverseStep();
		astFactory.addASTChild(currentAST, returnAST);
		}
		predicates();
		astFactory.addASTChild(currentAST, returnAST);
		axisStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = axisStep_AST;
	}
	
	public final void postfixExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST postfixExpr_AST = null;
		
		primaryExpr();
		astFactory.addASTChild(currentAST, returnAST);
		{
		_loop390:
		do {
			switch ( LA(1)) {
			case LPPAREN:
			{
				predicate();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case LPAREN:
			{
				dynamicFunCall();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case QUESTION:
			{
				lookup();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			default:
			{
				break _loop390;
			}
			}
		} while (true);
		}
		postfixExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = postfixExpr_AST;
	}
	
	public final void forwardOrReverseStep() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST forwardOrReverseStep_AST = null;
		
		boolean synPredMatched363 = false;
		if (((_tokenSet_12.member(LA(1))))) {
			int _m363 = mark();
			synPredMatched363 = true;
			inputState.guessing++;
			try {
				{
				forwardAxisSpecifier();
				match(COLON);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched363 = false;
			}
			rewind(_m363);
inputState.guessing--;
		}
		if ( synPredMatched363 ) {
			forwardAxis();
			astFactory.addASTChild(currentAST, returnAST);
			nodeTest();
			astFactory.addASTChild(currentAST, returnAST);
			forwardOrReverseStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			boolean synPredMatched365 = false;
			if (((_tokenSet_13.member(LA(1))))) {
				int _m365 = mark();
				synPredMatched365 = true;
				inputState.guessing++;
				try {
					{
					reverseAxisSpecifier();
					match(COLON);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched365 = false;
				}
				rewind(_m365);
inputState.guessing--;
			}
			if ( synPredMatched365 ) {
				reverseAxis();
				astFactory.addASTChild(currentAST, returnAST);
				nodeTest();
				astFactory.addASTChild(currentAST, returnAST);
				forwardOrReverseStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else if ((_tokenSet_10.member(LA(1)))) {
				abbrevStep();
				astFactory.addASTChild(currentAST, returnAST);
				forwardOrReverseStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else {
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			returnAST = forwardOrReverseStep_AST;
		}
		
	public final void predicates() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST predicates_AST = null;
		
		{
		_loop359:
		do {
			if ((LA(1)==LPPAREN)) {
				predicate();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop359;
			}
			
		} while (true);
		}
		predicates_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = predicates_AST;
	}
	
	public final void predicate() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST predicate_AST = null;
		org.exist.xquery.parser.XQueryAST predExpr_AST = null;
		
		match(LPPAREN);
		expr();
		predExpr_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		match(RPPAREN);
		if ( inputState.guessing==0 ) {
			predicate_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			predicate_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(PREDICATE,"Pred")).add(predExpr_AST));
			currentAST.root = predicate_AST;
			currentAST.child = predicate_AST!=null &&predicate_AST.getFirstChild()!=null ?
				predicate_AST.getFirstChild() : predicate_AST;
			currentAST.advanceChildToEnd();
		}
		predicate_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = predicate_AST;
	}
	
	public final void forwardAxisSpecifier() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST forwardAxisSpecifier_AST = null;
		
		switch ( LA(1)) {
		case LITERAL_child:
		{
			org.exist.xquery.parser.XQueryAST tmp329_AST = null;
			tmp329_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp329_AST);
			match(LITERAL_child);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_self:
		{
			org.exist.xquery.parser.XQueryAST tmp330_AST = null;
			tmp330_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp330_AST);
			match(LITERAL_self);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_attribute:
		{
			org.exist.xquery.parser.XQueryAST tmp331_AST = null;
			tmp331_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp331_AST);
			match(LITERAL_attribute);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_descendant:
		{
			org.exist.xquery.parser.XQueryAST tmp332_AST = null;
			tmp332_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp332_AST);
			match(LITERAL_descendant);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 209:
		{
			org.exist.xquery.parser.XQueryAST tmp333_AST = null;
			tmp333_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp333_AST);
			match(209);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 210:
		{
			org.exist.xquery.parser.XQueryAST tmp334_AST = null;
			tmp334_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp334_AST);
			match(210);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_following:
		{
			org.exist.xquery.parser.XQueryAST tmp335_AST = null;
			tmp335_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp335_AST);
			match(LITERAL_following);
			forwardAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = forwardAxisSpecifier_AST;
	}
	
	public final void forwardAxis() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST forwardAxis_AST = null;
		
		forwardAxisSpecifier();
		astFactory.addASTChild(currentAST, returnAST);
		match(COLON);
		match(COLON);
		forwardAxis_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = forwardAxis_AST;
	}
	
	public final void nodeTest() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST nodeTest_AST = null;
		
		boolean synPredMatched374 = false;
		if (((_tokenSet_2.member(LA(1))))) {
			int _m374 = mark();
			synPredMatched374 = true;
			inputState.guessing++;
			try {
				{
				matchNot(EOF);
				match(LPAREN);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched374 = false;
			}
			rewind(_m374);
inputState.guessing--;
		}
		if ( synPredMatched374 ) {
			kindTest();
			astFactory.addASTChild(currentAST, returnAST);
			nodeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((_tokenSet_14.member(LA(1)))) {
			nameTest();
			astFactory.addASTChild(currentAST, returnAST);
			nodeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = nodeTest_AST;
	}
	
	public final void reverseAxisSpecifier() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST reverseAxisSpecifier_AST = null;
		
		switch ( LA(1)) {
		case LITERAL_parent:
		{
			org.exist.xquery.parser.XQueryAST tmp338_AST = null;
			tmp338_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp338_AST);
			match(LITERAL_parent);
			reverseAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ancestor:
		{
			org.exist.xquery.parser.XQueryAST tmp339_AST = null;
			tmp339_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp339_AST);
			match(LITERAL_ancestor);
			reverseAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 213:
		{
			org.exist.xquery.parser.XQueryAST tmp340_AST = null;
			tmp340_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp340_AST);
			match(213);
			reverseAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 214:
		{
			org.exist.xquery.parser.XQueryAST tmp341_AST = null;
			tmp341_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp341_AST);
			match(214);
			reverseAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_preceding:
		{
			org.exist.xquery.parser.XQueryAST tmp342_AST = null;
			tmp342_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp342_AST);
			match(LITERAL_preceding);
			reverseAxisSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = reverseAxisSpecifier_AST;
	}
	
	public final void reverseAxis() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST reverseAxis_AST = null;
		
		reverseAxisSpecifier();
		astFactory.addASTChild(currentAST, returnAST);
		match(COLON);
		match(COLON);
		reverseAxis_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = reverseAxis_AST;
	}
	
	public final void abbrevStep() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST abbrevStep_AST = null;
		
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case AT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			{
			switch ( LA(1)) {
			case AT:
			{
				org.exist.xquery.parser.XQueryAST tmp345_AST = null;
				tmp345_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp345_AST);
				match(AT);
				break;
			}
			case QNAME:
			case LITERAL_xpointer:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case STAR:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case LITERAL_div:
			case LITERAL_mod:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			nodeTest();
			astFactory.addASTChild(currentAST, returnAST);
			abbrevStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case PARENT:
		{
			org.exist.xquery.parser.XQueryAST tmp346_AST = null;
			tmp346_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp346_AST);
			match(PARENT);
			abbrevStep_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = abbrevStep_AST;
	}
	
	public final void wildcard() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST wildcard_AST = null;
		String name= null;
		
		boolean synPredMatched381 = false;
		if (((LA(1)==STAR))) {
			int _m381 = mark();
			synPredMatched381 = true;
			inputState.guessing++;
			try {
				{
				match(STAR);
				match(COLON);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched381 = false;
			}
			rewind(_m381);
inputState.guessing--;
		}
		if ( synPredMatched381 ) {
			match(STAR);
			match(COLON);
			name=ncnameOrKeyword();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				wildcard_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(PREFIX_WILDCARD,"*")).add((org.exist.xquery.parser.XQueryAST)astFactory.create(NCNAME,name)));
				currentAST.root = wildcard_AST;
				currentAST.child = wildcard_AST!=null &&wildcard_AST.getFirstChild()!=null ?
					wildcard_AST.getFirstChild() : wildcard_AST;
				currentAST.advanceChildToEnd();
			}
			wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((_tokenSet_15.member(LA(1)))) {
			name=ncnameOrKeyword();
			astFactory.addASTChild(currentAST, returnAST);
			match(COLON);
			match(STAR);
			if ( inputState.guessing==0 ) {
				wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				wildcard_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(NCNAME,name)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(WILDCARD,"*")));
				currentAST.root = wildcard_AST;
				currentAST.child = wildcard_AST!=null &&wildcard_AST.getFirstChild()!=null ?
					wildcard_AST.getFirstChild() : wildcard_AST;
				currentAST.advanceChildToEnd();
			}
			wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==STAR)) {
			org.exist.xquery.parser.XQueryAST tmp351_AST = null;
			tmp351_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp351_AST);
			match(STAR);
			if ( inputState.guessing==0 ) {
				wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
						// make this distinct from multiplication
						wildcard_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(WILDCARD,"*");
					
				currentAST.root = wildcard_AST;
				currentAST.child = wildcard_AST!=null &&wildcard_AST.getFirstChild()!=null ?
					wildcard_AST.getFirstChild() : wildcard_AST;
				currentAST.advanceChildToEnd();
			}
			wildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = wildcard_AST;
	}
	
	public final void primaryExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST primaryExpr_AST = null;
		String varName= null;
		
		switch ( LA(1)) {
		case LT:
		case XML_COMMENT:
		case XML_PI:
		{
			directConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case QUESTION:
		{
			lookup();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case STRING_CONSTRUCTOR_START:
		{
			stringConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case SELF:
		{
			contextItemExpr();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LPAREN:
		{
			parenthesizedExpr();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case DOLLAR:
		{
			varRef();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case STRING_LITERAL:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		{
			literal();
			astFactory.addASTChild(currentAST, returnAST);
			primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
			boolean synPredMatched401 = false;
			if (((_tokenSet_16.member(LA(1))))) {
				int _m401 = mark();
				synPredMatched401 = true;
				inputState.guessing++;
				try {
					{
					{
					switch ( LA(1)) {
					case LITERAL_element:
					{
						match(LITERAL_element);
						break;
					}
					case LITERAL_attribute:
					{
						match(LITERAL_attribute);
						break;
					}
					case LITERAL_text:
					{
						match(LITERAL_text);
						break;
					}
					case LITERAL_document:
					{
						match(LITERAL_document);
						break;
					}
					case 194:
					{
						match(194);
						break;
					}
					case LITERAL_comment:
					{
						match(LITERAL_comment);
						break;
					}
					case LITERAL_namespace:
					{
						match(LITERAL_namespace);
						break;
					}
					default:
					{
						throw new NoViableAltException(LT(1), getFilename());
					}
					}
					}
					match(LCURLY);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched401 = false;
				}
				rewind(_m401);
inputState.guessing--;
			}
			if ( synPredMatched401 ) {
				computedConstructor();
				astFactory.addASTChild(currentAST, returnAST);
				primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else {
				boolean synPredMatched404 = false;
				if (((_tokenSet_16.member(LA(1))))) {
					int _m404 = mark();
					synPredMatched404 = true;
					inputState.guessing++;
					try {
						{
						{
						switch ( LA(1)) {
						case LITERAL_element:
						{
							match(LITERAL_element);
							break;
						}
						case LITERAL_attribute:
						{
							match(LITERAL_attribute);
							break;
						}
						case 194:
						{
							match(194);
							break;
						}
						case LITERAL_namespace:
						{
							match(LITERAL_namespace);
							break;
						}
						default:
						{
							throw new NoViableAltException(LT(1), getFilename());
						}
						}
						}
						qName();
						match(LCURLY);
						}
					}
					catch (RecognitionException pe) {
						synPredMatched404 = false;
					}
					rewind(_m404);
inputState.guessing--;
				}
				if ( synPredMatched404 ) {
					computedConstructor();
					astFactory.addASTChild(currentAST, returnAST);
					primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				}
				else {
					boolean synPredMatched406 = false;
					if (((LA(1)==LITERAL_ordered))) {
						int _m406 = mark();
						synPredMatched406 = true;
						inputState.guessing++;
						try {
							{
							match(LITERAL_ordered);
							match(LCURLY);
							}
						}
						catch (RecognitionException pe) {
							synPredMatched406 = false;
						}
						rewind(_m406);
inputState.guessing--;
					}
					if ( synPredMatched406 ) {
						orderedExpr();
						astFactory.addASTChild(currentAST, returnAST);
						primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					}
					else {
						boolean synPredMatched408 = false;
						if (((LA(1)==LITERAL_unordered))) {
							int _m408 = mark();
							synPredMatched408 = true;
							inputState.guessing++;
							try {
								{
								match(LITERAL_unordered);
								match(LCURLY);
								}
							}
							catch (RecognitionException pe) {
								synPredMatched408 = false;
							}
							rewind(_m408);
inputState.guessing--;
						}
						if ( synPredMatched408 ) {
							unorderedExpr();
							astFactory.addASTChild(currentAST, returnAST);
							primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
						}
						else {
							boolean synPredMatched411 = false;
							if (((LA(1)==LITERAL_array||LA(1)==LPPAREN))) {
								int _m411 = mark();
								synPredMatched411 = true;
								inputState.guessing++;
								try {
									{
									switch ( LA(1)) {
									case LPPAREN:
									{
										match(LPPAREN);
										break;
									}
									case LITERAL_array:
									{
										{
										match(LITERAL_array);
										match(LCURLY);
										}
										break;
									}
									default:
									{
										throw new NoViableAltException(LT(1), getFilename());
									}
									}
									}
								}
								catch (RecognitionException pe) {
									synPredMatched411 = false;
								}
								rewind(_m411);
inputState.guessing--;
							}
							if ( synPredMatched411 ) {
								arrayConstructor();
								astFactory.addASTChild(currentAST, returnAST);
								primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
							}
							else {
								boolean synPredMatched413 = false;
								if (((LA(1)==LITERAL_map))) {
									int _m413 = mark();
									synPredMatched413 = true;
									inputState.guessing++;
									try {
										{
										match(LITERAL_map);
										match(LCURLY);
										}
									}
									catch (RecognitionException pe) {
										synPredMatched413 = false;
									}
									rewind(_m413);
inputState.guessing--;
								}
								if ( synPredMatched413 ) {
									mapConstructor();
									astFactory.addASTChild(currentAST, returnAST);
									primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
								}
								else {
									boolean synPredMatched415 = false;
									if (((_tokenSet_17.member(LA(1))))) {
										int _m415 = mark();
										synPredMatched415 = true;
										inputState.guessing++;
										try {
											{
											if ((LA(1)==MOD)) {
												match(MOD);
											}
											else if ((LA(1)==LITERAL_function)) {
												match(LITERAL_function);
												match(LPAREN);
											}
											else if ((_tokenSet_7.member(LA(1)))) {
												eqName();
												match(HASH);
											}
											else {
												throw new NoViableAltException(LT(1), getFilename());
											}
											
											}
										}
										catch (RecognitionException pe) {
											synPredMatched415 = false;
										}
										rewind(_m415);
inputState.guessing--;
									}
									if ( synPredMatched415 ) {
										functionItemExpr();
										astFactory.addASTChild(currentAST, returnAST);
										primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
									}
									else {
										boolean synPredMatched417 = false;
										if (((_tokenSet_7.member(LA(1))))) {
											int _m417 = mark();
											synPredMatched417 = true;
											inputState.guessing++;
											try {
												{
												eqName();
												match(LPAREN);
												}
											}
											catch (RecognitionException pe) {
												synPredMatched417 = false;
											}
											rewind(_m417);
inputState.guessing--;
										}
										if ( synPredMatched417 ) {
											functionCall();
											astFactory.addASTChild(currentAST, returnAST);
											primaryExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
										}
									else {
										throw new NoViableAltException(LT(1), getFilename());
									}
									}}}}}}}}
									returnAST = primaryExpr_AST;
								}
								
	public final void dynamicFunCall() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST dynamicFunCall_AST = null;
		org.exist.xquery.parser.XQueryAST args_AST = null;
		
		argumentList();
		args_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			dynamicFunCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					dynamicFunCall_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(DYNAMIC_FCALL,"DynamicFunction")).add(args_AST));
				
			currentAST.root = dynamicFunCall_AST;
			currentAST.child = dynamicFunCall_AST!=null &&dynamicFunCall_AST.getFirstChild()!=null ?
				dynamicFunCall_AST.getFirstChild() : dynamicFunCall_AST;
			currentAST.advanceChildToEnd();
		}
		dynamicFunCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = dynamicFunCall_AST;
	}
	
	public final void lookup() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST lookup_AST = null;
		Token  q = null;
		org.exist.xquery.parser.XQueryAST q_AST = null;
		Token  pos = null;
		org.exist.xquery.parser.XQueryAST pos_AST = null;
		org.exist.xquery.parser.XQueryAST paren_AST = null;
		String name= null;
		
		q = LT(1);
		q_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(q);
		match(QUESTION);
		{
		switch ( LA(1)) {
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			name=ncnameOrKeyword();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				lookup_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					lookup_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(1)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(LOOKUP,name)));
					lookup_AST.copyLexInfo(q_AST);
						
				currentAST.root = lookup_AST;
				currentAST.child = lookup_AST!=null &&lookup_AST.getFirstChild()!=null ?
					lookup_AST.getFirstChild() : lookup_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		case INTEGER_LITERAL:
		{
			pos = LT(1);
			pos_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(pos);
			astFactory.addASTChild(currentAST, pos_AST);
			match(INTEGER_LITERAL);
			if ( inputState.guessing==0 ) {
				lookup_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					lookup_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(LOOKUP,"?")).add(pos_AST));
					lookup_AST.copyLexInfo(q_AST);
						
				currentAST.root = lookup_AST;
				currentAST.child = lookup_AST!=null &&lookup_AST.getFirstChild()!=null ?
					lookup_AST.getFirstChild() : lookup_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		case LPAREN:
		{
			parenthesizedExpr();
			paren_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				lookup_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					lookup_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(LOOKUP,"?")).add(paren_AST));
					lookup_AST.copyLexInfo(q_AST);
						
				currentAST.root = lookup_AST;
				currentAST.child = lookup_AST!=null &&lookup_AST.getFirstChild()!=null ?
					lookup_AST.getFirstChild() : lookup_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		case STAR:
		{
			org.exist.xquery.parser.XQueryAST tmp352_AST = null;
			tmp352_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp352_AST);
			match(STAR);
			if ( inputState.guessing==0 ) {
				lookup_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					lookup_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(1)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(LOOKUP,"?*")));
					lookup_AST.copyLexInfo(q_AST);
				
				currentAST.root = lookup_AST;
				currentAST.child = lookup_AST!=null &&lookup_AST.getFirstChild()!=null ?
					lookup_AST.getFirstChild() : lookup_AST;
				currentAST.advanceChildToEnd();
			}
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		lookup_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = lookup_AST;
	}
	
	public final void arrowFunctionSpecifier() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST arrowFunctionSpecifier_AST = null;
		org.exist.xquery.parser.XQueryAST n_AST = null;
		String name= null;
		
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			name=eqName();
			n_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				arrowFunctionSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
				arrowFunctionSpecifier_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(EQNAME,name);
				arrowFunctionSpecifier_AST.copyLexInfo(n_AST);
				
				currentAST.root = arrowFunctionSpecifier_AST;
				currentAST.child = arrowFunctionSpecifier_AST!=null &&arrowFunctionSpecifier_AST.getFirstChild()!=null ?
					arrowFunctionSpecifier_AST.getFirstChild() : arrowFunctionSpecifier_AST;
				currentAST.advanceChildToEnd();
			}
			arrowFunctionSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LPAREN:
		{
			parenthesizedExpr();
			astFactory.addASTChild(currentAST, returnAST);
			arrowFunctionSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case DOLLAR:
		{
			varRef();
			astFactory.addASTChild(currentAST, returnAST);
			arrowFunctionSpecifier_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = arrowFunctionSpecifier_AST;
	}
	
	public final void argumentList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST argumentList_AST = null;
		
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			argument();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop458:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					argument();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop458;
				}
				
			} while (true);
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		argumentList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = argumentList_AST;
	}
	
	public final void parenthesizedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST parenthesizedExpr_AST = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			expr();
			e_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			parenthesizedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			parenthesizedExpr_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(PARENTHESIZED,"Parenthesized")).add(e_AST));
			currentAST.root = parenthesizedExpr_AST;
			currentAST.child = parenthesizedExpr_AST!=null &&parenthesizedExpr_AST.getFirstChild()!=null ?
				parenthesizedExpr_AST.getFirstChild() : parenthesizedExpr_AST;
			currentAST.advanceChildToEnd();
		}
		parenthesizedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = parenthesizedExpr_AST;
	}
	
	public final void varRef() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST varRef_AST = null;
		org.exist.xquery.parser.XQueryAST v_AST = null;
		String varName = null;
		
		match(DOLLAR);
		varName=varName();
		v_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			varRef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					varRef_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(VARIABLE_REF,varName);
					varRef_AST.copyLexInfo(v_AST);
				
			currentAST.root = varRef_AST;
			currentAST.child = varRef_AST!=null &&varRef_AST.getFirstChild()!=null ?
				varRef_AST.getFirstChild() : varRef_AST;
			currentAST.advanceChildToEnd();
		}
		varRef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = varRef_AST;
	}
	
	public final void computedConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST computedConstructor_AST = null;
		
		switch ( LA(1)) {
		case LITERAL_element:
		{
			compElemConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_attribute:
		{
			compAttrConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_text:
		{
			compTextConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_namespace:
		{
			compNamespaceConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_document:
		{
			compDocumentConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 194:
		{
			compXmlPI();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_comment:
		{
			compXmlComment();
			astFactory.addASTChild(currentAST, returnAST);
			computedConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = computedConstructor_AST;
	}
	
	public final void orderedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST orderedExpr_AST = null;
		
		match(LITERAL_ordered);
		match(LCURLY);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		orderedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = orderedExpr_AST;
	}
	
	public final void unorderedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST unorderedExpr_AST = null;
		
		match(LITERAL_unordered);
		match(LCURLY);
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		unorderedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = unorderedExpr_AST;
	}
	
	public final void arrayConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST arrayConstructor_AST = null;
		Token  lp = null;
		org.exist.xquery.parser.XQueryAST lp_AST = null;
		Token  a = null;
		org.exist.xquery.parser.XQueryAST a_AST = null;
		
		switch ( LA(1)) {
		case LPPAREN:
		{
			lp = LT(1);
			lp_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(lp);
			match(LPPAREN);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				exprSingle();
				astFactory.addASTChild(currentAST, returnAST);
				{
				_loop437:
				do {
					if ((LA(1)==COMMA)) {
						match(COMMA);
						exprSingle();
						astFactory.addASTChild(currentAST, returnAST);
					}
					else {
						break _loop437;
					}
					
				} while (true);
				}
				break;
			}
			case RPPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RPPAREN);
			if ( inputState.guessing==0 ) {
				arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
				arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ARRAY,"[")).add(arrayConstructor_AST));
				arrayConstructor_AST.copyLexInfo(lp_AST);
				
				currentAST.root = arrayConstructor_AST;
				currentAST.child = arrayConstructor_AST!=null &&arrayConstructor_AST.getFirstChild()!=null ?
					arrayConstructor_AST.getFirstChild() : arrayConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_array:
		{
			a = LT(1);
			a_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(a);
			match(LITERAL_array);
			match(LCURLY);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				expr();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
				arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ARRAY,"array")).add(arrayConstructor_AST));
				arrayConstructor_AST.copyLexInfo(a_AST);
				
				currentAST.root = arrayConstructor_AST;
				currentAST.child = arrayConstructor_AST!=null &&arrayConstructor_AST.getFirstChild()!=null ?
					arrayConstructor_AST.getFirstChild() : arrayConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			arrayConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = arrayConstructor_AST;
	}
	
	public final void mapConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mapConstructor_AST = null;
		Token  a = null;
		org.exist.xquery.parser.XQueryAST a_AST = null;
		
		a = LT(1);
		a_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(a);
		match(LITERAL_map);
		match(LCURLY);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			mapAssignment();
			astFactory.addASTChild(currentAST, returnAST);
			{
			_loop431:
			do {
				if ((LA(1)==COMMA)) {
					match(COMMA);
					mapAssignment();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop431;
				}
				
			} while (true);
			}
			break;
		}
		case RCURLY:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			mapConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
			mapConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(MAP,"map")).add(mapConstructor_AST));
			mapConstructor_AST.copyLexInfo(a_AST);
			
			currentAST.root = mapConstructor_AST;
			currentAST.child = mapConstructor_AST!=null &&mapConstructor_AST.getFirstChild()!=null ?
				mapConstructor_AST.getFirstChild() : mapConstructor_AST;
			currentAST.advanceChildToEnd();
		}
		mapConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = mapConstructor_AST;
	}
	
	public final void directConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST directConstructor_AST = null;
		
		switch ( LA(1)) {
		case LT:
		{
			elementConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			directConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case XML_COMMENT:
		{
			xmlComment();
			astFactory.addASTChild(currentAST, returnAST);
			directConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case XML_PI:
		{
			xmlPI();
			astFactory.addASTChild(currentAST, returnAST);
			directConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = directConstructor_AST;
	}
	
	public final void functionItemExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionItemExpr_AST = null;
		
		boolean synPredMatched448 = false;
		if (((LA(1)==LITERAL_function||LA(1)==MOD))) {
			int _m448 = mark();
			synPredMatched448 = true;
			inputState.guessing++;
			try {
				{
				switch ( LA(1)) {
				case MOD:
				{
					match(MOD);
					break;
				}
				case LITERAL_function:
				{
					match(LITERAL_function);
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
			}
			catch (RecognitionException pe) {
				synPredMatched448 = false;
			}
			rewind(_m448);
inputState.guessing--;
		}
		if ( synPredMatched448 ) {
			inlineFunctionExpr();
			astFactory.addASTChild(currentAST, returnAST);
			functionItemExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((_tokenSet_7.member(LA(1)))) {
			namedFunctionRef();
			astFactory.addASTChild(currentAST, returnAST);
			functionItemExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = functionItemExpr_AST;
	}
	
	public final void functionCall() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST functionCall_AST = null;
		org.exist.xquery.parser.XQueryAST eq_AST = null;
		org.exist.xquery.parser.XQueryAST params_AST = null;
		String fnName= null;
		
		fnName=eqName();
		eq_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			functionCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
			functionCall_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(FUNCTION,fnName);
			
			currentAST.root = functionCall_AST;
			currentAST.child = functionCall_AST!=null &&functionCall_AST.getFirstChild()!=null ?
				functionCall_AST.getFirstChild() : functionCall_AST;
			currentAST.advanceChildToEnd();
		}
		{
		if ((LA(1)==LPAREN)) {
			argumentList();
			params_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				functionCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				functionCall_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(FUNCTION,fnName)).add(params_AST));
				currentAST.root = functionCall_AST;
				currentAST.child = functionCall_AST!=null &&functionCall_AST.getFirstChild()!=null ?
					functionCall_AST.getFirstChild() : functionCall_AST;
				currentAST.advanceChildToEnd();
			}
		}
		else if ((_tokenSet_18.member(LA(1)))) {
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		}
		if ( inputState.guessing==0 ) {
			functionCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			functionCall_AST.copyLexInfo(eq_AST);
		}
		functionCall_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = functionCall_AST;
	}
	
	public final void stringConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST stringConstructor_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp372_AST = null;
		tmp372_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp372_AST);
		match(STRING_CONSTRUCTOR_START);
		if ( inputState.guessing==0 ) {
			lexer.inStringConstructor = true;
		}
		stringConstructorContent();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			lexer.inStringConstructor = false;
		}
		match(STRING_CONSTRUCTOR_END);
		stringConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = stringConstructor_AST;
	}
	
	public final void contextItemExpr() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST contextItemExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp374_AST = null;
		tmp374_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp374_AST);
		match(SELF);
		contextItemExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = contextItemExpr_AST;
	}
	
	public final void stringConstructorContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST stringConstructorContent_AST = null;
		
		{
		_loop425:
		do {
			switch ( LA(1)) {
			case STRING_CONSTRUCTOR_CONTENT:
			{
				org.exist.xquery.parser.XQueryAST tmp375_AST = null;
				tmp375_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp375_AST);
				match(STRING_CONSTRUCTOR_CONTENT);
				break;
			}
			case STRING_CONSTRUCTOR_INTERPOLATION_START:
			{
				stringConstructorInterpolation();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			default:
			{
				break _loop425;
			}
			}
		} while (true);
		}
		stringConstructorContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = stringConstructorContent_AST;
	}
	
	public final void stringConstructorInterpolation() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST stringConstructorInterpolation_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp376_AST = null;
		tmp376_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp376_AST);
		match(STRING_CONSTRUCTOR_INTERPOLATION_START);
		if ( inputState.guessing==0 ) {
			lexer.inStringConstructor = false;
		}
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			expr();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case STRING_CONSTRUCTOR_INTERPOLATION_END:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(STRING_CONSTRUCTOR_INTERPOLATION_END);
		if ( inputState.guessing==0 ) {
			lexer.inStringConstructor = true;
		}
		stringConstructorInterpolation_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = stringConstructorInterpolation_AST;
	}
	
	public final void mapAssignment() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mapAssignment_AST = null;
		
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		org.exist.xquery.parser.XQueryAST tmp378_AST = null;
		tmp378_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp378_AST);
		match(COLON);
		{
		switch ( LA(1)) {
		case EQ:
		{
			match(EQ);
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		exprSingle();
		astFactory.addASTChild(currentAST, returnAST);
		mapAssignment_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = mapAssignment_AST;
	}
	
	public final void numericLiteral() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST numericLiteral_AST = null;
		
		switch ( LA(1)) {
		case DOUBLE_LITERAL:
		{
			org.exist.xquery.parser.XQueryAST tmp380_AST = null;
			tmp380_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp380_AST);
			match(DOUBLE_LITERAL);
			numericLiteral_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case DECIMAL_LITERAL:
		{
			org.exist.xquery.parser.XQueryAST tmp381_AST = null;
			tmp381_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp381_AST);
			match(DECIMAL_LITERAL);
			numericLiteral_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case INTEGER_LITERAL:
		{
			org.exist.xquery.parser.XQueryAST tmp382_AST = null;
			tmp382_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.makeASTRoot(currentAST, tmp382_AST);
			match(INTEGER_LITERAL);
			numericLiteral_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = numericLiteral_AST;
	}
	
	public final void inlineFunctionExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST inlineFunctionExpr_AST = null;
		org.exist.xquery.parser.XQueryAST ann_AST = null;
		Token  lp = null;
		org.exist.xquery.parser.XQueryAST lp_AST = null;
		
		try {      // for error handling
			annotations();
			ann_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			match(LITERAL_function);
			lp = LT(1);
			lp_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(lp);
			match(LPAREN);
			{
			switch ( LA(1)) {
			case DOLLAR:
			{
				paramList();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RPAREN);
			{
			switch ( LA(1)) {
			case LITERAL_as:
			{
				returnType();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case LCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			functionBody();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				inlineFunctionExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
					  	inlineFunctionExpr_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(INLINE_FUNCTION_DECL,null)).add(null).add(inlineFunctionExpr_AST));
						inlineFunctionExpr_AST.copyLexInfo(lp_AST);
					
				currentAST.root = inlineFunctionExpr_AST;
				currentAST.child = inlineFunctionExpr_AST!=null &&inlineFunctionExpr_AST.getFirstChild()!=null ?
					inlineFunctionExpr_AST.getFirstChild() : inlineFunctionExpr_AST;
				currentAST.advanceChildToEnd();
			}
			inlineFunctionExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
						if (lp_AST == null) {
							throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, "Syntax error within inline function: " + e.getMessage());
						} else {
							lp_AST.setLine(e.getLine());
							lp_AST.setColumn(e.getColumn());
							throw new XPathException(lp_AST, ErrorCodes.XPST0003, "Syntax error within user defined function: " + e.getMessage());
						}
					
			} else {
				throw e;
			}
		}
		returnAST = inlineFunctionExpr_AST;
	}
	
	public final void namedFunctionRef() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST namedFunctionRef_AST = null;
		Token  h = null;
		org.exist.xquery.parser.XQueryAST h_AST = null;
		
			String name = null;
		
		
		name=eqName();
		h = LT(1);
		h_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(h);
		match(HASH);
		org.exist.xquery.parser.XQueryAST tmp385_AST = null;
		tmp385_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp385_AST);
		match(INTEGER_LITERAL);
		if ( inputState.guessing==0 ) {
			namedFunctionRef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					namedFunctionRef_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(HASH,name)).add(namedFunctionRef_AST));
				
			currentAST.root = namedFunctionRef_AST;
			currentAST.child = namedFunctionRef_AST!=null &&namedFunctionRef_AST.getFirstChild()!=null ?
				namedFunctionRef_AST.getFirstChild() : namedFunctionRef_AST;
			currentAST.advanceChildToEnd();
		}
		namedFunctionRef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = namedFunctionRef_AST;
	}
	
	public final void argument() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST argument_AST = null;
		
		if ((LA(1)==QUESTION)) {
			argumentPlaceholder();
			astFactory.addASTChild(currentAST, returnAST);
			argument_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((_tokenSet_4.member(LA(1)))) {
			exprSingle();
			astFactory.addASTChild(currentAST, returnAST);
			argument_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = argument_AST;
	}
	
	public final void argumentPlaceholder() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST argumentPlaceholder_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp386_AST = null;
		tmp386_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp386_AST);
		match(QUESTION);
		argumentPlaceholder_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = argumentPlaceholder_AST;
	}
	
	public final void textTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST textTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp387_AST = null;
		tmp387_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp387_AST);
		match(LITERAL_text);
		match(LPAREN);
		match(RPAREN);
		textTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = textTest_AST;
	}
	
	public final void anyKindTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST anyKindTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp390_AST = null;
		tmp390_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp390_AST);
		match(LITERAL_node);
		match(LPAREN);
		match(RPAREN);
		anyKindTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = anyKindTest_AST;
	}
	
	public final void elementTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp393_AST = null;
		tmp393_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp393_AST);
		match(LITERAL_element);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			elementNameOrWildcard();
			astFactory.addASTChild(currentAST, returnAST);
			{
			switch ( LA(1)) {
			case COMMA:
			{
				match(COMMA);
				typeName();
				astFactory.addASTChild(currentAST, returnAST);
				{
				switch ( LA(1)) {
				case QUESTION:
				{
					org.exist.xquery.parser.XQueryAST tmp396_AST = null;
					tmp396_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp396_AST);
					match(QUESTION);
					break;
				}
				case RPAREN:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		elementTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = elementTest_AST;
	}
	
	public final void attributeTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeTest_AST = null;
		
		match(LITERAL_attribute);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case STAR:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			attributeNameOrWildcard();
			astFactory.addASTChild(currentAST, returnAST);
			{
			switch ( LA(1)) {
			case COMMA:
			{
				match(COMMA);
				typeName();
				astFactory.addASTChild(currentAST, returnAST);
				{
				switch ( LA(1)) {
				case QUESTION:
				{
					org.exist.xquery.parser.XQueryAST tmp401_AST = null;
					tmp401_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
					astFactory.addASTChild(currentAST, tmp401_AST);
					match(QUESTION);
					break;
				}
				case RPAREN:
				{
					break;
				}
				default:
				{
					throw new NoViableAltException(LT(1), getFilename());
				}
				}
				}
				break;
			}
			case RPAREN:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		if ( inputState.guessing==0 ) {
			attributeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			attributeTest_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_TEST,"attribute()")).add(attributeTest_AST));
			currentAST.root = attributeTest_AST;
			currentAST.child = attributeTest_AST!=null &&attributeTest_AST.getFirstChild()!=null ?
				attributeTest_AST.getFirstChild() : attributeTest_AST;
			currentAST.advanceChildToEnd();
		}
		attributeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = attributeTest_AST;
	}
	
	public final void commentTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST commentTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp403_AST = null;
		tmp403_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp403_AST);
		match(LITERAL_comment);
		match(LPAREN);
		match(RPAREN);
		commentTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = commentTest_AST;
	}
	
	public final void namespaceNodeTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST namespaceNodeTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp406_AST = null;
		tmp406_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp406_AST);
		match(193);
		match(LPAREN);
		match(RPAREN);
		namespaceNodeTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = namespaceNodeTest_AST;
	}
	
	public final void piTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST piTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp409_AST = null;
		tmp409_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp409_AST);
		match(194);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case NCNAME:
		{
			org.exist.xquery.parser.XQueryAST tmp411_AST = null;
			tmp411_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp411_AST);
			match(NCNAME);
			break;
		}
		case STRING_LITERAL:
		{
			org.exist.xquery.parser.XQueryAST tmp412_AST = null;
			tmp412_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp412_AST);
			match(STRING_LITERAL);
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		piTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = piTest_AST;
	}
	
	public final void documentTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST documentTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp414_AST = null;
		tmp414_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp414_AST);
		match(195);
		match(LPAREN);
		{
		switch ( LA(1)) {
		case LITERAL_element:
		{
			elementTest();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case 223:
		{
			schemaElementTest();
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case RPAREN:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RPAREN);
		documentTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = documentTest_AST;
	}
	
	public final void elementNameOrWildcard() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementNameOrWildcard_AST = null;
		String eq = null;
		
		switch ( LA(1)) {
		case STAR:
		{
			org.exist.xquery.parser.XQueryAST tmp417_AST = null;
			tmp417_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp417_AST);
			match(STAR);
			if ( inputState.guessing==0 ) {
				elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(WILDCARD,"*");
				currentAST.root = elementNameOrWildcard_AST;
				currentAST.child = elementNameOrWildcard_AST!=null &&elementNameOrWildcard_AST.getFirstChild()!=null ?
					elementNameOrWildcard_AST.getFirstChild() : elementNameOrWildcard_AST;
				currentAST.advanceChildToEnd();
			}
			elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			eq=eqName();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(EQNAME,eq);
				currentAST.root = elementNameOrWildcard_AST;
				currentAST.child = elementNameOrWildcard_AST!=null &&elementNameOrWildcard_AST.getFirstChild()!=null ?
					elementNameOrWildcard_AST.getFirstChild() : elementNameOrWildcard_AST;
				currentAST.advanceChildToEnd();
			}
			elementNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = elementNameOrWildcard_AST;
	}
	
	public final void typeName() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST typeName_AST = null;
		String eq = null;
		
		eq=eqName();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			typeName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			typeName_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(EQNAME,eq);
			currentAST.root = typeName_AST;
			currentAST.child = typeName_AST!=null &&typeName_AST.getFirstChild()!=null ?
				typeName_AST.getFirstChild() : typeName_AST;
			currentAST.advanceChildToEnd();
		}
		typeName_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = typeName_AST;
	}
	
	public final void attributeNameOrWildcard() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeNameOrWildcard_AST = null;
		String eq = null;
		
		switch ( LA(1)) {
		case STAR:
		{
			org.exist.xquery.parser.XQueryAST tmp418_AST = null;
			tmp418_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp418_AST);
			match(STAR);
			if ( inputState.guessing==0 ) {
				attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(WILDCARD,"*");
				currentAST.root = attributeNameOrWildcard_AST;
				currentAST.child = attributeNameOrWildcard_AST!=null &&attributeNameOrWildcard_AST.getFirstChild()!=null ?
					attributeNameOrWildcard_AST.getFirstChild() : attributeNameOrWildcard_AST;
				currentAST.advanceChildToEnd();
			}
			attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case QNAME:
		case LITERAL_xpointer:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case LITERAL_div:
		case LITERAL_mod:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 195:
		case LITERAL_document:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			eq=eqName();
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(EQNAME,eq);
				currentAST.root = attributeNameOrWildcard_AST;
				currentAST.child = attributeNameOrWildcard_AST!=null &&attributeNameOrWildcard_AST.getFirstChild()!=null ?
					attributeNameOrWildcard_AST.getFirstChild() : attributeNameOrWildcard_AST;
				currentAST.advanceChildToEnd();
			}
			attributeNameOrWildcard_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = attributeNameOrWildcard_AST;
	}
	
	public final void schemaElementTest() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST schemaElementTest_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp419_AST = null;
		tmp419_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp419_AST);
		match(223);
		match(LPAREN);
		eqName();
		astFactory.addASTChild(currentAST, returnAST);
		match(RPAREN);
		schemaElementTest_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = schemaElementTest_AST;
	}
	
	public final void elementConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementConstructor_AST = null;
		
			String name= null;
		//lexer.wsExplicit = true;
		
		
		boolean synPredMatched510 = false;
		if (((LA(1)==LT))) {
			int _m510 = mark();
			synPredMatched510 = true;
			inputState.guessing++;
			try {
				{
				match(LT);
				qName();
				{
				match(_tokenSet_19);
				}
				}
			}
			catch (RecognitionException pe) {
				synPredMatched510 = false;
			}
			rewind(_m510);
inputState.guessing--;
		}
		if ( synPredMatched510 ) {
			elementWithAttributes();
			astFactory.addASTChild(currentAST, returnAST);
			elementConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LT)) {
			elementWithoutAttributes();
			astFactory.addASTChild(currentAST, returnAST);
			elementConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = elementConstructor_AST;
	}
	
	public final void xmlComment() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST xmlComment_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp422_AST = null;
		tmp422_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp422_AST);
		match(XML_COMMENT);
		match(XML_COMMENT_END);
		xmlComment_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = xmlComment_AST;
	}
	
	public final void xmlPI() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST xmlPI_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp424_AST = null;
		tmp424_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp424_AST);
		match(XML_PI);
		match(XML_PI_END);
		xmlPI_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = xmlPI_AST;
	}
	
	public final void compElemConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compElemConstructor_AST = null;
		org.exist.xquery.parser.XQueryAST e3_AST = null;
		
			String eq;
		
		
		boolean synPredMatched488 = false;
		if (((LA(1)==LITERAL_element))) {
			int _m488 = mark();
			synPredMatched488 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_element);
				match(LCURLY);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched488 = false;
			}
			rewind(_m488);
inputState.guessing--;
		}
		if ( synPredMatched488 ) {
			match(LITERAL_element);
			match(LCURLY);
			expr();
			astFactory.addASTChild(currentAST, returnAST);
			match(RCURLY);
			match(LCURLY);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				expr();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_ELEM_CONSTRUCTOR)).add(compElemConstructor_AST));
				currentAST.root = compElemConstructor_AST;
				currentAST.child = compElemConstructor_AST!=null &&compElemConstructor_AST.getFirstChild()!=null ?
					compElemConstructor_AST.getFirstChild() : compElemConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_element)) {
			match(LITERAL_element);
			eq=eqName();
			astFactory.addASTChild(currentAST, returnAST);
			match(LCURLY);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				expr();
				e3_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_ELEM_CONSTRUCTOR,eq)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(STRING_LITERAL,eq)).add(e3_AST));
				currentAST.root = compElemConstructor_AST;
				currentAST.child = compElemConstructor_AST!=null &&compElemConstructor_AST.getFirstChild()!=null ?
					compElemConstructor_AST.getFirstChild() : compElemConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compElemConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = compElemConstructor_AST;
	}
	
	public final void compAttrConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compAttrConstructor_AST = null;
		org.exist.xquery.parser.XQueryAST e1_AST = null;
		org.exist.xquery.parser.XQueryAST e2_AST = null;
		org.exist.xquery.parser.XQueryAST e3_AST = null;
		
			String eq;
		
		
		boolean synPredMatched493 = false;
		if (((LA(1)==LITERAL_attribute))) {
			int _m493 = mark();
			synPredMatched493 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_attribute);
				match(LCURLY);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched493 = false;
			}
			rewind(_m493);
inputState.guessing--;
		}
		if ( synPredMatched493 ) {
			match(LITERAL_attribute);
			match(LCURLY);
			expr();
			e1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			match(RCURLY);
			compConstructorValue();
			e2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_ATTR_CONSTRUCTOR)).add(compAttrConstructor_AST));
				currentAST.root = compAttrConstructor_AST;
				currentAST.child = compAttrConstructor_AST!=null &&compAttrConstructor_AST.getFirstChild()!=null ?
					compAttrConstructor_AST.getFirstChild() : compAttrConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_attribute)) {
			match(LITERAL_attribute);
			eq=eqName();
			astFactory.addASTChild(currentAST, returnAST);
			compConstructorValue();
			e3_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_ATTR_CONSTRUCTOR,eq)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(STRING_LITERAL,eq)).add(e3_AST));
				currentAST.root = compAttrConstructor_AST;
				currentAST.child = compAttrConstructor_AST!=null &&compAttrConstructor_AST.getFirstChild()!=null ?
					compAttrConstructor_AST.getFirstChild() : compAttrConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compAttrConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = compAttrConstructor_AST;
	}
	
	public final void compTextConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compTextConstructor_AST = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp438_AST = null;
		tmp438_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp438_AST);
		match(LITERAL_text);
		match(LCURLY);
		expr();
		e_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			compTextConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			compTextConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_TEXT_CONSTRUCTOR,"text")).add(e_AST));
			currentAST.root = compTextConstructor_AST;
			currentAST.child = compTextConstructor_AST!=null &&compTextConstructor_AST.getFirstChild()!=null ?
				compTextConstructor_AST.getFirstChild() : compTextConstructor_AST;
			currentAST.advanceChildToEnd();
		}
		compTextConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = compTextConstructor_AST;
	}
	
	public final void compNamespaceConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compNamespaceConstructor_AST = null;
		org.exist.xquery.parser.XQueryAST e3_AST = null;
		
			String qn;
		
		
		boolean synPredMatched504 = false;
		if (((LA(1)==LITERAL_namespace))) {
			int _m504 = mark();
			synPredMatched504 = true;
			inputState.guessing++;
			try {
				{
				match(LITERAL_namespace);
				match(LCURLY);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched504 = false;
			}
			rewind(_m504);
inputState.guessing--;
		}
		if ( synPredMatched504 ) {
			match(LITERAL_namespace);
			match(LCURLY);
			expr();
			astFactory.addASTChild(currentAST, returnAST);
			match(RCURLY);
			match(LCURLY);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				expr();
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_NS_CONSTRUCTOR)).add(compNamespaceConstructor_AST));
				currentAST.root = compNamespaceConstructor_AST;
				currentAST.child = compNamespaceConstructor_AST!=null &&compNamespaceConstructor_AST.getFirstChild()!=null ?
					compNamespaceConstructor_AST.getFirstChild() : compNamespaceConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LITERAL_namespace)) {
			match(LITERAL_namespace);
			qn=qName();
			astFactory.addASTChild(currentAST, returnAST);
			match(LCURLY);
			{
			switch ( LA(1)) {
			case QNAME:
			case LITERAL_xpointer:
			case LPAREN:
			case NCNAME:
			case LITERAL_xquery:
			case LITERAL_version:
			case LITERAL_module:
			case LITERAL_namespace:
			case STRING_LITERAL:
			case LITERAL_declare:
			case LITERAL_default:
			case 79:
			case LITERAL_ordering:
			case LITERAL_construction:
			case 82:
			case LITERAL_option:
			case LITERAL_function:
			case LITERAL_variable:
			case LITERAL_context:
			case LITERAL_item:
			case MOD:
			case LITERAL_import:
			case LITERAL_encoding:
			case LITERAL_collation:
			case LITERAL_element:
			case LITERAL_order:
			case LITERAL_empty:
			case LITERAL_preserve:
			case LITERAL_strip:
			case LITERAL_ordered:
			case LITERAL_unordered:
			case 103:
			case LITERAL_inherit:
			case 105:
			case DOLLAR:
			case LITERAL_external:
			case LITERAL_schema:
			case BRACED_URI_LITERAL:
			case LITERAL_as:
			case LITERAL_at:
			case QUESTION:
			case STAR:
			case PLUS:
			case LITERAL_map:
			case LITERAL_array:
			case LITERAL_for:
			case LITERAL_let:
			case LITERAL_try:
			case LITERAL_some:
			case LITERAL_every:
			case LITERAL_if:
			case LITERAL_switch:
			case LITERAL_typeswitch:
			case LITERAL_update:
			case LITERAL_replace:
			case LITERAL_value:
			case LITERAL_insert:
			case LITERAL_delete:
			case LITERAL_rename:
			case LITERAL_with:
			case LITERAL_into:
			case LITERAL_preceding:
			case LITERAL_following:
			case LITERAL_catch:
			case LITERAL_return:
			case LITERAL_where:
			case LITERAL_in:
			case LITERAL_by:
			case LITERAL_stable:
			case LITERAL_group:
			case LITERAL_case:
			case LITERAL_then:
			case LITERAL_else:
			case LITERAL_or:
			case LITERAL_and:
			case LITERAL_instance:
			case LITERAL_of:
			case LITERAL_treat:
			case LITERAL_cast:
			case LITERAL_eq:
			case LITERAL_ne:
			case LITERAL_lt:
			case LITERAL_le:
			case LITERAL_gt:
			case LITERAL_ge:
			case LT:
			case LITERAL_is:
			case LITERAL_isnot:
			case LITERAL_to:
			case MINUS:
			case LITERAL_div:
			case LITERAL_mod:
			case PRAGMA_START:
			case LITERAL_union:
			case LITERAL_intersect:
			case LITERAL_except:
			case SLASH:
			case DSLASH:
			case LITERAL_text:
			case LITERAL_node:
			case LITERAL_attribute:
			case LITERAL_comment:
			case 193:
			case 194:
			case 195:
			case LITERAL_document:
			case SELF:
			case XML_COMMENT:
			case XML_PI:
			case LPPAREN:
			case STRING_CONSTRUCTOR_START:
			case AT:
			case PARENT:
			case LITERAL_child:
			case LITERAL_self:
			case LITERAL_descendant:
			case 209:
			case 210:
			case LITERAL_parent:
			case LITERAL_ancestor:
			case 213:
			case 214:
			case INTEGER_LITERAL:
			case DOUBLE_LITERAL:
			case DECIMAL_LITERAL:
			case LITERAL_collection:
			case LITERAL_validate:
			{
				expr();
				e3_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				break;
			}
			case RCURLY:
			{
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_NS_CONSTRUCTOR,qn)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(STRING_LITERAL,qn)).add(e3_AST));
				currentAST.root = compNamespaceConstructor_AST;
				currentAST.child = compNamespaceConstructor_AST!=null &&compNamespaceConstructor_AST.getFirstChild()!=null ?
					compNamespaceConstructor_AST.getFirstChild() : compNamespaceConstructor_AST;
				currentAST.advanceChildToEnd();
			}
			compNamespaceConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = compNamespaceConstructor_AST;
	}
	
	public final void compDocumentConstructor() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compDocumentConstructor_AST = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp449_AST = null;
		tmp449_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp449_AST);
		match(LITERAL_document);
		match(LCURLY);
		expr();
		e_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			compDocumentConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			compDocumentConstructor_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_DOC_CONSTRUCTOR,"document")).add(e_AST));
			currentAST.root = compDocumentConstructor_AST;
			currentAST.child = compDocumentConstructor_AST!=null &&compDocumentConstructor_AST.getFirstChild()!=null ?
				compDocumentConstructor_AST.getFirstChild() : compDocumentConstructor_AST;
			currentAST.advanceChildToEnd();
		}
		compDocumentConstructor_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = compDocumentConstructor_AST;
	}
	
	public final void compXmlPI() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compXmlPI_AST = null;
		org.exist.xquery.parser.XQueryAST e1_AST = null;
		org.exist.xquery.parser.XQueryAST e2_AST = null;
		org.exist.xquery.parser.XQueryAST e3_AST = null;
		
			String qn;
		
		
		boolean synPredMatched500 = false;
		if (((LA(1)==194))) {
			int _m500 = mark();
			synPredMatched500 = true;
			inputState.guessing++;
			try {
				{
				match(194);
				match(LCURLY);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched500 = false;
			}
			rewind(_m500);
inputState.guessing--;
		}
		if ( synPredMatched500 ) {
			match(194);
			match(LCURLY);
			expr();
			e1_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			match(RCURLY);
			compConstructorValue();
			e2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_PI_CONSTRUCTOR)).add(compXmlPI_AST));
				currentAST.root = compXmlPI_AST;
				currentAST.child = compXmlPI_AST!=null &&compXmlPI_AST.getFirstChild()!=null ?
					compXmlPI_AST.getFirstChild() : compXmlPI_AST;
				currentAST.advanceChildToEnd();
			}
			compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==194)) {
			match(194);
			qn=qName();
			astFactory.addASTChild(currentAST, returnAST);
			compConstructorValue();
			e3_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			if ( inputState.guessing==0 ) {
				compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(3)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_PI_CONSTRUCTOR,qn)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(STRING_LITERAL,qn)).add(e3_AST));
				currentAST.root = compXmlPI_AST;
				currentAST.child = compXmlPI_AST!=null &&compXmlPI_AST.getFirstChild()!=null ?
					compXmlPI_AST.getFirstChild() : compXmlPI_AST;
				currentAST.advanceChildToEnd();
			}
			compXmlPI_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = compXmlPI_AST;
	}
	
	public final void compXmlComment() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compXmlComment_AST = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp456_AST = null;
		tmp456_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp456_AST);
		match(LITERAL_comment);
		match(LCURLY);
		expr();
		e_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			compXmlComment_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			compXmlComment_AST = (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(COMP_COMMENT_CONSTRUCTOR,"comment")).add(e_AST));
			currentAST.root = compXmlComment_AST;
			currentAST.child = compXmlComment_AST!=null &&compXmlComment_AST.getFirstChild()!=null ?
				compXmlComment_AST.getFirstChild() : compXmlComment_AST;
			currentAST.advanceChildToEnd();
		}
		compXmlComment_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = compXmlComment_AST;
	}
	
	public final void compConstructorValue() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST compConstructorValue_AST = null;
		org.exist.xquery.parser.XQueryAST e2_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp459_AST = null;
		tmp459_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp459_AST);
		match(LCURLY);
		{
		switch ( LA(1)) {
		case QNAME:
		case LITERAL_xpointer:
		case LPAREN:
		case NCNAME:
		case LITERAL_xquery:
		case LITERAL_version:
		case LITERAL_module:
		case LITERAL_namespace:
		case STRING_LITERAL:
		case LITERAL_declare:
		case LITERAL_default:
		case 79:
		case LITERAL_ordering:
		case LITERAL_construction:
		case 82:
		case LITERAL_option:
		case LITERAL_function:
		case LITERAL_variable:
		case LITERAL_context:
		case LITERAL_item:
		case MOD:
		case LITERAL_import:
		case LITERAL_encoding:
		case LITERAL_collation:
		case LITERAL_element:
		case LITERAL_order:
		case LITERAL_empty:
		case LITERAL_preserve:
		case LITERAL_strip:
		case LITERAL_ordered:
		case LITERAL_unordered:
		case 103:
		case LITERAL_inherit:
		case 105:
		case DOLLAR:
		case LITERAL_external:
		case LITERAL_schema:
		case BRACED_URI_LITERAL:
		case LITERAL_as:
		case LITERAL_at:
		case QUESTION:
		case STAR:
		case PLUS:
		case LITERAL_map:
		case LITERAL_array:
		case LITERAL_for:
		case LITERAL_let:
		case LITERAL_try:
		case LITERAL_some:
		case LITERAL_every:
		case LITERAL_if:
		case LITERAL_switch:
		case LITERAL_typeswitch:
		case LITERAL_update:
		case LITERAL_replace:
		case LITERAL_value:
		case LITERAL_insert:
		case LITERAL_delete:
		case LITERAL_rename:
		case LITERAL_with:
		case LITERAL_into:
		case LITERAL_preceding:
		case LITERAL_following:
		case LITERAL_catch:
		case LITERAL_return:
		case LITERAL_where:
		case LITERAL_in:
		case LITERAL_by:
		case LITERAL_stable:
		case LITERAL_group:
		case LITERAL_case:
		case LITERAL_then:
		case LITERAL_else:
		case LITERAL_or:
		case LITERAL_and:
		case LITERAL_instance:
		case LITERAL_of:
		case LITERAL_treat:
		case LITERAL_cast:
		case LITERAL_eq:
		case LITERAL_ne:
		case LITERAL_lt:
		case LITERAL_le:
		case LITERAL_gt:
		case LITERAL_ge:
		case LT:
		case LITERAL_is:
		case LITERAL_isnot:
		case LITERAL_to:
		case MINUS:
		case LITERAL_div:
		case LITERAL_mod:
		case PRAGMA_START:
		case LITERAL_union:
		case LITERAL_intersect:
		case LITERAL_except:
		case SLASH:
		case DSLASH:
		case LITERAL_text:
		case LITERAL_node:
		case LITERAL_attribute:
		case LITERAL_comment:
		case 193:
		case 194:
		case 195:
		case LITERAL_document:
		case SELF:
		case XML_COMMENT:
		case XML_PI:
		case LPPAREN:
		case STRING_CONSTRUCTOR_START:
		case AT:
		case PARENT:
		case LITERAL_child:
		case LITERAL_self:
		case LITERAL_descendant:
		case 209:
		case 210:
		case LITERAL_parent:
		case LITERAL_ancestor:
		case 213:
		case 214:
		case INTEGER_LITERAL:
		case DOUBLE_LITERAL:
		case DECIMAL_LITERAL:
		case LITERAL_collection:
		case LITERAL_validate:
		{
			expr();
			e2_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			break;
		}
		case RCURLY:
		{
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		}
		match(RCURLY);
		compConstructorValue_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = compConstructorValue_AST;
	}
	
	public final void elementWithAttributes() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementWithAttributes_AST = null;
		org.exist.xquery.parser.XQueryAST q_AST = null;
		org.exist.xquery.parser.XQueryAST attrs_AST = null;
		org.exist.xquery.parser.XQueryAST content_AST = null;
		org.exist.xquery.parser.XQueryAST qn_AST = null;
		String name= null, cname=null;
		
		try {      // for error handling
			match(LT);
			name=qName();
			q_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			attributeList();
			attrs_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			{
			switch ( LA(1)) {
			case SLASH:
			{
				{
				match(SLASH);
				match(GT);
				if ( inputState.guessing==0 ) {
					elementWithAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					
									if (!elementStack.isEmpty())
										lexer.inElementContent= true;
									elementWithAttributes_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ELEMENT,name)).add(attrs_AST));
								
					currentAST.root = elementWithAttributes_AST;
					currentAST.child = elementWithAttributes_AST!=null &&elementWithAttributes_AST.getFirstChild()!=null ?
						elementWithAttributes_AST.getFirstChild() : elementWithAttributes_AST;
					currentAST.advanceChildToEnd();
				}
				}
				break;
			}
			case GT:
			{
				{
				match(GT);
				if ( inputState.guessing==0 ) {
					
									elementStack.push(name);
									lexer.inElementContent= true;
								
				}
				mixedElementContent();
				content_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				match(END_TAG_START);
				cname=qName();
				qn_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				match(GT);
				if ( inputState.guessing==0 ) {
					elementWithAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					
									if (elementStack.isEmpty())
										throw new XPathException(qn_AST, ErrorCodes.XPST0003, "Found closing tag without opening tag: " + cname);
									String prev= (String) elementStack.pop();
									if (!prev.equals(cname))
										throw new XPathException(qn_AST, ErrorCodes.XPST0003, "Found closing tag: " + cname + "; expected: " + prev);
									elementWithAttributes_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ELEMENT,cname)).add(attrs_AST));
									if (!elementStack.isEmpty()) {
										lexer.inElementContent= true;
									}
								
					currentAST.root = elementWithAttributes_AST;
					currentAST.child = elementWithAttributes_AST!=null &&elementWithAttributes_AST.getFirstChild()!=null ?
						elementWithAttributes_AST.getFirstChild() : elementWithAttributes_AST;
					currentAST.advanceChildToEnd();
				}
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			if ( inputState.guessing==0 ) {
				elementWithAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementWithAttributes_AST.copyLexInfo(q_AST);
			}
			elementWithAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
					if (e.getMessage().contains("expecting XML end tag") || e.getMessage().contains("<")) {
					            lexer.wsExplicit = false;
					            throw new XPathException(q_AST, ErrorCodes.XPST0003, "Static error: no closing end tag found for element constructor: " + name);
					        } else if (e.getMessage().contains("unexpected token")) {
					        	throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage() +
					        		" (while expecting closing tag for element constructor: " + name + ")");
					        } else {
					        	throw e;
					        }
				
			} else {
				throw e;
			}
		}
		returnAST = elementWithAttributes_AST;
	}
	
	public final void elementWithoutAttributes() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementWithoutAttributes_AST = null;
		org.exist.xquery.parser.XQueryAST q_AST = null;
		org.exist.xquery.parser.XQueryAST content_AST = null;
		org.exist.xquery.parser.XQueryAST qn_AST = null;
		String name = null, cname = null;
		
		try {      // for error handling
			org.exist.xquery.parser.XQueryAST tmp467_AST = null;
			tmp467_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp467_AST);
			match(LT);
			name=qName();
			q_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
			astFactory.addASTChild(currentAST, returnAST);
			{
			switch ( LA(1)) {
			case SLASH:
			{
				{
				match(SLASH);
				match(GT);
				if ( inputState.guessing==0 ) {
					elementWithoutAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					
									lexer.wsExplicit= false;
									if (!elementStack.isEmpty())
										lexer.inElementContent= true;
									elementWithoutAttributes_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(ELEMENT,name);
								
					currentAST.root = elementWithoutAttributes_AST;
					currentAST.child = elementWithoutAttributes_AST!=null &&elementWithoutAttributes_AST.getFirstChild()!=null ?
						elementWithoutAttributes_AST.getFirstChild() : elementWithoutAttributes_AST;
					currentAST.advanceChildToEnd();
				}
				}
				break;
			}
			case GT:
			{
				{
				match(GT);
				if ( inputState.guessing==0 ) {
					
									elementStack.push(name);
									lexer.inElementContent= true;
								
				}
				mixedElementContent();
				content_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				astFactory.addASTChild(currentAST, returnAST);
				match(END_TAG_START);
				cname=qName();
				qn_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
				match(GT);
				if ( inputState.guessing==0 ) {
					elementWithoutAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					
									if (elementStack.isEmpty())
										throw new XPathException(qn_AST, "found additional closing tag: " + cname);
									String prev= (String) elementStack.pop();
									if (!prev.equals(cname))
										throw new XPathException(qn_AST, "found closing tag: " + cname + "; expected: " + prev);
									elementWithoutAttributes_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ELEMENT,cname)).add(content_AST));
									if (!elementStack.isEmpty()) {
										lexer.inElementContent= true;
										//lexer.wsExplicit= false;
									}
								
					currentAST.root = elementWithoutAttributes_AST;
					currentAST.child = elementWithoutAttributes_AST!=null &&elementWithoutAttributes_AST.getFirstChild()!=null ?
						elementWithoutAttributes_AST.getFirstChild() : elementWithoutAttributes_AST;
					currentAST.advanceChildToEnd();
				}
				}
				break;
			}
			default:
			{
				throw new NoViableAltException(LT(1), getFilename());
			}
			}
			}
			if ( inputState.guessing==0 ) {
				elementWithoutAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementWithoutAttributes_AST.copyLexInfo(q_AST);
			}
			elementWithoutAttributes_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		catch (RecognitionException e) {
			if (inputState.guessing==0) {
				
					if (e.getMessage().contains("expecting XML end tag") || e.getMessage().contains("<")) {
					lexer.wsExplicit = false;
					throw new XPathException(q_AST, ErrorCodes.XPST0003, "No closing end tag found for element constructor: " + name);
				} else if (e.getMessage().contains("unexpected token")) {
					        	throw new XPathException(e.getLine(), e.getColumn(), ErrorCodes.XPST0003, e.getMessage() +
					        		" (while expecting closing tag for element constructor: " + name + ")");
				} else {
					throw e;
				}
				
			} else {
				throw e;
			}
		}
		returnAST = elementWithoutAttributes_AST;
	}
	
	public final void mixedElementContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST mixedElementContent_AST = null;
		
		{
		_loop535:
		do {
			if ((_tokenSet_20.member(LA(1)))) {
				elementContent();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				break _loop535;
			}
			
		} while (true);
		}
		mixedElementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = mixedElementContent_AST;
	}
	
	public final void attributeList() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeList_AST = null;
		
		{
		int _cnt521=0;
		_loop521:
		do {
			if ((_tokenSet_3.member(LA(1)))) {
				attributeDef();
				astFactory.addASTChild(currentAST, returnAST);
			}
			else {
				if ( _cnt521>=1 ) { break _loop521; } else {throw new NoViableAltException(LT(1), getFilename());}
			}
			
			_cnt521++;
		} while (true);
		}
		attributeList_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = attributeList_AST;
	}
	
	public final void attributeDef() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeDef_AST = null;
		org.exist.xquery.parser.XQueryAST q_AST = null;
		
			String name= null;
			lexer.parseStringLiterals= false;
		
		
		name=qName();
		q_AST = (org.exist.xquery.parser.XQueryAST)returnAST;
		match(EQ);
		attributeValue();
		astFactory.addASTChild(currentAST, returnAST);
		if ( inputState.guessing==0 ) {
			attributeDef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			
					attributeDef_AST= (org.exist.xquery.parser.XQueryAST)astFactory.make( (new ASTArray(2)).add((org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE,name)).add(attributeDef_AST));
					attributeDef_AST.copyLexInfo(q_AST);
				
			currentAST.root = attributeDef_AST;
			currentAST.child = attributeDef_AST!=null &&attributeDef_AST.getFirstChild()!=null ?
				attributeDef_AST.getFirstChild() : attributeDef_AST;
			currentAST.advanceChildToEnd();
		}
		attributeDef_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = attributeDef_AST;
	}
	
	public final void attributeValue() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeValue_AST = null;
		
		switch ( LA(1)) {
		case QUOT:
		{
			match(QUOT);
			if ( inputState.guessing==0 ) {
				
						lexer.inAttributeContent= true;
						lexer.attrDelimChar = '"';
					
			}
			{
			_loop525:
			do {
				if ((_tokenSet_21.member(LA(1)))) {
					quotAttrValueContent();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop525;
				}
				
			} while (true);
			}
			match(QUOT);
			if ( inputState.guessing==0 ) {
				
						lexer.parseStringLiterals= true;
						lexer.inAttributeContent= false;
					
			}
			attributeValue_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case APOS:
		{
			match(APOS);
			if ( inputState.guessing==0 ) {
				
						lexer.inAttributeContent= true;
						lexer.attrDelimChar = '\'';
					
			}
			{
			_loop527:
			do {
				if ((_tokenSet_22.member(LA(1)))) {
					aposAttrValueContent();
					astFactory.addASTChild(currentAST, returnAST);
				}
				else {
					break _loop527;
				}
				
			} while (true);
			}
			match(APOS);
			if ( inputState.guessing==0 ) {
				
						lexer.parseStringLiterals= true;
						lexer.inAttributeContent= false;
					
			}
			attributeValue_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = attributeValue_AST;
	}
	
	public final void quotAttrValueContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST quotAttrValueContent_AST = null;
		Token  c = null;
		org.exist.xquery.parser.XQueryAST c_AST = null;
		Token  e = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		switch ( LA(1)) {
		case QUOT_ATTRIBUTE_CONTENT:
		{
			c = LT(1);
			c_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(c);
			astFactory.addASTChild(currentAST, c_AST);
			match(QUOT_ATTRIBUTE_CONTENT);
			if ( inputState.guessing==0 ) {
				quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,c.getText());
				currentAST.root = quotAttrValueContent_AST;
				currentAST.child = quotAttrValueContent_AST!=null &&quotAttrValueContent_AST.getFirstChild()!=null ?
					quotAttrValueContent_AST.getFirstChild() : quotAttrValueContent_AST;
				currentAST.advanceChildToEnd();
			}
			quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case ESCAPE_QUOT:
		{
			e = LT(1);
			e_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(e);
			astFactory.addASTChild(currentAST, e_AST);
			match(ESCAPE_QUOT);
			if ( inputState.guessing==0 ) {
				quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,"\"");
				currentAST.root = quotAttrValueContent_AST;
				currentAST.child = quotAttrValueContent_AST!=null &&quotAttrValueContent_AST.getFirstChild()!=null ?
					quotAttrValueContent_AST.getFirstChild() : quotAttrValueContent_AST;
				currentAST.advanceChildToEnd();
			}
			quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LCURLY:
		case RCURLY:
		{
			attrCommonContent();
			astFactory.addASTChild(currentAST, returnAST);
			quotAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = quotAttrValueContent_AST;
	}
	
	public final void aposAttrValueContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST aposAttrValueContent_AST = null;
		Token  c = null;
		org.exist.xquery.parser.XQueryAST c_AST = null;
		Token  e = null;
		org.exist.xquery.parser.XQueryAST e_AST = null;
		
		switch ( LA(1)) {
		case APOS_ATTRIBUTE_CONTENT:
		{
			c = LT(1);
			c_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(c);
			astFactory.addASTChild(currentAST, c_AST);
			match(APOS_ATTRIBUTE_CONTENT);
			if ( inputState.guessing==0 ) {
				aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,c.getText());
				currentAST.root = aposAttrValueContent_AST;
				currentAST.child = aposAttrValueContent_AST!=null &&aposAttrValueContent_AST.getFirstChild()!=null ?
					aposAttrValueContent_AST.getFirstChild() : aposAttrValueContent_AST;
				currentAST.advanceChildToEnd();
			}
			aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case ESCAPE_APOS:
		{
			e = LT(1);
			e_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(e);
			astFactory.addASTChild(currentAST, e_AST);
			match(ESCAPE_APOS);
			if ( inputState.guessing==0 ) {
				aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,"'");
				currentAST.root = aposAttrValueContent_AST;
				currentAST.child = aposAttrValueContent_AST!=null &&aposAttrValueContent_AST.getFirstChild()!=null ?
					aposAttrValueContent_AST.getFirstChild() : aposAttrValueContent_AST;
				currentAST.advanceChildToEnd();
			}
			aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LCURLY:
		case RCURLY:
		{
			attrCommonContent();
			astFactory.addASTChild(currentAST, returnAST);
			aposAttrValueContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = aposAttrValueContent_AST;
	}
	
	public final void attrCommonContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attrCommonContent_AST = null;
		
		boolean synPredMatched532 = false;
		if (((LA(1)==LCURLY))) {
			int _m532 = mark();
			synPredMatched532 = true;
			inputState.guessing++;
			try {
				{
				match(LCURLY);
				match(LCURLY);
				}
			}
			catch (RecognitionException pe) {
				synPredMatched532 = false;
			}
			rewind(_m532);
inputState.guessing--;
		}
		if ( synPredMatched532 ) {
			org.exist.xquery.parser.XQueryAST tmp478_AST = null;
			tmp478_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp478_AST);
			match(LCURLY);
			org.exist.xquery.parser.XQueryAST tmp479_AST = null;
			tmp479_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp479_AST);
			match(LCURLY);
			if ( inputState.guessing==0 ) {
				attrCommonContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				
						lexer.inAttributeContent= true;
						lexer.parseStringLiterals = false;
						attrCommonContent_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,"{");
					
				currentAST.root = attrCommonContent_AST;
				currentAST.child = attrCommonContent_AST!=null &&attrCommonContent_AST.getFirstChild()!=null ?
					attrCommonContent_AST.getFirstChild() : attrCommonContent_AST;
				currentAST.advanceChildToEnd();
			}
			attrCommonContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==RCURLY)) {
			org.exist.xquery.parser.XQueryAST tmp480_AST = null;
			tmp480_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp480_AST);
			match(RCURLY);
			org.exist.xquery.parser.XQueryAST tmp481_AST = null;
			tmp481_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp481_AST);
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				attrCommonContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				attrCommonContent_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(ATTRIBUTE_CONTENT,"}");
				currentAST.root = attrCommonContent_AST;
				currentAST.child = attrCommonContent_AST!=null &&attrCommonContent_AST.getFirstChild()!=null ?
					attrCommonContent_AST.getFirstChild() : attrCommonContent_AST;
				currentAST.advanceChildToEnd();
			}
			attrCommonContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else if ((LA(1)==LCURLY)) {
			attributeEnclosedExpr();
			astFactory.addASTChild(currentAST, returnAST);
			attrCommonContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		
		returnAST = attrCommonContent_AST;
	}
	
	public final void attributeEnclosedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST attributeEnclosedExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp482_AST = null;
		tmp482_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp482_AST);
		match(LCURLY);
		if ( inputState.guessing==0 ) {
			
					lexer.inAttributeContent= false;
					lexer.parseStringLiterals = true;
				
		}
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			
					lexer.inAttributeContent= true;
					lexer.parseStringLiterals = false;
				
		}
		attributeEnclosedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = attributeEnclosedExpr_AST;
	}
	
	public final void elementContent() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST elementContent_AST = null;
		Token  content = null;
		org.exist.xquery.parser.XQueryAST content_AST = null;
		
		switch ( LA(1)) {
		case LT:
		{
			elementConstructor();
			astFactory.addASTChild(currentAST, returnAST);
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case RCURLY:
		{
			org.exist.xquery.parser.XQueryAST tmp484_AST = null;
			tmp484_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp484_AST);
			match(RCURLY);
			org.exist.xquery.parser.XQueryAST tmp485_AST = null;
			tmp485_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp485_AST);
			match(RCURLY);
			if ( inputState.guessing==0 ) {
				elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementContent_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(TEXT,"}");
				currentAST.root = elementContent_AST;
				currentAST.child = elementContent_AST!=null &&elementContent_AST.getFirstChild()!=null ?
					elementContent_AST.getFirstChild() : elementContent_AST;
				currentAST.advanceChildToEnd();
			}
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case ELEMENT_CONTENT:
		{
			content = LT(1);
			content_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(content);
			astFactory.addASTChild(currentAST, content_AST);
			match(ELEMENT_CONTENT);
			if ( inputState.guessing==0 ) {
				elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
				elementContent_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(TEXT,content.getText());
				currentAST.root = elementContent_AST;
				currentAST.child = elementContent_AST!=null &&elementContent_AST.getFirstChild()!=null ?
					elementContent_AST.getFirstChild() : elementContent_AST;
				currentAST.advanceChildToEnd();
			}
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case XML_COMMENT:
		{
			xmlComment();
			astFactory.addASTChild(currentAST, returnAST);
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case XML_CDATA:
		{
			cdataSection();
			astFactory.addASTChild(currentAST, returnAST);
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case XML_PI:
		{
			xmlPI();
			astFactory.addASTChild(currentAST, returnAST);
			elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
			boolean synPredMatched538 = false;
			if (((LA(1)==LCURLY))) {
				int _m538 = mark();
				synPredMatched538 = true;
				inputState.guessing++;
				try {
					{
					match(LCURLY);
					match(LCURLY);
					}
				}
				catch (RecognitionException pe) {
					synPredMatched538 = false;
				}
				rewind(_m538);
inputState.guessing--;
			}
			if ( synPredMatched538 ) {
				org.exist.xquery.parser.XQueryAST tmp486_AST = null;
				tmp486_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp486_AST);
				match(LCURLY);
				org.exist.xquery.parser.XQueryAST tmp487_AST = null;
				tmp487_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
				astFactory.addASTChild(currentAST, tmp487_AST);
				match(LCURLY);
				if ( inputState.guessing==0 ) {
					elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
					
							lexer.inElementContent= true;
							elementContent_AST= (org.exist.xquery.parser.XQueryAST)astFactory.create(TEXT,"{");
						
					currentAST.root = elementContent_AST;
					currentAST.child = elementContent_AST!=null &&elementContent_AST.getFirstChild()!=null ?
						elementContent_AST.getFirstChild() : elementContent_AST;
					currentAST.advanceChildToEnd();
				}
				elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
			else if ((LA(1)==LCURLY)) {
				enclosedExpr();
				astFactory.addASTChild(currentAST, returnAST);
				elementContent_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			}
		else {
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = elementContent_AST;
	}
	
	public final void cdataSection() throws RecognitionException, TokenStreamException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST cdataSection_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp488_AST = null;
		tmp488_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.addASTChild(currentAST, tmp488_AST);
		match(XML_CDATA);
		cdataSection_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = cdataSection_AST;
	}
	
	public final void enclosedExpr() throws RecognitionException, TokenStreamException, XPathException {
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST enclosedExpr_AST = null;
		
		org.exist.xquery.parser.XQueryAST tmp489_AST = null;
		tmp489_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
		astFactory.makeASTRoot(currentAST, tmp489_AST);
		match(LCURLY);
		if ( inputState.guessing==0 ) {
			
					globalStack.push(elementStack);
					elementStack = new ArrayDeque<>();
					lexer.inElementContent= false;
				
		}
		expr();
		astFactory.addASTChild(currentAST, returnAST);
		match(RCURLY);
		if ( inputState.guessing==0 ) {
			
					elementStack = (Deque) globalStack.pop();
					lexer.inElementContent= true;
				
		}
		enclosedExpr_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
		returnAST = enclosedExpr_AST;
	}
	
	public final String  reservedKeywords() throws RecognitionException, TokenStreamException {
		String name;
		
		returnAST = null;
		ASTPair currentAST = new ASTPair();
		org.exist.xquery.parser.XQueryAST reservedKeywords_AST = null;
		name= null;
		
		switch ( LA(1)) {
		case LITERAL_element:
		{
			org.exist.xquery.parser.XQueryAST tmp491_AST = null;
			tmp491_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp491_AST);
			match(LITERAL_element);
			if ( inputState.guessing==0 ) {
				name = "element";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_to:
		{
			org.exist.xquery.parser.XQueryAST tmp492_AST = null;
			tmp492_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp492_AST);
			match(LITERAL_to);
			if ( inputState.guessing==0 ) {
				name = "to";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_div:
		{
			org.exist.xquery.parser.XQueryAST tmp493_AST = null;
			tmp493_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp493_AST);
			match(LITERAL_div);
			if ( inputState.guessing==0 ) {
				name= "div";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_mod:
		{
			org.exist.xquery.parser.XQueryAST tmp494_AST = null;
			tmp494_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp494_AST);
			match(LITERAL_mod);
			if ( inputState.guessing==0 ) {
				name= "mod";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_text:
		{
			org.exist.xquery.parser.XQueryAST tmp495_AST = null;
			tmp495_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp495_AST);
			match(LITERAL_text);
			if ( inputState.guessing==0 ) {
				name= "text";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_node:
		{
			org.exist.xquery.parser.XQueryAST tmp496_AST = null;
			tmp496_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp496_AST);
			match(LITERAL_node);
			if ( inputState.guessing==0 ) {
				name= "node";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_or:
		{
			org.exist.xquery.parser.XQueryAST tmp497_AST = null;
			tmp497_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp497_AST);
			match(LITERAL_or);
			if ( inputState.guessing==0 ) {
				name= "or";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_and:
		{
			org.exist.xquery.parser.XQueryAST tmp498_AST = null;
			tmp498_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp498_AST);
			match(LITERAL_and);
			if ( inputState.guessing==0 ) {
				name= "and";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_child:
		{
			org.exist.xquery.parser.XQueryAST tmp499_AST = null;
			tmp499_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp499_AST);
			match(LITERAL_child);
			if ( inputState.guessing==0 ) {
				name= "child";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_parent:
		{
			org.exist.xquery.parser.XQueryAST tmp500_AST = null;
			tmp500_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp500_AST);
			match(LITERAL_parent);
			if ( inputState.guessing==0 ) {
				name= "parent";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_self:
		{
			org.exist.xquery.parser.XQueryAST tmp501_AST = null;
			tmp501_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp501_AST);
			match(LITERAL_self);
			if ( inputState.guessing==0 ) {
				name= "self";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_attribute:
		{
			org.exist.xquery.parser.XQueryAST tmp502_AST = null;
			tmp502_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp502_AST);
			match(LITERAL_attribute);
			if ( inputState.guessing==0 ) {
				name= "attribute";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_comment:
		{
			org.exist.xquery.parser.XQueryAST tmp503_AST = null;
			tmp503_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp503_AST);
			match(LITERAL_comment);
			if ( inputState.guessing==0 ) {
				name= "comment";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_document:
		{
			org.exist.xquery.parser.XQueryAST tmp504_AST = null;
			tmp504_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp504_AST);
			match(LITERAL_document);
			if ( inputState.guessing==0 ) {
				name= "document";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 195:
		{
			org.exist.xquery.parser.XQueryAST tmp505_AST = null;
			tmp505_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp505_AST);
			match(195);
			if ( inputState.guessing==0 ) {
				name= "document-node";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_collection:
		{
			org.exist.xquery.parser.XQueryAST tmp506_AST = null;
			tmp506_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp506_AST);
			match(LITERAL_collection);
			if ( inputState.guessing==0 ) {
				name= "collection";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ancestor:
		{
			org.exist.xquery.parser.XQueryAST tmp507_AST = null;
			tmp507_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp507_AST);
			match(LITERAL_ancestor);
			if ( inputState.guessing==0 ) {
				name= "ancestor";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_descendant:
		{
			org.exist.xquery.parser.XQueryAST tmp508_AST = null;
			tmp508_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp508_AST);
			match(LITERAL_descendant);
			if ( inputState.guessing==0 ) {
				name= "descendant";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 209:
		{
			org.exist.xquery.parser.XQueryAST tmp509_AST = null;
			tmp509_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp509_AST);
			match(209);
			if ( inputState.guessing==0 ) {
				name= "descendant-or-self";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 213:
		{
			org.exist.xquery.parser.XQueryAST tmp510_AST = null;
			tmp510_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp510_AST);
			match(213);
			if ( inputState.guessing==0 ) {
				name= "ancestor-or-self";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 214:
		{
			org.exist.xquery.parser.XQueryAST tmp511_AST = null;
			tmp511_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp511_AST);
			match(214);
			if ( inputState.guessing==0 ) {
				name= "preceding-sibling";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 210:
		{
			org.exist.xquery.parser.XQueryAST tmp512_AST = null;
			tmp512_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp512_AST);
			match(210);
			if ( inputState.guessing==0 ) {
				name= "following-sibling";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_following:
		{
			org.exist.xquery.parser.XQueryAST tmp513_AST = null;
			tmp513_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp513_AST);
			match(LITERAL_following);
			if ( inputState.guessing==0 ) {
				name = "following";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_preceding:
		{
			org.exist.xquery.parser.XQueryAST tmp514_AST = null;
			tmp514_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp514_AST);
			match(LITERAL_preceding);
			if ( inputState.guessing==0 ) {
				name = "preceding";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_item:
		{
			org.exist.xquery.parser.XQueryAST tmp515_AST = null;
			tmp515_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp515_AST);
			match(LITERAL_item);
			if ( inputState.guessing==0 ) {
				name= "item";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_empty:
		{
			org.exist.xquery.parser.XQueryAST tmp516_AST = null;
			tmp516_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp516_AST);
			match(LITERAL_empty);
			if ( inputState.guessing==0 ) {
				name= "empty";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_version:
		{
			org.exist.xquery.parser.XQueryAST tmp517_AST = null;
			tmp517_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp517_AST);
			match(LITERAL_version);
			if ( inputState.guessing==0 ) {
				name= "version";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_xquery:
		{
			org.exist.xquery.parser.XQueryAST tmp518_AST = null;
			tmp518_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp518_AST);
			match(LITERAL_xquery);
			if ( inputState.guessing==0 ) {
				name= "xquery";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_variable:
		{
			org.exist.xquery.parser.XQueryAST tmp519_AST = null;
			tmp519_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp519_AST);
			match(LITERAL_variable);
			if ( inputState.guessing==0 ) {
				name= "variable";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 193:
		{
			org.exist.xquery.parser.XQueryAST tmp520_AST = null;
			tmp520_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp520_AST);
			match(193);
			if ( inputState.guessing==0 ) {
				name= "namespace-node";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_namespace:
		{
			org.exist.xquery.parser.XQueryAST tmp521_AST = null;
			tmp521_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp521_AST);
			match(LITERAL_namespace);
			if ( inputState.guessing==0 ) {
				name= "namespace";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_if:
		{
			org.exist.xquery.parser.XQueryAST tmp522_AST = null;
			tmp522_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp522_AST);
			match(LITERAL_if);
			if ( inputState.guessing==0 ) {
				name= "if";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_then:
		{
			org.exist.xquery.parser.XQueryAST tmp523_AST = null;
			tmp523_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp523_AST);
			match(LITERAL_then);
			if ( inputState.guessing==0 ) {
				name= "then";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_else:
		{
			org.exist.xquery.parser.XQueryAST tmp524_AST = null;
			tmp524_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp524_AST);
			match(LITERAL_else);
			if ( inputState.guessing==0 ) {
				name= "else";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_for:
		{
			org.exist.xquery.parser.XQueryAST tmp525_AST = null;
			tmp525_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp525_AST);
			match(LITERAL_for);
			if ( inputState.guessing==0 ) {
				name= "for";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_where:
		{
			org.exist.xquery.parser.XQueryAST tmp526_AST = null;
			tmp526_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp526_AST);
			match(LITERAL_where);
			if ( inputState.guessing==0 ) {
				name= "where";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_in:
		{
			org.exist.xquery.parser.XQueryAST tmp527_AST = null;
			tmp527_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp527_AST);
			match(LITERAL_in);
			if ( inputState.guessing==0 ) {
				name = "in";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_let:
		{
			org.exist.xquery.parser.XQueryAST tmp528_AST = null;
			tmp528_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp528_AST);
			match(LITERAL_let);
			if ( inputState.guessing==0 ) {
				name= "let";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_try:
		{
			org.exist.xquery.parser.XQueryAST tmp529_AST = null;
			tmp529_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp529_AST);
			match(LITERAL_try);
			if ( inputState.guessing==0 ) {
				name="try";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_catch:
		{
			org.exist.xquery.parser.XQueryAST tmp530_AST = null;
			tmp530_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp530_AST);
			match(LITERAL_catch);
			if ( inputState.guessing==0 ) {
				name="catch";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_default:
		{
			org.exist.xquery.parser.XQueryAST tmp531_AST = null;
			tmp531_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp531_AST);
			match(LITERAL_default);
			if ( inputState.guessing==0 ) {
				name= "default";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_function:
		{
			org.exist.xquery.parser.XQueryAST tmp532_AST = null;
			tmp532_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp532_AST);
			match(LITERAL_function);
			if ( inputState.guessing==0 ) {
				name= "function";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_external:
		{
			org.exist.xquery.parser.XQueryAST tmp533_AST = null;
			tmp533_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp533_AST);
			match(LITERAL_external);
			if ( inputState.guessing==0 ) {
				name = "external";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_as:
		{
			org.exist.xquery.parser.XQueryAST tmp534_AST = null;
			tmp534_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp534_AST);
			match(LITERAL_as);
			if ( inputState.guessing==0 ) {
				name = "as";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_union:
		{
			org.exist.xquery.parser.XQueryAST tmp535_AST = null;
			tmp535_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp535_AST);
			match(LITERAL_union);
			if ( inputState.guessing==0 ) {
				name = "union";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_intersect:
		{
			org.exist.xquery.parser.XQueryAST tmp536_AST = null;
			tmp536_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp536_AST);
			match(LITERAL_intersect);
			if ( inputState.guessing==0 ) {
				name = "intersect";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_except:
		{
			org.exist.xquery.parser.XQueryAST tmp537_AST = null;
			tmp537_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp537_AST);
			match(LITERAL_except);
			if ( inputState.guessing==0 ) {
				name = "except";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_order:
		{
			org.exist.xquery.parser.XQueryAST tmp538_AST = null;
			tmp538_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp538_AST);
			match(LITERAL_order);
			if ( inputState.guessing==0 ) {
				name = "order";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_stable:
		{
			org.exist.xquery.parser.XQueryAST tmp539_AST = null;
			tmp539_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp539_AST);
			match(LITERAL_stable);
			if ( inputState.guessing==0 ) {
				name = "stable";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_by:
		{
			org.exist.xquery.parser.XQueryAST tmp540_AST = null;
			tmp540_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp540_AST);
			match(LITERAL_by);
			if ( inputState.guessing==0 ) {
				name = "by";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_group:
		{
			org.exist.xquery.parser.XQueryAST tmp541_AST = null;
			tmp541_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp541_AST);
			match(LITERAL_group);
			if ( inputState.guessing==0 ) {
				name = "group";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_some:
		{
			org.exist.xquery.parser.XQueryAST tmp542_AST = null;
			tmp542_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp542_AST);
			match(LITERAL_some);
			if ( inputState.guessing==0 ) {
				name = "some";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_every:
		{
			org.exist.xquery.parser.XQueryAST tmp543_AST = null;
			tmp543_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp543_AST);
			match(LITERAL_every);
			if ( inputState.guessing==0 ) {
				name = "every";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_is:
		{
			org.exist.xquery.parser.XQueryAST tmp544_AST = null;
			tmp544_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp544_AST);
			match(LITERAL_is);
			if ( inputState.guessing==0 ) {
				name = "is";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_isnot:
		{
			org.exist.xquery.parser.XQueryAST tmp545_AST = null;
			tmp545_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp545_AST);
			match(LITERAL_isnot);
			if ( inputState.guessing==0 ) {
				name = "isnot";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_module:
		{
			org.exist.xquery.parser.XQueryAST tmp546_AST = null;
			tmp546_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp546_AST);
			match(LITERAL_module);
			if ( inputState.guessing==0 ) {
				name = "module";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_import:
		{
			org.exist.xquery.parser.XQueryAST tmp547_AST = null;
			tmp547_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp547_AST);
			match(LITERAL_import);
			if ( inputState.guessing==0 ) {
				name = "import";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_at:
		{
			org.exist.xquery.parser.XQueryAST tmp548_AST = null;
			tmp548_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp548_AST);
			match(LITERAL_at);
			if ( inputState.guessing==0 ) {
				name = "at";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_cast:
		{
			org.exist.xquery.parser.XQueryAST tmp549_AST = null;
			tmp549_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp549_AST);
			match(LITERAL_cast);
			if ( inputState.guessing==0 ) {
				name = "cast";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_return:
		{
			org.exist.xquery.parser.XQueryAST tmp550_AST = null;
			tmp550_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp550_AST);
			match(LITERAL_return);
			if ( inputState.guessing==0 ) {
				name = "return";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_instance:
		{
			org.exist.xquery.parser.XQueryAST tmp551_AST = null;
			tmp551_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp551_AST);
			match(LITERAL_instance);
			if ( inputState.guessing==0 ) {
				name = "instance";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_of:
		{
			org.exist.xquery.parser.XQueryAST tmp552_AST = null;
			tmp552_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp552_AST);
			match(LITERAL_of);
			if ( inputState.guessing==0 ) {
				name = "of";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_declare:
		{
			org.exist.xquery.parser.XQueryAST tmp553_AST = null;
			tmp553_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp553_AST);
			match(LITERAL_declare);
			if ( inputState.guessing==0 ) {
				name = "declare";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_collation:
		{
			org.exist.xquery.parser.XQueryAST tmp554_AST = null;
			tmp554_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp554_AST);
			match(LITERAL_collation);
			if ( inputState.guessing==0 ) {
				name = "collation";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 79:
		{
			org.exist.xquery.parser.XQueryAST tmp555_AST = null;
			tmp555_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp555_AST);
			match(79);
			if ( inputState.guessing==0 ) {
				name = "boundary-space";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_preserve:
		{
			org.exist.xquery.parser.XQueryAST tmp556_AST = null;
			tmp556_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp556_AST);
			match(LITERAL_preserve);
			if ( inputState.guessing==0 ) {
				name = "preserve";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_strip:
		{
			org.exist.xquery.parser.XQueryAST tmp557_AST = null;
			tmp557_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp557_AST);
			match(LITERAL_strip);
			if ( inputState.guessing==0 ) {
				name = "strip";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ordering:
		{
			org.exist.xquery.parser.XQueryAST tmp558_AST = null;
			tmp558_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp558_AST);
			match(LITERAL_ordering);
			if ( inputState.guessing==0 ) {
				name = "ordering";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_construction:
		{
			org.exist.xquery.parser.XQueryAST tmp559_AST = null;
			tmp559_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp559_AST);
			match(LITERAL_construction);
			if ( inputState.guessing==0 ) {
				name = "construction";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_context:
		{
			org.exist.xquery.parser.XQueryAST tmp560_AST = null;
			tmp560_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp560_AST);
			match(LITERAL_context);
			if ( inputState.guessing==0 ) {
				name = "context";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ordered:
		{
			org.exist.xquery.parser.XQueryAST tmp561_AST = null;
			tmp561_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp561_AST);
			match(LITERAL_ordered);
			if ( inputState.guessing==0 ) {
				name = "ordered";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_unordered:
		{
			org.exist.xquery.parser.XQueryAST tmp562_AST = null;
			tmp562_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp562_AST);
			match(LITERAL_unordered);
			if ( inputState.guessing==0 ) {
				name = "unordered";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_typeswitch:
		{
			org.exist.xquery.parser.XQueryAST tmp563_AST = null;
			tmp563_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp563_AST);
			match(LITERAL_typeswitch);
			if ( inputState.guessing==0 ) {
				name = "typeswitch";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_switch:
		{
			org.exist.xquery.parser.XQueryAST tmp564_AST = null;
			tmp564_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp564_AST);
			match(LITERAL_switch);
			if ( inputState.guessing==0 ) {
				name = "switch";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_encoding:
		{
			org.exist.xquery.parser.XQueryAST tmp565_AST = null;
			tmp565_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp565_AST);
			match(LITERAL_encoding);
			if ( inputState.guessing==0 ) {
				name = "encoding";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 82:
		{
			org.exist.xquery.parser.XQueryAST tmp566_AST = null;
			tmp566_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp566_AST);
			match(82);
			if ( inputState.guessing==0 ) {
				name = "base-uri";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_update:
		{
			org.exist.xquery.parser.XQueryAST tmp567_AST = null;
			tmp567_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp567_AST);
			match(LITERAL_update);
			if ( inputState.guessing==0 ) {
				name = "update";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_replace:
		{
			org.exist.xquery.parser.XQueryAST tmp568_AST = null;
			tmp568_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp568_AST);
			match(LITERAL_replace);
			if ( inputState.guessing==0 ) {
				name = "replace";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_delete:
		{
			org.exist.xquery.parser.XQueryAST tmp569_AST = null;
			tmp569_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp569_AST);
			match(LITERAL_delete);
			if ( inputState.guessing==0 ) {
				name = "delete";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_value:
		{
			org.exist.xquery.parser.XQueryAST tmp570_AST = null;
			tmp570_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp570_AST);
			match(LITERAL_value);
			if ( inputState.guessing==0 ) {
				name = "value";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_insert:
		{
			org.exist.xquery.parser.XQueryAST tmp571_AST = null;
			tmp571_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp571_AST);
			match(LITERAL_insert);
			if ( inputState.guessing==0 ) {
				name = "insert";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_with:
		{
			org.exist.xquery.parser.XQueryAST tmp572_AST = null;
			tmp572_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp572_AST);
			match(LITERAL_with);
			if ( inputState.guessing==0 ) {
				name = "with";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_into:
		{
			org.exist.xquery.parser.XQueryAST tmp573_AST = null;
			tmp573_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp573_AST);
			match(LITERAL_into);
			if ( inputState.guessing==0 ) {
				name = "into";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_rename:
		{
			org.exist.xquery.parser.XQueryAST tmp574_AST = null;
			tmp574_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp574_AST);
			match(LITERAL_rename);
			if ( inputState.guessing==0 ) {
				name = "rename";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_option:
		{
			org.exist.xquery.parser.XQueryAST tmp575_AST = null;
			tmp575_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp575_AST);
			match(LITERAL_option);
			if ( inputState.guessing==0 ) {
				name = "option";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_case:
		{
			org.exist.xquery.parser.XQueryAST tmp576_AST = null;
			tmp576_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp576_AST);
			match(LITERAL_case);
			if ( inputState.guessing==0 ) {
				name = "case";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_validate:
		{
			org.exist.xquery.parser.XQueryAST tmp577_AST = null;
			tmp577_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp577_AST);
			match(LITERAL_validate);
			if ( inputState.guessing==0 ) {
				name = "validate";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_schema:
		{
			org.exist.xquery.parser.XQueryAST tmp578_AST = null;
			tmp578_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp578_AST);
			match(LITERAL_schema);
			if ( inputState.guessing==0 ) {
				name = "schema";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_treat:
		{
			org.exist.xquery.parser.XQueryAST tmp579_AST = null;
			tmp579_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp579_AST);
			match(LITERAL_treat);
			if ( inputState.guessing==0 ) {
				name = "treat";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 103:
		{
			org.exist.xquery.parser.XQueryAST tmp580_AST = null;
			tmp580_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp580_AST);
			match(103);
			if ( inputState.guessing==0 ) {
				name = "no-preserve";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_inherit:
		{
			org.exist.xquery.parser.XQueryAST tmp581_AST = null;
			tmp581_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp581_AST);
			match(LITERAL_inherit);
			if ( inputState.guessing==0 ) {
				name = "inherit";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case 105:
		{
			org.exist.xquery.parser.XQueryAST tmp582_AST = null;
			tmp582_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp582_AST);
			match(105);
			if ( inputState.guessing==0 ) {
				name = "no-inherit";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_eq:
		{
			org.exist.xquery.parser.XQueryAST tmp583_AST = null;
			tmp583_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp583_AST);
			match(LITERAL_eq);
			if ( inputState.guessing==0 ) {
				name="eq";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ne:
		{
			org.exist.xquery.parser.XQueryAST tmp584_AST = null;
			tmp584_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp584_AST);
			match(LITERAL_ne);
			if ( inputState.guessing==0 ) {
				name = "ne";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_lt:
		{
			org.exist.xquery.parser.XQueryAST tmp585_AST = null;
			tmp585_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp585_AST);
			match(LITERAL_lt);
			if ( inputState.guessing==0 ) {
				name = "lt";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_le:
		{
			org.exist.xquery.parser.XQueryAST tmp586_AST = null;
			tmp586_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp586_AST);
			match(LITERAL_le);
			if ( inputState.guessing==0 ) {
				name = "le";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_gt:
		{
			org.exist.xquery.parser.XQueryAST tmp587_AST = null;
			tmp587_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp587_AST);
			match(LITERAL_gt);
			if ( inputState.guessing==0 ) {
				name = "gt";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_ge:
		{
			org.exist.xquery.parser.XQueryAST tmp588_AST = null;
			tmp588_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp588_AST);
			match(LITERAL_ge);
			if ( inputState.guessing==0 ) {
				name = "ge";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_xpointer:
		{
			org.exist.xquery.parser.XQueryAST tmp589_AST = null;
			tmp589_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp589_AST);
			match(LITERAL_xpointer);
			if ( inputState.guessing==0 ) {
				name = "xpointer";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_map:
		{
			org.exist.xquery.parser.XQueryAST tmp590_AST = null;
			tmp590_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp590_AST);
			match(LITERAL_map);
			if ( inputState.guessing==0 ) {
				name = "map";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		case LITERAL_array:
		{
			org.exist.xquery.parser.XQueryAST tmp591_AST = null;
			tmp591_AST = (org.exist.xquery.parser.XQueryAST)astFactory.create(LT(1));
			astFactory.addASTChild(currentAST, tmp591_AST);
			match(LITERAL_array);
			if ( inputState.guessing==0 ) {
				name = "array";
			}
			reservedKeywords_AST = (org.exist.xquery.parser.XQueryAST)currentAST.root;
			break;
		}
		default:
		{
			throw new NoViableAltException(LT(1), getFilename());
		}
		}
		returnAST = reservedKeywords_AST;
		return name;
	}
	
	
	public static final String[] _tokenNames = {
		"<0>",
		"EOF",
		"<2>",
		"NULL_TREE_LOOKAHEAD",
		"qname",
		"EQNAME",
		"PREDICATE",
		"FLWOR",
		"PARENTHESIZED",
		"ABSOLUTE_SLASH",
		"ABSOLUTE_DSLASH",
		"WILDCARD",
		"PREFIX_WILDCARD",
		"FUNCTION",
		"DYNAMIC_FCALL",
		"UNARY_MINUS",
		"UNARY_PLUS",
		"XPOINTER",
		"XPOINTER_ID",
		"VARIABLE_REF",
		"VARIABLE_BINDING",
		"ELEMENT",
		"ATTRIBUTE",
		"ATTRIBUTE_CONTENT",
		"TEXT",
		"VERSION_DECL",
		"NAMESPACE_DECL",
		"DEF_NAMESPACE_DECL",
		"DEF_COLLATION_DECL",
		"DEF_FUNCTION_NS_DECL",
		"CONTEXT_ITEM_DECL",
		"ANNOT_DECL",
		"GLOBAL_VAR",
		"FUNCTION_DECL",
		"INLINE_FUNCTION_DECL",
		"FUNCTION_INLINE",
		"FUNCTION_TEST",
		"MAP",
		"MAP_TEST",
		"LOOKUP",
		"ARRAY",
		"ARRAY_TEST",
		"PROLOG",
		"OPTION",
		"ATOMIC_TYPE",
		"MODULE",
		"ORDER_BY",
		"GROUP_BY",
		"POSITIONAL_VAR",
		"CATCH_ERROR_CODE",
		"CATCH_ERROR_DESC",
		"CATCH_ERROR_VAL",
		"MODULE_DECL",
		"MODULE_IMPORT",
		"SCHEMA_IMPORT",
		"ATTRIBUTE_TEST",
		"COMP_ELEM_CONSTRUCTOR",
		"COMP_ATTR_CONSTRUCTOR",
		"COMP_TEXT_CONSTRUCTOR",
		"COMP_COMMENT_CONSTRUCTOR",
		"COMP_PI_CONSTRUCTOR",
		"COMP_NS_CONSTRUCTOR",
		"COMP_DOC_CONSTRUCTOR",
		"PRAGMA",
		"GTEQ",
		"SEQUENCE",
		"\"xpointer\"",
		"opening parenthesis '('",
		"closing parenthesis ')'",
		"ncname",
		"\"xquery\"",
		"\"version\"",
		"semicolon ';'",
		"\"module\"",
		"\"namespace\"",
		"=",
		"string literal",
		"\"declare\"",
		"\"default\"",
		"\"boundary-space\"",
		"\"ordering\"",
		"\"construction\"",
		"\"base-uri\"",
		"\"copy-namespaces\"",
		"\"option\"",
		"\"function\"",
		"\"variable\"",
		"\"context\"",
		"\"item\"",
		"MOD",
		"\"import\"",
		"\"encoding\"",
		"\"collation\"",
		"\"element\"",
		"\"order\"",
		"\"empty\"",
		"\"greatest\"",
		"\"least\"",
		"\"preserve\"",
		"\"strip\"",
		"\"ordered\"",
		"\"unordered\"",
		"COMMA",
		"\"no-preserve\"",
		"\"inherit\"",
		"\"no-inherit\"",
		"dollar sign '$'",
		"\"external\"",
		"COLON",
		"opening curly brace '{'",
		"closing curly brace '}'",
		"\"schema\"",
		"braced uri literal",
		"\"as\"",
		"\"at\"",
		"\"empty-sequence\"",
		"question mark '?'",
		"wildcard '*'",
		"+",
		"\"map\"",
		"\"array\"",
		"\"for\"",
		"\"let\"",
		"\"try\"",
		"\"some\"",
		"\"every\"",
		"\"if\"",
		"\"switch\"",
		"\"typeswitch\"",
		"\"update\"",
		"\"replace\"",
		"\"value\"",
		"\"insert\"",
		"\"delete\"",
		"\"rename\"",
		"\"with\"",
		"\"into\"",
		"\"preceding\"",
		"\"following\"",
		"\"catch\"",
		"union",
		"\"return\"",
		"\"where\"",
		"\"in\"",
		"\"allowing\"",
		"\"by\"",
		"\"stable\"",
		"\"ascending\"",
		"\"descending\"",
		"\"group\"",
		"\"satisfies\"",
		"\"case\"",
		"\"then\"",
		"\"else\"",
		"\"or\"",
		"\"and\"",
		"\"instance\"",
		"\"of\"",
		"\"treat\"",
		"\"castable\"",
		"\"cast\"",
		"BEFORE",
		"AFTER",
		"\"eq\"",
		"\"ne\"",
		"\"lt\"",
		"\"le\"",
		"\"gt\"",
		"\"ge\"",
		">",
		"!=",
		"<",
		"<=",
		"\"is\"",
		"\"isnot\"",
		"||",
		"\"to\"",
		"-",
		"\"div\"",
		"\"idiv\"",
		"\"mod\"",
		"BANG",
		"PRAGMA_START",
		"pragma expression",
		"\"union\"",
		"\"intersect\"",
		"\"except\"",
		"single slash '/'",
		"double slash '//'",
		"\"text\"",
		"\"node\"",
		"\"attribute\"",
		"\"comment\"",
		"\"namespace-node\"",
		"\"processing-instruction\"",
		"\"document-node\"",
		"\"document\"",
		"HASH",
		".",
		"XML comment",
		"processing instruction",
		"opening brace '['",
		"start of string constructor",
		"closing brace ']'",
		"@ char",
		"..",
		"\"child\"",
		"\"self\"",
		"\"descendant\"",
		"\"descendant-or-self\"",
		"\"following-sibling\"",
		"\"parent\"",
		"\"ancestor\"",
		"\"ancestor-or-self\"",
		"\"preceding-sibling\"",
		"arrow operator",
		"INTEGER_LITERAL",
		"start of string constructor",
		"string constructor content",
		"start of interpolated expression",
		"end of interpolated expression",
		"DOUBLE_LITERAL",
		"DECIMAL_LITERAL",
		"\"schema-element\"",
		"XML end tag",
		"double quote '\\\"'",
		"single quote '",
		"QUOT_ATTRIBUTE_CONTENT",
		"ESCAPE_QUOT",
		"APOS_ATTRIBUTE_CONTENT",
		"ESCAPE_APOS",
		"ELEMENT_CONTENT",
		"end of XML comment",
		"end of processing instruction",
		"CDATA section",
		"\"collection\"",
		"\"validate\"",
		"start of processing instruction",
		"CDATA section start",
		"end of CDATA section",
		"LETTER",
		"DIGITS",
		"HEX_DIGITS",
		"WS",
		"XQuery XQDoc comment",
		"XQuery comment",
		"PREDEFINED_ENTITY_REF",
		"CHAR_REF",
		"S",
		"NEXT_TOKEN",
		"NAME_START_CHAR",
		"NAME_CHAR",
		"CHAR",
		"BASECHAR",
		"IDEOGRAPHIC",
		"COMBINING_CHAR",
		"DIGIT",
		"EXTENDER"
	};
	
	protected void buildTokenTypeASTClassMap() {
		tokenTypeToASTClassMap=null;
	};
	
	private static final long[] mk_tokenSet_0() {
		long[] data = new long[8];
		data[0]=18L;
		data[1]=-2375232879331604L;
		data[2]=-47452750754680833L;
		data[3]=26389914843103L;
		return data;
	}
	public static final BitSet _tokenSet_0 = new BitSet(mk_tokenSet_0());
	private static final long[] mk_tokenSet_1() {
		long[] data = new long[8];
		data[0]=2L;
		data[1]=465691831242344720L;
		data[2]=513410349450262400L;
		data[3]=268437504L;
		return data;
	}
	public static final BitSet _tokenSet_1 = new BitSet(mk_tokenSet_1());
	private static final long[] mk_tokenSet_2() {
		long[] data = new long[8];
		data[1]=536870912L;
		data[2]=-2305843009213693952L;
		data[3]=15L;
		return data;
	}
	public static final BitSet _tokenSet_2 = new BitSet(mk_tokenSet_2());
	private static final long[] mk_tokenSet_3() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-34186303327705372L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_3 = new BitSet(mk_tokenSet_3());
	private static final long[] mk_tokenSet_4() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-2375232879331604L;
		data[2]=-47452750754680833L;
		data[3]=26389914843103L;
		return data;
	}
	public static final BitSet _tokenSet_4 = new BitSet(mk_tokenSet_4());
	private static final long[] mk_tokenSet_5() {
		long[] data = { 0L, 432345565301309440L, 2375680L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_5 = new BitSet(mk_tokenSet_5());
	private static final long[] mk_tokenSet_6() {
		long[] data = new long[8];
		data[1]=-25179104072964380L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_6 = new BitSet(mk_tokenSet_6());
	private static final long[] mk_tokenSet_7() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-33904828350994716L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_7 = new BitSet(mk_tokenSet_7());
	private static final long[] mk_tokenSet_8() {
		long[] data = { 0L, 2048L, 32985348833280L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_8 = new BitSet(mk_tokenSet_8());
	private static final long[] mk_tokenSet_9() {
		long[] data = { 0L, 9007199254740992L, 7881299347898368L, 0L, 0L, 0L};
		return data;
	}
	public static final BitSet _tokenSet_9 = new BitSet(mk_tokenSet_9());
	private static final long[] mk_tokenSet_10() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-24897629096253724L;
		data[2]=-1795421152220876801L;
		data[3]=26388287451167L;
		return data;
	}
	public static final BitSet _tokenSet_10 = new BitSet(mk_tokenSet_10());
	private static final long[] mk_tokenSet_11() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-29396830643554580L;
		data[2]=-1795412356127854593L;
		data[3]=26389914830815L;
		return data;
	}
	public static final BitSet _tokenSet_11 = new BitSet(mk_tokenSet_11());
	private static final long[] mk_tokenSet_12() {
		long[] data = new long[8];
		data[2]=-9223372036854774784L;
		data[3]=507904L;
		return data;
	}
	public static final BitSet _tokenSet_12 = new BitSet(mk_tokenSet_12());
	private static final long[] mk_tokenSet_13() {
		long[] data = new long[8];
		data[2]=512L;
		data[3]=7864320L;
		return data;
	}
	public static final BitSet _tokenSet_13 = new BitSet(mk_tokenSet_13());
	private static final long[] mk_tokenSet_14() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-24897629096253724L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_14 = new BitSet(mk_tokenSet_14());
	private static final long[] mk_tokenSet_15() {
		long[] data = new long[8];
		data[1]=-34186303327705372L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_15 = new BitSet(mk_tokenSet_15());
	private static final long[] mk_tokenSet_16() {
		long[] data = new long[8];
		data[1]=536871936L;
		data[2]=-6917529027641081856L;
		data[3]=21L;
		return data;
	}
	public static final BitSet _tokenSet_16 = new BitSet(mk_tokenSet_16());
	private static final long[] mk_tokenSet_17() {
		long[] data = new long[8];
		data[0]=16L;
		data[1]=-33904828317440284L;
		data[2]=-1795421152220876801L;
		data[3]=26388287438875L;
		return data;
	}
	public static final BitSet _tokenSet_17 = new BitSet(mk_tokenSet_17());
	private static final long[] mk_tokenSet_18() {
		long[] data = new long[8];
		data[0]=2L;
		data[1]=464521950870391064L;
		data[2]=2251799813131368320L;
		data[3]=276826624L;
		return data;
	}
	public static final BitSet _tokenSet_18 = new BitSet(mk_tokenSet_18());
	private static final long[] mk_tokenSet_19() {
		long[] data = new long[12];
		data[0]=-16L;
		data[1]=-1L;
		data[2]=-576462951326679041L;
		data[3]=-1L;
		data[4]=3L;
		return data;
	}
	public static final BitSet _tokenSet_19 = new BitSet(mk_tokenSet_19());
	private static final long[] mk_tokenSet_20() {
		long[] data = new long[8];
		data[1]=105553116266496L;
		data[2]=8796093022208L;
		data[3]=4947802325376L;
		return data;
	}
	public static final BitSet _tokenSet_20 = new BitSet(mk_tokenSet_20());
	private static final long[] mk_tokenSet_21() {
		long[] data = new long[8];
		data[1]=105553116266496L;
		data[3]=103079215104L;
		return data;
	}
	public static final BitSet _tokenSet_21 = new BitSet(mk_tokenSet_21());
	private static final long[] mk_tokenSet_22() {
		long[] data = new long[8];
		data[1]=105553116266496L;
		data[3]=412316860416L;
		return data;
	}
	public static final BitSet _tokenSet_22 = new BitSet(mk_tokenSet_22());
	
	}
